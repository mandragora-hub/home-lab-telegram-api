// Autogenerated types for TDLib v1.8.19 (2589c3fd46925f5d57e4ec79233cd1bd0f5d0c09)
declare module 'tdlib-types' {
  export type error = {
    /**
     * An object of this type can be returned on every function call, in case of an
     * error
     */
    _: 'error',
    /**
     * Error code; subject to future changes. If the error code is 406, the error message
     * must not be processed in any way and must not be displayed to the user
     */
    code: number,
    /** Error message; subject to future changes */
    message: string,
  }

  export type error$Input = {
    /**
     * An object of this type can be returned on every function call, in case of an
     * error
     */
    readonly _: 'error',
    /**
     * Error code; subject to future changes. If the error code is 406, the error message
     * must not be processed in any way and must not be displayed to the user
     */
    readonly code?: number,
    /** Error message; subject to future changes */
    readonly message?: string,
  }

  export type ok = {
    /**
     * An object of this type is returned on a successful function call for certain
     * functions
     */
    _: 'ok',
  }

  export type authenticationCodeTypeTelegramMessage = {
    /**
     * An authentication code is delivered via a private Telegram message, which can
     * be viewed from another active session
     */
    _: 'authenticationCodeTypeTelegramMessage',
    /** Length of the code */
    length: number,
  }

  export type authenticationCodeTypeSms = {
    /**
     * An authentication code is delivered via an SMS message to the specified phone
     * number; applications may not receive this type of code
     */
    _: 'authenticationCodeTypeSms',
    /** Length of the code */
    length: number,
  }

  export type authenticationCodeTypeCall = {
    /**
     * An authentication code is delivered via a phone call to the specified phone
     * number
     */
    _: 'authenticationCodeTypeCall',
    /** Length of the code */
    length: number,
  }

  export type authenticationCodeTypeFlashCall = {
    /**
     * An authentication code is delivered by an immediately canceled call to the specified
     * phone number. The phone number that calls is the code that must be entered automatically
     */
    _: 'authenticationCodeTypeFlashCall',
    /** Pattern of the phone number from which the call will be made */
    pattern: string,
  }

  export type authenticationCodeTypeMissedCall = {
    /**
     * An authentication code is delivered by an immediately canceled call to the specified
     * phone number. The last digits of the phone number that calls are the code that
     * must be entered manually by the user
     */
    _: 'authenticationCodeTypeMissedCall',
    /** Prefix of the phone number from which the call will be made */
    phone_number_prefix: string,
    /** Number of digits in the code, excluding the prefix */
    length: number,
  }

  export type authenticationCodeTypeFragment = {
    /**
     * An authentication code is delivered to https://fragment.com. The user must be
     * logged in there via a wallet owning the phone number's NFT
     */
    _: 'authenticationCodeTypeFragment',
    /** URL to open to receive the code */
    url: string,
    /** Length of the code */
    length: number,
  }

  export type authenticationCodeTypeFirebaseAndroid = {
    /**
     * An authentication code is delivered via Firebase Authentication to the official
     * Android application
     */
    _: 'authenticationCodeTypeFirebaseAndroid',
    /** Nonce to pass to the SafetyNet Attestation API */
    nonce: string,
    /** Length of the code */
    length: number,
  }

  export type authenticationCodeTypeFirebaseIos = {
    /**
     * An authentication code is delivered via Firebase Authentication to the official
     * iOS application
     */
    _: 'authenticationCodeTypeFirebaseIos',
    /**
     * Receipt of successful application token validation to compare with receipt from
     * push notification
     */
    receipt: string,
    /**
     * Time after the next authentication method is supposed to be used if verification
     * push notification isn't received, in seconds
     */
    push_timeout: number,
    /** Length of the code */
    length: number,
  }

  export type authenticationCodeInfo = {
    /** Information about the authentication code that was sent */
    _: 'authenticationCodeInfo',
    /** A phone number that is being authenticated */
    phone_number: string,
    /** The way the code was sent to the user */
    type: AuthenticationCodeType,
    /** The way the next code will be sent to the user; may be null */
    next_type?: AuthenticationCodeType,
    /** Timeout before the code can be re-sent, in seconds */
    timeout: number,
  }

  export type emailAddressAuthenticationCodeInfo = {
    /** Information about the email address authentication code that was sent */
    _: 'emailAddressAuthenticationCodeInfo',
    /** Pattern of the email address to which an authentication code was sent */
    email_address_pattern: string,
    /** Length of the code; 0 if unknown */
    length: number,
  }

  export type emailAddressAuthenticationCode$Input = {
    /** An authentication code delivered to a user's email address */
    readonly _: 'emailAddressAuthenticationCode',
    /** The code */
    readonly code?: string,
  }

  export type emailAddressAuthenticationAppleId$Input = {
    /** An authentication token received through Apple ID */
    readonly _: 'emailAddressAuthenticationAppleId',
    /** The token */
    readonly token?: string,
  }

  export type emailAddressAuthenticationGoogleId$Input = {
    /** An authentication token received through Google ID */
    readonly _: 'emailAddressAuthenticationGoogleId',
    /** The token */
    readonly token?: string,
  }

  export type emailAddressResetStateAvailable = {
    /**
     * Email address can be reset after the given period. Call resetAuthenticationEmailAddress
     * to reset it and allow the user to authorize with a code sent to the user's phone
     * number
     */
    _: 'emailAddressResetStateAvailable',
    /**
     * Time required to wait before the email address can be reset; 0 if the user is
     * subscribed to Telegram Premium
     */
    wait_period: number,
  }

  export type emailAddressResetStatePending = {
    /**
     * Email address reset has already been requested. Call resetAuthenticationEmailAddress
     * to check whether immediate reset is possible
     */
    _: 'emailAddressResetStatePending',
    /**
     * Left time before the email address will be reset, in seconds. updateAuthorizationState
     * is not sent when this field changes
     */
    reset_in: number,
  }

  export type textEntity = {
    /** Represents a part of the text that needs to be formatted in some unusual way */
    _: 'textEntity',
    /** Offset of the entity, in UTF-16 code units */
    offset: number,
    /** Length of the entity, in UTF-16 code units */
    length: number,
    /** Type of the entity */
    type: TextEntityType,
  }

  export type textEntity$Input = {
    /** Represents a part of the text that needs to be formatted in some unusual way */
    readonly _: 'textEntity',
    /** Offset of the entity, in UTF-16 code units */
    readonly offset?: number,
    /** Length of the entity, in UTF-16 code units */
    readonly length?: number,
    /** Type of the entity */
    readonly type?: TextEntityType$Input,
  }

  export type textEntities = {
    /** Contains a list of text entities */
    _: 'textEntities',
    /** List of text entities */
    entities: Array<textEntity>,
  }

  export type formattedText = {
    /** A text with some entities */
    _: 'formattedText',
    /** The text */
    text: string,
    /**
     * Entities contained in the text. Entities can be nested, but must not mutually
     * intersect with each other. Pre, Code and PreCode entities can't contain other
     * entities. Bold, Italic, Underline, Strikethrough, and Spoiler entities can contain
     * and can be part of any other entities. All other entities can't contain each
     * other
     */
    entities: Array<textEntity>,
  }

  export type formattedText$Input = {
    /** A text with some entities */
    readonly _: 'formattedText',
    /** The text */
    readonly text?: string,
    /**
     * Entities contained in the text. Entities can be nested, but must not mutually
     * intersect with each other. Pre, Code and PreCode entities can't contain other
     * entities. Bold, Italic, Underline, Strikethrough, and Spoiler entities can contain
     * and can be part of any other entities. All other entities can't contain each
     * other
     */
    readonly entities?: ReadonlyArray<textEntity$Input>,
  }

  export type termsOfService = {
    /** Contains Telegram terms of service */
    _: 'termsOfService',
    /** Text of the terms of service */
    text: formattedText,
    /** The minimum age of a user to be able to accept the terms; 0 if age isn't restricted */
    min_user_age: number,
    /** True, if a blocking popup with terms of service must be shown to the user */
    show_popup: boolean,
  }

  export type authorizationStateWaitTdlibParameters = {
    /** Initialization parameters are needed. Call setTdlibParameters to provide them */
    _: 'authorizationStateWaitTdlibParameters',
  }

  export type authorizationStateWaitPhoneNumber = {
    /**
     * TDLib needs the user's phone number to authorize. Call setAuthenticationPhoneNumber
     * to provide the phone number, or use requestQrCodeAuthentication or checkAuthenticationBotToken
     * for other authentication options
     */
    _: 'authorizationStateWaitPhoneNumber',
  }

  export type authorizationStateWaitEmailAddress = {
    /**
     * TDLib needs the user's email address to authorize. Call setAuthenticationEmailAddress
     * to provide the email address, or directly call checkAuthenticationEmailCode
     * with Apple ID/Google ID token if allowed
     */
    _: 'authorizationStateWaitEmailAddress',
    /** True, if authorization through Apple ID is allowed */
    allow_apple_id: boolean,
    /** True, if authorization through Google ID is allowed */
    allow_google_id: boolean,
  }

  export type authorizationStateWaitEmailCode = {
    /**
     * TDLib needs the user's authentication code sent to an email address to authorize.
     * Call checkAuthenticationEmailCode to provide the code
     */
    _: 'authorizationStateWaitEmailCode',
    /** True, if authorization through Apple ID is allowed */
    allow_apple_id: boolean,
    /** True, if authorization through Google ID is allowed */
    allow_google_id: boolean,
    /** Information about the sent authentication code */
    code_info: emailAddressAuthenticationCodeInfo,
    /**
     * Reset state of the email address; may be null if the email address can't be
     * reset
     */
    email_address_reset_state?: EmailAddressResetState,
  }

  export type authorizationStateWaitCode = {
    /**
     * TDLib needs the user's authentication code to authorize. Call checkAuthenticationCode
     * to check the code
     */
    _: 'authorizationStateWaitCode',
    /** Information about the authorization code that was sent */
    code_info: authenticationCodeInfo,
  }

  export type authorizationStateWaitOtherDeviceConfirmation = {
    /**
     * The user needs to confirm authorization on another logged in device by scanning
     * a QR code with the provided link
     */
    _: 'authorizationStateWaitOtherDeviceConfirmation',
    /** A tg:// URL for the QR code. The link will be updated frequently */
    link: string,
  }

  export type authorizationStateWaitRegistration = {
    /**
     * The user is unregistered and need to accept terms of service and enter their
     * first name and last name to finish registration. Call registerUser to accept
     * the terms of service and provide the data
     */
    _: 'authorizationStateWaitRegistration',
    /** Telegram terms of service */
    terms_of_service: termsOfService,
  }

  export type authorizationStateWaitPassword = {
    /**
     * The user has been authorized, but needs to enter a 2-step verification password
     * to start using the application. Call checkAuthenticationPassword to provide
     * the password, or requestAuthenticationPasswordRecovery to recover the password,
     * or deleteAccount to delete the account after a week
     */
    _: 'authorizationStateWaitPassword',
    /** Hint for the password; may be empty */
    password_hint: string,
    /** True, if a recovery email address has been set up */
    has_recovery_email_address: boolean,
    /** True, if some Telegram Passport elements were saved */
    has_passport_data: boolean,
    /**
     * Pattern of the email address to which the recovery email was sent; empty until
     * a recovery email has been sent
     */
    recovery_email_address_pattern: string,
  }

  export type authorizationStateReady = {
    /**
     * The user has been successfully authorized. TDLib is now ready to answer general
     * requests
     */
    _: 'authorizationStateReady',
  }

  export type authorizationStateLoggingOut = {
    /** The user is currently logging out */
    _: 'authorizationStateLoggingOut',
  }

  export type authorizationStateClosing = {
    /**
     * TDLib is closing, all subsequent queries will be answered with the error 500.
     * Note that closing TDLib can take a while. All resources will be freed only after
     * authorizationStateClosed has been received
     */
    _: 'authorizationStateClosing',
  }

  export type authorizationStateClosed = {
    /**
     * TDLib client is in its final state. All databases are closed and all resources
     * are released. No other updates will be received after this. All queries will
     * be responded to with error code 500. To continue working, one must create a
     * new instance of the TDLib client
     */
    _: 'authorizationStateClosed',
  }

  export type passwordState = {
    /** Represents the current state of 2-step verification */
    _: 'passwordState',
    /** True, if a 2-step verification password is set */
    has_password: boolean,
    /** Hint for the password; may be empty */
    password_hint: string,
    /** True, if a recovery email is set */
    has_recovery_email_address: boolean,
    /** True, if some Telegram Passport elements were saved */
    has_passport_data: boolean,
    /**
     * Information about the recovery email address to which the confirmation email
     * was sent; may be null
     */
    recovery_email_address_code_info?: emailAddressAuthenticationCodeInfo,
    /** Pattern of the email address set up for logging in */
    login_email_address_pattern: string,
    /**
     * If not 0, point in time (Unix timestamp) after which the 2-step verification
     * password can be reset immediately using resetPassword
     */
    pending_reset_date: number,
  }

  export type recoveryEmailAddress = {
    /** Contains information about the current recovery email address */
    _: 'recoveryEmailAddress',
    /** Recovery email address */
    recovery_email_address: string,
  }

  export type temporaryPasswordState = {
    /**
     * Returns information about the availability of a temporary password, which can
     * be used for payments
     */
    _: 'temporaryPasswordState',
    /** True, if a temporary password is available */
    has_password: boolean,
    /** Time left before the temporary password expires, in seconds */
    valid_for: number,
  }

  export type localFile = {
    /** Represents a local file */
    _: 'localFile',
    /** Local path to the locally available file part; may be empty */
    path: string,
    /** True, if it is possible to download or generate the file */
    can_be_downloaded: boolean,
    /** True, if the file can be deleted */
    can_be_deleted: boolean,
    /**
     * True, if the file is currently being downloaded (or a local copy is being generated
     * by some other means)
     */
    is_downloading_active: boolean,
    /** True, if the local copy is fully available */
    is_downloading_completed: boolean,
    /**
     * Download will be started from this offset. downloaded_prefix_size is calculated
     * from this offset
     */
    download_offset: number,
    /**
     * If is_downloading_completed is false, then only some prefix of the file starting
     * from download_offset is ready to be read. downloaded_prefix_size is the size
     * of that prefix in bytes
     */
    downloaded_prefix_size: number,
    /**
     * Total downloaded file size, in bytes. Can be used only for calculating download
     * progress. The actual file size may be bigger, and some parts of it may contain
     * garbage
     */
    downloaded_size: number,
  }

  export type remoteFile = {
    /** Represents a remote file */
    _: 'remoteFile',
    /**
     * Remote file identifier; may be empty. Can be used by the current user across
     * application restarts or even from other devices. Uniquely identifies a file,
     * but a file can have a lot of different valid identifiers. If the identifier
     * starts with "http://" or "https://", it represents the HTTP URL of the file.
     * TDLib is currently unable to download files if only their URL is known. If downloadFile/addFileToDownloads
     * is called on such a file or if it is sent to a secret chat, TDLib starts a file
     * generation process by sending updateFileGenerationStart to the application with
     * the HTTP URL in the original_path and "#url#" as the conversion string. Application
     * must generate the file by downloading it to the specified location
     */
    id: string,
    /**
     * Unique file identifier; may be empty if unknown. The unique file identifier
     * which is the same for the same file even for different users and is persistent
     * over time
     */
    unique_id: string,
    /**
     * True, if the file is currently being uploaded (or a remote copy is being generated
     * by some other means)
     */
    is_uploading_active: boolean,
    /** True, if a remote copy is fully available */
    is_uploading_completed: boolean,
    /** Size of the remote available part of the file, in bytes; 0 if unknown */
    uploaded_size: number,
  }

  export type file = {
    /** Represents a file */
    _: 'file',
    /** Unique file identifier */
    id: number,
    /** File size, in bytes; 0 if unknown */
    size: number,
    /**
     * Approximate file size in bytes in case the exact file size is unknown. Can be
     * used to show download/upload progress
     */
    expected_size: number,
    /** Information about the local copy of the file */
    local: localFile,
    /** Information about the remote copy of the file */
    remote: remoteFile,
  }

  export type inputFileId = {
    /** A file defined by its unique identifier */
    _: 'inputFileId',
    /** Unique file identifier */
    id: number,
  }

  export type inputFileId$Input = {
    /** A file defined by its unique identifier */
    readonly _: 'inputFileId',
    /** Unique file identifier */
    readonly id?: number,
  }

  export type inputFileRemote = {
    /**
     * A file defined by its remote identifier. The remote identifier is guaranteed
     * to be usable only if the corresponding file is still accessible to the user
     * and known to TDLib. For example, if the file is from a message, then the message
     * must be not deleted and accessible to the user. If the file database is disabled,
     * then the corresponding object with the file must be preloaded by the application
     */
    _: 'inputFileRemote',
    /** Remote file identifier */
    id: string,
  }

  export type inputFileRemote$Input = {
    /**
     * A file defined by its remote identifier. The remote identifier is guaranteed
     * to be usable only if the corresponding file is still accessible to the user
     * and known to TDLib. For example, if the file is from a message, then the message
     * must be not deleted and accessible to the user. If the file database is disabled,
     * then the corresponding object with the file must be preloaded by the application
     */
    readonly _: 'inputFileRemote',
    /** Remote file identifier */
    readonly id?: string,
  }

  export type inputFileLocal = {
    /** A file defined by a local path */
    _: 'inputFileLocal',
    /** Local path to the file */
    path: string,
  }

  export type inputFileLocal$Input = {
    /** A file defined by a local path */
    readonly _: 'inputFileLocal',
    /** Local path to the file */
    readonly path?: string,
  }

  export type inputFileGenerated = {
    /** A file generated by the application */
    _: 'inputFileGenerated',
    /**
     * Local path to a file from which the file is generated; may be empty if there
     * is no such file
     */
    original_path: string,
    /**
     * String specifying the conversion applied to the original file; must be persistent
     * across application restarts. Conversions beginning with '#' are reserved for
     * internal TDLib usage
     */
    conversion: string,
    /** Expected size of the generated file, in bytes; 0 if unknown */
    expected_size: number,
  }

  export type inputFileGenerated$Input = {
    /** A file generated by the application */
    readonly _: 'inputFileGenerated',
    /**
     * Local path to a file from which the file is generated; may be empty if there
     * is no such file
     */
    readonly original_path?: string,
    /**
     * String specifying the conversion applied to the original file; must be persistent
     * across application restarts. Conversions beginning with '#' are reserved for
     * internal TDLib usage
     */
    readonly conversion?: string,
    /** Expected size of the generated file, in bytes; 0 if unknown */
    readonly expected_size?: number,
  }

  export type photoSize = {
    /** Describes an image in JPEG format */
    _: 'photoSize',
    /** Image type (see https://core.telegram.org/constructor/photoSize) */
    type: string,
    /** Information about the image file */
    photo: file,
    /** Image width */
    width: number,
    /** Image height */
    height: number,
    /**
     * Sizes of progressive JPEG file prefixes, which can be used to preliminarily
     * show the image; in bytes
     */
    progressive_sizes: Array<number>,
  }

  export type minithumbnail = {
    /** Thumbnail image of a very poor quality and low resolution */
    _: 'minithumbnail',
    /** Thumbnail width, usually doesn't exceed 40 */
    width: number,
    /** Thumbnail height, usually doesn't exceed 40 */
    height: number,
    /** The thumbnail in JPEG format */
    data: string,
  }

  export type thumbnailFormatJpeg = {
    /** The thumbnail is in JPEG format */
    _: 'thumbnailFormatJpeg',
  }

  export type thumbnailFormatGif = {
    /**
     * The thumbnail is in static GIF format. It will be used only for some bot inline
     * query results
     */
    _: 'thumbnailFormatGif',
  }

  export type thumbnailFormatMpeg4 = {
    /**
     * The thumbnail is in MPEG4 format. It will be used only for some animations and
     * videos
     */
    _: 'thumbnailFormatMpeg4',
  }

  export type thumbnailFormatPng = {
    /** The thumbnail is in PNG format. It will be used only for background patterns */
    _: 'thumbnailFormatPng',
  }

  export type thumbnailFormatTgs = {
    /** The thumbnail is in TGS format. It will be used only for TGS sticker sets */
    _: 'thumbnailFormatTgs',
  }

  export type thumbnailFormatWebm = {
    /** The thumbnail is in WEBM format. It will be used only for WEBM sticker sets */
    _: 'thumbnailFormatWebm',
  }

  export type thumbnailFormatWebp = {
    /** The thumbnail is in WEBP format. It will be used only for some stickers */
    _: 'thumbnailFormatWebp',
  }

  export type thumbnail = {
    /** Represents a thumbnail */
    _: 'thumbnail',
    /** Thumbnail format */
    format: ThumbnailFormat,
    /** Thumbnail width */
    width: number,
    /** Thumbnail height */
    height: number,
    /** The thumbnail */
    file: file,
  }

  export type maskPointForehead = {
    /** The mask is placed relatively to the forehead */
    _: 'maskPointForehead',
  }

  export type maskPointForehead$Input = {
    /** The mask is placed relatively to the forehead */
    readonly _: 'maskPointForehead',
  }

  export type maskPointEyes = {
    /** The mask is placed relatively to the eyes */
    _: 'maskPointEyes',
  }

  export type maskPointEyes$Input = {
    /** The mask is placed relatively to the eyes */
    readonly _: 'maskPointEyes',
  }

  export type maskPointMouth = {
    /** The mask is placed relatively to the mouth */
    _: 'maskPointMouth',
  }

  export type maskPointMouth$Input = {
    /** The mask is placed relatively to the mouth */
    readonly _: 'maskPointMouth',
  }

  export type maskPointChin = {
    /** The mask is placed relatively to the chin */
    _: 'maskPointChin',
  }

  export type maskPointChin$Input = {
    /** The mask is placed relatively to the chin */
    readonly _: 'maskPointChin',
  }

  export type maskPosition = {
    /** Position on a photo where a mask is placed */
    _: 'maskPosition',
    /** Part of the face, relative to which the mask is placed */
    point: MaskPoint,
    /**
     * Shift by X-axis measured in widths of the mask scaled to the face size, from
     * left to right. (For example, -1.0 will place the mask just to the left of the
     * default mask position)
     */
    x_shift: number,
    /**
     * Shift by Y-axis measured in heights of the mask scaled to the face size, from
     * top to bottom. (For example, 1.0 will place the mask just below the default
     * mask position)
     */
    y_shift: number,
    /** Mask scaling coefficient. (For example, 2.0 means a doubled size) */
    scale: number,
  }

  export type maskPosition$Input = {
    /** Position on a photo where a mask is placed */
    readonly _: 'maskPosition',
    /** Part of the face, relative to which the mask is placed */
    readonly point?: MaskPoint$Input,
    /**
     * Shift by X-axis measured in widths of the mask scaled to the face size, from
     * left to right. (For example, -1.0 will place the mask just to the left of the
     * default mask position)
     */
    readonly x_shift?: number,
    /**
     * Shift by Y-axis measured in heights of the mask scaled to the face size, from
     * top to bottom. (For example, 1.0 will place the mask just below the default
     * mask position)
     */
    readonly y_shift?: number,
    /** Mask scaling coefficient. (For example, 2.0 means a doubled size) */
    readonly scale?: number,
  }

  export type stickerFormatWebp = {
    /** The sticker is an image in WEBP format */
    _: 'stickerFormatWebp',
  }

  export type stickerFormatWebp$Input = {
    /** The sticker is an image in WEBP format */
    readonly _: 'stickerFormatWebp',
  }

  export type stickerFormatTgs = {
    /** The sticker is an animation in TGS format */
    _: 'stickerFormatTgs',
  }

  export type stickerFormatTgs$Input = {
    /** The sticker is an animation in TGS format */
    readonly _: 'stickerFormatTgs',
  }

  export type stickerFormatWebm = {
    /** The sticker is a video in WEBM format */
    _: 'stickerFormatWebm',
  }

  export type stickerFormatWebm$Input = {
    /** The sticker is a video in WEBM format */
    readonly _: 'stickerFormatWebm',
  }

  export type stickerTypeRegular = {
    /** The sticker is a regular sticker */
    _: 'stickerTypeRegular',
  }

  export type stickerTypeRegular$Input = {
    /** The sticker is a regular sticker */
    readonly _: 'stickerTypeRegular',
  }

  export type stickerTypeMask = {
    /** The sticker is a mask in WEBP format to be placed on photos or videos */
    _: 'stickerTypeMask',
  }

  export type stickerTypeMask$Input = {
    /** The sticker is a mask in WEBP format to be placed on photos or videos */
    readonly _: 'stickerTypeMask',
  }

  export type stickerTypeCustomEmoji = {
    /** The sticker is a custom emoji to be used inside message text and caption */
    _: 'stickerTypeCustomEmoji',
  }

  export type stickerTypeCustomEmoji$Input = {
    /** The sticker is a custom emoji to be used inside message text and caption */
    readonly _: 'stickerTypeCustomEmoji',
  }

  export type stickerFullTypeRegular = {
    /** The sticker is a regular sticker */
    _: 'stickerFullTypeRegular',
    /**
     * Premium animation of the sticker; may be null. If present, only Telegram Premium
     * users can use the sticker
     */
    premium_animation?: file,
  }

  export type stickerFullTypeMask = {
    /** The sticker is a mask in WEBP format to be placed on photos or videos */
    _: 'stickerFullTypeMask',
    /** Position where the mask is placed; may be null */
    mask_position?: maskPosition,
  }

  export type stickerFullTypeCustomEmoji = {
    /**
     * The sticker is a custom emoji to be used inside message text and caption. Currently,
     * only Telegram Premium users can use custom emoji
     */
    _: 'stickerFullTypeCustomEmoji',
    /** Identifier of the custom emoji */
    custom_emoji_id: number | string,
    /**
     * True, if the sticker must be repainted to a text color in messages, the color
     * of the Telegram Premium badge in emoji status, white color on chat photos, or
     * another appropriate color in other places
     */
    needs_repainting: boolean,
  }

  export type closedVectorPath = {
    /**
     * Represents a closed vector path. The path begins at the end point of the last
     * command
     */
    _: 'closedVectorPath',
    /** List of vector path commands */
    commands: Array<VectorPathCommand>,
  }

  export type pollOption = {
    /** Describes one answer option of a poll */
    _: 'pollOption',
    /** Option text; 1-100 characters */
    text: string,
    /** Number of voters for this option, available only for closed or voted polls */
    voter_count: number,
    /** The percentage of votes for this option; 0-100 */
    vote_percentage: number,
    /** True, if the option was chosen by the user */
    is_chosen: boolean,
    /** True, if the option is being chosen by a pending setPollAnswer request */
    is_being_chosen: boolean,
  }

  export type pollTypeRegular = {
    /** A regular poll */
    _: 'pollTypeRegular',
    /** True, if multiple answer options can be chosen simultaneously */
    allow_multiple_answers: boolean,
  }

  export type pollTypeRegular$Input = {
    /** A regular poll */
    readonly _: 'pollTypeRegular',
    /** True, if multiple answer options can be chosen simultaneously */
    readonly allow_multiple_answers?: boolean,
  }

  export type pollTypeQuiz = {
    /**
     * A poll in quiz mode, which has exactly one correct answer option and can be
     * answered only once
     */
    _: 'pollTypeQuiz',
    /** 0-based identifier of the correct answer option; -1 for a yet unanswered poll */
    correct_option_id: number,
    /**
     * Text that is shown when the user chooses an incorrect answer or taps on the
     * lamp icon; 0-200 characters with at most 2 line feeds; empty for a yet unanswered
     * poll
     */
    explanation: formattedText,
  }

  export type pollTypeQuiz$Input = {
    /**
     * A poll in quiz mode, which has exactly one correct answer option and can be
     * answered only once
     */
    readonly _: 'pollTypeQuiz',
    /** 0-based identifier of the correct answer option; -1 for a yet unanswered poll */
    readonly correct_option_id?: number,
    /**
     * Text that is shown when the user chooses an incorrect answer or taps on the
     * lamp icon; 0-200 characters with at most 2 line feeds; empty for a yet unanswered
     * poll
     */
    readonly explanation?: formattedText$Input,
  }

  export type animation = {
    /** Describes an animation file. The animation must be encoded in GIF or MPEG4 format */
    _: 'animation',
    /** Duration of the animation, in seconds; as defined by the sender */
    duration: number,
    /** Width of the animation */
    width: number,
    /** Height of the animation */
    height: number,
    /** Original name of the file; as defined by the sender */
    file_name: string,
    /** MIME type of the file, usually "image/gif" or "video/mp4" */
    mime_type: string,
    /**
     * True, if stickers were added to the animation. The list of corresponding sticker
     * set can be received using getAttachedStickerSets
     */
    has_stickers: boolean,
    /** Animation minithumbnail; may be null */
    minithumbnail?: minithumbnail,
    /** Animation thumbnail in JPEG or MPEG4 format; may be null */
    thumbnail?: thumbnail,
    /** File containing the animation */
    animation: file,
  }

  export type audio = {
    /** Describes an audio file. Audio is usually in MP3 or M4A format */
    _: 'audio',
    /** Duration of the audio, in seconds; as defined by the sender */
    duration: number,
    /** Title of the audio; as defined by the sender */
    title: string,
    /** Performer of the audio; as defined by the sender */
    performer: string,
    /** Original name of the file; as defined by the sender */
    file_name: string,
    /** The MIME type of the file; as defined by the sender */
    mime_type: string,
    /** The minithumbnail of the album cover; may be null */
    album_cover_minithumbnail?: minithumbnail,
    /**
     * The thumbnail of the album cover in JPEG format; as defined by the sender. The
     * full size thumbnail is supposed to be extracted from the downloaded audio file;
     * may be null
     */
    album_cover_thumbnail?: thumbnail,
    /**
     * Album cover variants to use if the downloaded audio file contains no album cover.
     * Provided thumbnail dimensions are approximate
     */
    external_album_covers: Array<thumbnail>,
    /** File containing the audio */
    audio: file,
  }

  export type document = {
    /** Describes a document of any type */
    _: 'document',
    /** Original name of the file; as defined by the sender */
    file_name: string,
    /** MIME type of the file; as defined by the sender */
    mime_type: string,
    /** Document minithumbnail; may be null */
    minithumbnail?: minithumbnail,
    /**
     * Document thumbnail in JPEG or PNG format (PNG will be used only for background
     * patterns); as defined by the sender; may be null
     */
    thumbnail?: thumbnail,
    /** File containing the document */
    document: file,
  }

  export type photo = {
    /** Describes a photo */
    _: 'photo',
    /**
     * True, if stickers were added to the photo. The list of corresponding sticker
     * sets can be received using getAttachedStickerSets
     */
    has_stickers: boolean,
    /** Photo minithumbnail; may be null */
    minithumbnail?: minithumbnail,
    /** Available variants of the photo, in different sizes */
    sizes: Array<photoSize>,
  }

  export type sticker = {
    /** Describes a sticker */
    _: 'sticker',
    /** Unique sticker identifier within the set; 0 if none */
    id: number | string,
    /** Identifier of the sticker set to which the sticker belongs; 0 if none */
    set_id: number | string,
    /** Sticker width; as defined by the sender */
    width: number,
    /** Sticker height; as defined by the sender */
    height: number,
    /** Emoji corresponding to the sticker */
    emoji: string,
    /** Sticker format */
    format: StickerFormat,
    /** Sticker's full type */
    full_type: StickerFullType,
    /**
     * Sticker's outline represented as a list of closed vector paths; may be empty.
     * The coordinate system origin is in the upper-left corner
     */
    outline: Array<closedVectorPath>,
    /** Sticker thumbnail in WEBP or JPEG format; may be null */
    thumbnail?: thumbnail,
    /** File containing the sticker */
    sticker: file,
  }

  export type video = {
    /** Describes a video file */
    _: 'video',
    /** Duration of the video, in seconds; as defined by the sender */
    duration: number,
    /** Video width; as defined by the sender */
    width: number,
    /** Video height; as defined by the sender */
    height: number,
    /** Original name of the file; as defined by the sender */
    file_name: string,
    /** MIME type of the file; as defined by the sender */
    mime_type: string,
    /**
     * True, if stickers were added to the video. The list of corresponding sticker
     * sets can be received using getAttachedStickerSets
     */
    has_stickers: boolean,
    /** True, if the video is supposed to be streamed */
    supports_streaming: boolean,
    /** Video minithumbnail; may be null */
    minithumbnail?: minithumbnail,
    /** Video thumbnail in JPEG or MPEG4 format; as defined by the sender; may be null */
    thumbnail?: thumbnail,
    /** File containing the video */
    video: file,
  }

  export type videoNote = {
    /**
     * Describes a video note. The video must be equal in width and height, cropped
     * to a circle, and stored in MPEG4 format
     */
    _: 'videoNote',
    /** Duration of the video, in seconds; as defined by the sender */
    duration: number,
    /**
     * A waveform representation of the video note's audio in 5-bit format; may be
     * empty if unknown
     */
    waveform: string,
    /** Video width and height; as defined by the sender */
    length: number,
    /** Video minithumbnail; may be null */
    minithumbnail?: minithumbnail,
    /** Video thumbnail in JPEG format; as defined by the sender; may be null */
    thumbnail?: thumbnail,
    /** Result of speech recognition in the video note; may be null */
    speech_recognition_result?: SpeechRecognitionResult,
    /** File containing the video */
    video: file,
  }

  export type voiceNote = {
    /**
     * Describes a voice note. The voice note must be encoded with the Opus codec,
     * and stored inside an OGG container. Voice notes can have only a single audio
     * channel
     */
    _: 'voiceNote',
    /** Duration of the voice note, in seconds; as defined by the sender */
    duration: number,
    /** A waveform representation of the voice note in 5-bit format */
    waveform: string,
    /** MIME type of the file; as defined by the sender */
    mime_type: string,
    /** Result of speech recognition in the voice note; may be null */
    speech_recognition_result?: SpeechRecognitionResult,
    /** File containing the voice note */
    voice: file,
  }

  export type animatedEmoji = {
    /** Describes an animated or custom representation of an emoji */
    _: 'animatedEmoji',
    /**
     * Sticker for the emoji; may be null if yet unknown for a custom emoji. If the
     * sticker is a custom emoji, it can have arbitrary format different from stickerFormatTgs
     */
    sticker?: sticker,
    /** Expected width of the sticker, which can be used if the sticker is null */
    sticker_width: number,
    /** Expected height of the sticker, which can be used if the sticker is null */
    sticker_height: number,
    /** Emoji modifier fitzpatrick type; 0-6; 0 if none */
    fitzpatrick_type: number,
    /**
     * File containing the sound to be played when the sticker is clicked; may be null.
     * The sound is encoded with the Opus codec, and stored inside an OGG container
     */
    sound?: file,
  }

  export type contact = {
    /** Describes a user contact */
    _: 'contact',
    /** Phone number of the user */
    phone_number: string,
    /** First name of the user; 1-255 characters in length */
    first_name: string,
    /** Last name of the user */
    last_name: string,
    /** Additional data about the user in a form of vCard; 0-2048 bytes in length */
    vcard: string,
    /** Identifier of the user, if known; 0 otherwise */
    user_id: number,
  }

  export type contact$Input = {
    /** Describes a user contact */
    readonly _: 'contact',
    /** Phone number of the user */
    readonly phone_number?: string,
    /** First name of the user; 1-255 characters in length */
    readonly first_name?: string,
    /** Last name of the user */
    readonly last_name?: string,
    /** Additional data about the user in a form of vCard; 0-2048 bytes in length */
    readonly vcard?: string,
    /** Identifier of the user, if known; 0 otherwise */
    readonly user_id?: number,
  }

  export type location = {
    /** Describes a location on planet Earth */
    _: 'location',
    /** Latitude of the location in degrees; as defined by the sender */
    latitude: number,
    /** Longitude of the location, in degrees; as defined by the sender */
    longitude: number,
    /**
     * The estimated horizontal accuracy of the location, in meters; as defined by
     * the sender. 0 if unknown
     */
    horizontal_accuracy: number,
  }

  export type location$Input = {
    /** Describes a location on planet Earth */
    readonly _: 'location',
    /** Latitude of the location in degrees; as defined by the sender */
    readonly latitude?: number,
    /** Longitude of the location, in degrees; as defined by the sender */
    readonly longitude?: number,
    /**
     * The estimated horizontal accuracy of the location, in meters; as defined by
     * the sender. 0 if unknown
     */
    readonly horizontal_accuracy?: number,
  }

  export type venue = {
    /** Describes a venue */
    _: 'venue',
    /** Venue location; as defined by the sender */
    location: location,
    /** Venue name; as defined by the sender */
    title: string,
    /** Venue address; as defined by the sender */
    address: string,
    /**
     * Provider of the venue database; as defined by the sender. Currently, only "foursquare"
     * and "gplaces" (Google Places) need to be supported
     */
    provider: string,
    /** Identifier of the venue in the provider database; as defined by the sender */
    id: string,
    /** Type of the venue in the provider database; as defined by the sender */
    type: string,
  }

  export type venue$Input = {
    /** Describes a venue */
    readonly _: 'venue',
    /** Venue location; as defined by the sender */
    readonly location?: location$Input,
    /** Venue name; as defined by the sender */
    readonly title?: string,
    /** Venue address; as defined by the sender */
    readonly address?: string,
    /**
     * Provider of the venue database; as defined by the sender. Currently, only "foursquare"
     * and "gplaces" (Google Places) need to be supported
     */
    readonly provider?: string,
    /** Identifier of the venue in the provider database; as defined by the sender */
    readonly id?: string,
    /** Type of the venue in the provider database; as defined by the sender */
    readonly type?: string,
  }

  export type game = {
    /**
     * Describes a game. Use getInternalLink with internalLinkTypeGame to share the
     * game
     */
    _: 'game',
    /** Unique game identifier */
    id: number | string,
    /** Game short name */
    short_name: string,
    /** Game title */
    title: string,
    /** Game text, usually containing scoreboards for a game */
    text: formattedText,
    /** Game description */
    description: string,
    /** Game photo */
    photo: photo,
    /** Game animation; may be null */
    animation?: animation,
  }

  export type webApp = {
    /**
     * Describes a Web App. Use getInternalLink with internalLinkTypeWebApp to share
     * the Web App
     */
    _: 'webApp',
    /** Web App short name */
    short_name: string,
    /** Web App title */
    title: string,
    /** Web App description */
    description: string,
    /** Web App photo */
    photo: photo,
    /** Web App animation; may be null */
    animation?: animation,
  }

  export type poll = {
    /** Describes a poll */
    _: 'poll',
    /** Unique poll identifier */
    id: number | string,
    /** Poll question; 1-300 characters */
    question: string,
    /** List of poll answer options */
    options: Array<pollOption>,
    /** Total number of voters, participating in the poll */
    total_voter_count: number,
    /** Identifiers of recent voters, if the poll is non-anonymous */
    recent_voter_ids: Array<MessageSender>,
    /** True, if the poll is anonymous */
    is_anonymous: boolean,
    /** Type of the poll */
    type: PollType,
    /** Amount of time the poll will be active after creation, in seconds */
    open_period: number,
    /** Point in time (Unix timestamp) when the poll will automatically be closed */
    close_date: number,
    /** True, if the poll is closed */
    is_closed: boolean,
  }

  export type background = {
    /** Describes a chat background */
    _: 'background',
    /** Unique background identifier */
    id: number | string,
    /** True, if this is one of default backgrounds */
    is_default: boolean,
    /** True, if the background is dark and is recommended to be used with dark theme */
    is_dark: boolean,
    /** Unique background name */
    name: string,
    /** Document with the background; may be null. Null only for filled backgrounds */
    document?: document,
    /** Type of the background */
    type: BackgroundType,
  }

  export type backgrounds = {
    /** Contains a list of backgrounds */
    _: 'backgrounds',
    /** A list of backgrounds */
    backgrounds: Array<background>,
  }

  export type chatBackground = {
    /** Describes a background set for a specific chat */
    _: 'chatBackground',
    /** The background */
    background: background,
    /** Dimming of the background in dark themes, as a percentage; 0-100 */
    dark_theme_dimming: number,
  }

  export type profilePhoto = {
    /** Describes a user profile photo */
    _: 'profilePhoto',
    /**
     * Photo identifier; 0 for an empty photo. Can be used to find a photo in a list
     * of user profile photos
     */
    id: number | string,
    /**
     * A small (160x160) user profile photo. The file can be downloaded only before
     * the photo is changed
     */
    small: file,
    /**
     * A big (640x640) user profile photo. The file can be downloaded only before the
     * photo is changed
     */
    big: file,
    /** User profile photo minithumbnail; may be null */
    minithumbnail?: minithumbnail,
    /** True, if the photo has animated variant */
    has_animation: boolean,
    /** True, if the photo is visible only for the current user */
    is_personal: boolean,
  }

  export type chatPhotoInfo = {
    /** Contains basic information about the photo of a chat */
    _: 'chatPhotoInfo',
    /**
     * A small (160x160) chat photo variant in JPEG format. The file can be downloaded
     * only before the photo is changed
     */
    small: file,
    /**
     * A big (640x640) chat photo variant in JPEG format. The file can be downloaded
     * only before the photo is changed
     */
    big: file,
    /** Chat photo minithumbnail; may be null */
    minithumbnail?: minithumbnail,
    /** True, if the photo has animated variant */
    has_animation: boolean,
    /** True, if the photo is visible only for the current user */
    is_personal: boolean,
  }

  export type userTypeRegular = {
    /** A regular user */
    _: 'userTypeRegular',
  }

  export type userTypeDeleted = {
    /**
     * A deleted user or deleted bot. No information on the user besides the user identifier
     * is available. It is not possible to perform any active actions on this type
     * of user
     */
    _: 'userTypeDeleted',
  }

  export type userTypeBot = {
    /** A bot (see https://core.telegram.org/bots) */
    _: 'userTypeBot',
    /**
     * True, if the bot is owned by the current user and can be edited using the methods
     * toggleBotUsernameIsActive, reorderBotActiveUsernames, setBotProfilePhoto, setBotName,
     * setBotInfoDescription, and setBotInfoShortDescription
     */
    can_be_edited: boolean,
    /** True, if the bot can be invited to basic group and supergroup chats */
    can_join_groups: boolean,
    /**
     * True, if the bot can read all messages in basic group or supergroup chats and
     * not just those addressed to the bot. In private and channel chats a bot can
     * always read all messages
     */
    can_read_all_group_messages: boolean,
    /** True, if the bot supports inline queries */
    is_inline: boolean,
    /** Placeholder for inline queries (displayed on the application input field) */
    inline_query_placeholder: string,
    /**
     * True, if the location of the user is expected to be sent with every inline query
     * to this bot
     */
    need_location: boolean,
    /** True, if the bot can be added to attachment or side menu */
    can_be_added_to_attachment_menu: boolean,
  }

  export type userTypeUnknown = {
    /**
     * No information on the user besides the user identifier is available, yet this
     * user has not been deleted. This object is extremely rare and must be handled
     * like a deleted user. It is not possible to perform any actions on users of this
     * type
     */
    _: 'userTypeUnknown',
  }

  export type botCommand = {
    /** Represents a command supported by a bot */
    _: 'botCommand',
    /** Text of the bot command */
    command: string,
    /** Description of the bot command */
    description: string,
  }

  export type botCommand$Input = {
    /** Represents a command supported by a bot */
    readonly _: 'botCommand',
    /** Text of the bot command */
    readonly command?: string,
    /** Description of the bot command */
    readonly description?: string,
  }

  export type botCommands = {
    /** Contains a list of bot commands */
    _: 'botCommands',
    /** Bot's user identifier */
    bot_user_id: number,
    /** List of bot commands */
    commands: Array<botCommand>,
  }

  export type botMenuButton = {
    /** Describes a button to be shown instead of bot commands menu button */
    _: 'botMenuButton',
    /** Text of the button */
    text: string,
    /** URL to be passed to openWebApp */
    url: string,
  }

  export type botMenuButton$Input = {
    /** Describes a button to be shown instead of bot commands menu button */
    readonly _: 'botMenuButton',
    /** Text of the button */
    readonly text?: string,
    /** URL to be passed to openWebApp */
    readonly url?: string,
  }

  export type chatLocation = {
    /** Represents a location to which a chat is connected */
    _: 'chatLocation',
    /** The location */
    location: location,
    /** Location address; 1-64 characters, as defined by the chat owner */
    address: string,
  }

  export type chatLocation$Input = {
    /** Represents a location to which a chat is connected */
    readonly _: 'chatLocation',
    /** The location */
    readonly location?: location$Input,
    /** Location address; 1-64 characters, as defined by the chat owner */
    readonly address?: string,
  }

  export type chatPhotoStickerTypeRegularOrMask = {
    /** Information about the sticker, which was used to create the chat photo */
    _: 'chatPhotoStickerTypeRegularOrMask',
    /** Sticker set identifier */
    sticker_set_id: number | string,
    /** Identifier of the sticker in the set */
    sticker_id: number | string,
  }

  export type chatPhotoStickerTypeRegularOrMask$Input = {
    /** Information about the sticker, which was used to create the chat photo */
    readonly _: 'chatPhotoStickerTypeRegularOrMask',
    /** Sticker set identifier */
    readonly sticker_set_id?: number | string,
    /** Identifier of the sticker in the set */
    readonly sticker_id?: number | string,
  }

  export type chatPhotoStickerTypeCustomEmoji = {
    /** Information about the custom emoji, which was used to create the chat photo */
    _: 'chatPhotoStickerTypeCustomEmoji',
    /** Identifier of the custom emoji */
    custom_emoji_id: number | string,
  }

  export type chatPhotoStickerTypeCustomEmoji$Input = {
    /** Information about the custom emoji, which was used to create the chat photo */
    readonly _: 'chatPhotoStickerTypeCustomEmoji',
    /** Identifier of the custom emoji */
    readonly custom_emoji_id?: number | string,
  }

  export type chatPhotoSticker = {
    /**
     * Information about the sticker, which was used to create the chat photo. The
     * sticker is shown at the center of the photo and occupies at most 67% of it
     */
    _: 'chatPhotoSticker',
    /** Type of the sticker */
    type: ChatPhotoStickerType,
    /**
     * The fill to be used as background for the sticker; rotation angle in backgroundFillGradient
     * isn't supported
     */
    background_fill: BackgroundFill,
  }

  export type chatPhotoSticker$Input = {
    /**
     * Information about the sticker, which was used to create the chat photo. The
     * sticker is shown at the center of the photo and occupies at most 67% of it
     */
    readonly _: 'chatPhotoSticker',
    /** Type of the sticker */
    readonly type?: ChatPhotoStickerType$Input,
    /**
     * The fill to be used as background for the sticker; rotation angle in backgroundFillGradient
     * isn't supported
     */
    readonly background_fill?: BackgroundFill$Input,
  }

  export type animatedChatPhoto = {
    /** Animated variant of a chat photo in MPEG4 format */
    _: 'animatedChatPhoto',
    /** Animation width and height */
    length: number,
    /** Information about the animation file */
    file: file,
    /** Timestamp of the frame, used as a static chat photo */
    main_frame_timestamp: number,
  }

  export type chatPhoto = {
    /** Describes a chat or user profile photo */
    _: 'chatPhoto',
    /** Unique photo identifier */
    id: number | string,
    /** Point in time (Unix timestamp) when the photo has been added */
    added_date: number,
    /** Photo minithumbnail; may be null */
    minithumbnail?: minithumbnail,
    /** Available variants of the photo in JPEG format, in different size */
    sizes: Array<photoSize>,
    /**
     * A big (up to 1280x1280) animated variant of the photo in MPEG4 format; may be
     * null
     */
    animation?: animatedChatPhoto,
    /**
     * A small (160x160) animated variant of the photo in MPEG4 format; may be null
     * even the big animation is available
     */
    small_animation?: animatedChatPhoto,
    /** Sticker-based version of the chat photo; may be null */
    sticker?: chatPhotoSticker,
  }

  export type chatPhotos = {
    /** Contains a list of chat or user profile photos */
    _: 'chatPhotos',
    /** Total number of photos */
    total_count: number,
    /** List of photos */
    photos: Array<chatPhoto>,
  }

  export type inputChatPhotoPrevious$Input = {
    /** A previously used profile photo of the current user */
    readonly _: 'inputChatPhotoPrevious',
    /** Identifier of the current user's profile photo to reuse */
    readonly chat_photo_id?: number | string,
  }

  export type inputChatPhotoStatic$Input = {
    /** A static photo in JPEG format */
    readonly _: 'inputChatPhotoStatic',
    /**
     * Photo to be set as profile photo. Only inputFileLocal and inputFileGenerated
     * are allowed
     */
    readonly photo?: InputFile$Input,
  }

  export type inputChatPhotoAnimation$Input = {
    /**
     * An animation in MPEG4 format; must be square, at most 10 seconds long, have
     * width between 160 and 1280 and be at most 2MB in size
     */
    readonly _: 'inputChatPhotoAnimation',
    /**
     * Animation to be set as profile photo. Only inputFileLocal and inputFileGenerated
     * are allowed
     */
    readonly animation?: InputFile$Input,
    /** Timestamp of the frame, which will be used as static chat photo */
    readonly main_frame_timestamp?: number,
  }

  export type inputChatPhotoSticker$Input = {
    /** A sticker on a custom background */
    readonly _: 'inputChatPhotoSticker',
    /** Information about the sticker */
    readonly sticker?: chatPhotoSticker$Input,
  }

  export type chatPermissions = {
    /** Describes actions that a user is allowed to take in a chat */
    _: 'chatPermissions',
    /**
     * True, if the user can send text messages, contacts, invoices, locations, and
     * venues
     */
    can_send_basic_messages: boolean,
    /** True, if the user can send music files */
    can_send_audios: boolean,
    /** True, if the user can send documents */
    can_send_documents: boolean,
    /** True, if the user can send audio photos */
    can_send_photos: boolean,
    /** True, if the user can send audio videos */
    can_send_videos: boolean,
    /** True, if the user can send video notes */
    can_send_video_notes: boolean,
    /** True, if the user can send voice notes */
    can_send_voice_notes: boolean,
    /** True, if the user can send polls */
    can_send_polls: boolean,
    /**
     * True, if the user can send animations, games, stickers, and dice and use inline
     * bots
     */
    can_send_other_messages: boolean,
    /** True, if the user may add a web page preview to their messages */
    can_add_web_page_previews: boolean,
    /** True, if the user can change the chat title, photo, and other settings */
    can_change_info: boolean,
    /** True, if the user can invite new users to the chat */
    can_invite_users: boolean,
    /** True, if the user can pin messages */
    can_pin_messages: boolean,
    /** True, if the user can manage topics */
    can_manage_topics: boolean,
  }

  export type chatPermissions$Input = {
    /** Describes actions that a user is allowed to take in a chat */
    readonly _: 'chatPermissions',
    /**
     * True, if the user can send text messages, contacts, invoices, locations, and
     * venues
     */
    readonly can_send_basic_messages?: boolean,
    /** True, if the user can send music files */
    readonly can_send_audios?: boolean,
    /** True, if the user can send documents */
    readonly can_send_documents?: boolean,
    /** True, if the user can send audio photos */
    readonly can_send_photos?: boolean,
    /** True, if the user can send audio videos */
    readonly can_send_videos?: boolean,
    /** True, if the user can send video notes */
    readonly can_send_video_notes?: boolean,
    /** True, if the user can send voice notes */
    readonly can_send_voice_notes?: boolean,
    /** True, if the user can send polls */
    readonly can_send_polls?: boolean,
    /**
     * True, if the user can send animations, games, stickers, and dice and use inline
     * bots
     */
    readonly can_send_other_messages?: boolean,
    /** True, if the user may add a web page preview to their messages */
    readonly can_add_web_page_previews?: boolean,
    /** True, if the user can change the chat title, photo, and other settings */
    readonly can_change_info?: boolean,
    /** True, if the user can invite new users to the chat */
    readonly can_invite_users?: boolean,
    /** True, if the user can pin messages */
    readonly can_pin_messages?: boolean,
    /** True, if the user can manage topics */
    readonly can_manage_topics?: boolean,
  }

  export type chatAdministratorRights = {
    /** Describes rights of the administrator */
    _: 'chatAdministratorRights',
    /**
     * True, if the administrator can get chat event log, get chat statistics, get
     * chat boosts in channels, get message statistics in channels, get channel members,
     * see anonymous administrators in supergroups and ignore slow mode. Implied by
     * any other privilege; applicable to supergroups and channels only
     */
    can_manage_chat: boolean,
    /** True, if the administrator can change the chat title, photo, and other settings */
    can_change_info: boolean,
    /**
     * True, if the administrator can create channel posts; applicable to channels
     * only
     */
    can_post_messages: boolean,
    /**
     * True, if the administrator can edit messages of other users and pin messages;
     * applicable to channels only
     */
    can_edit_messages: boolean,
    /** True, if the administrator can delete messages of other users */
    can_delete_messages: boolean,
    /** True, if the administrator can invite new users to the chat */
    can_invite_users: boolean,
    /**
     * True, if the administrator can restrict, ban, or unban chat members; always
     * true for channels
     */
    can_restrict_members: boolean,
    /**
     * True, if the administrator can pin messages; applicable to basic groups and
     * supergroups only
     */
    can_pin_messages: boolean,
    /**
     * True, if the administrator can manage topics; applicable to forum supergroups
     * only
     */
    can_manage_topics: boolean,
    /**
     * True, if the administrator can add new administrators with a subset of their
     * own privileges or demote administrators that were directly or indirectly promoted
     * by them
     */
    can_promote_members: boolean,
    /** True, if the administrator can manage video chats */
    can_manage_video_chats: boolean,
    /**
     * True, if the administrator can create new channel stories, or edit and delete
     * posted stories; applicable to channels only
     */
    can_post_stories: boolean,
    /**
     * True, if the administrator can edit stories posted by other users, pin stories
     * and access story archive; applicable to channels only
     */
    can_edit_stories: boolean,
    /**
     * True, if the administrator can delete stories posted by other users; applicable
     * to channels only
     */
    can_delete_stories: boolean,
    /**
     * True, if the administrator isn't shown in the chat member list and sends messages
     * anonymously; applicable to supergroups only
     */
    is_anonymous: boolean,
  }

  export type chatAdministratorRights$Input = {
    /** Describes rights of the administrator */
    readonly _: 'chatAdministratorRights',
    /**
     * True, if the administrator can get chat event log, get chat statistics, get
     * chat boosts in channels, get message statistics in channels, get channel members,
     * see anonymous administrators in supergroups and ignore slow mode. Implied by
     * any other privilege; applicable to supergroups and channels only
     */
    readonly can_manage_chat?: boolean,
    /** True, if the administrator can change the chat title, photo, and other settings */
    readonly can_change_info?: boolean,
    /**
     * True, if the administrator can create channel posts; applicable to channels
     * only
     */
    readonly can_post_messages?: boolean,
    /**
     * True, if the administrator can edit messages of other users and pin messages;
     * applicable to channels only
     */
    readonly can_edit_messages?: boolean,
    /** True, if the administrator can delete messages of other users */
    readonly can_delete_messages?: boolean,
    /** True, if the administrator can invite new users to the chat */
    readonly can_invite_users?: boolean,
    /**
     * True, if the administrator can restrict, ban, or unban chat members; always
     * true for channels
     */
    readonly can_restrict_members?: boolean,
    /**
     * True, if the administrator can pin messages; applicable to basic groups and
     * supergroups only
     */
    readonly can_pin_messages?: boolean,
    /**
     * True, if the administrator can manage topics; applicable to forum supergroups
     * only
     */
    readonly can_manage_topics?: boolean,
    /**
     * True, if the administrator can add new administrators with a subset of their
     * own privileges or demote administrators that were directly or indirectly promoted
     * by them
     */
    readonly can_promote_members?: boolean,
    /** True, if the administrator can manage video chats */
    readonly can_manage_video_chats?: boolean,
    /**
     * True, if the administrator can create new channel stories, or edit and delete
     * posted stories; applicable to channels only
     */
    readonly can_post_stories?: boolean,
    /**
     * True, if the administrator can edit stories posted by other users, pin stories
     * and access story archive; applicable to channels only
     */
    readonly can_edit_stories?: boolean,
    /**
     * True, if the administrator can delete stories posted by other users; applicable
     * to channels only
     */
    readonly can_delete_stories?: boolean,
    /**
     * True, if the administrator isn't shown in the chat member list and sends messages
     * anonymously; applicable to supergroups only
     */
    readonly is_anonymous?: boolean,
  }

  export type premiumPaymentOption = {
    /** Describes an option for buying Telegram Premium to a user */
    _: 'premiumPaymentOption',
    /** ISO 4217 currency code for Telegram Premium subscription payment */
    currency: string,
    /** The amount to pay, in the smallest units of the currency */
    amount: number,
    /** The discount associated with this option, as a percentage */
    discount_percentage: number,
    /** Number of month the Telegram Premium subscription will be active */
    month_count: number,
    /** Identifier of the store product associated with the option */
    store_product_id: string,
    /**
     * An internal link to be opened for buying Telegram Premium to the user if store
     * payment isn't possible; may be null if direct payment isn't available
     */
    payment_link?: InternalLinkType,
  }

  export type premiumStatePaymentOption = {
    /** Describes an option for buying or upgrading Telegram Premium for self */
    _: 'premiumStatePaymentOption',
    /** Information about the payment option */
    payment_option: premiumPaymentOption,
    /** True, if this is the currently used Telegram Premium subscription option */
    is_current: boolean,
    /**
     * True, if the payment option can be used to upgrade the existing Telegram Premium
     * subscription
     */
    is_upgrade: boolean,
    /** Identifier of the last in-store transaction for the currently used option */
    last_transaction_id: string,
  }

  export type emojiStatus = {
    /** Describes a custom emoji to be shown instead of the Telegram Premium badge */
    _: 'emojiStatus',
    /** Identifier of the custom emoji in stickerFormatTgs format */
    custom_emoji_id: number | string,
    /** Point in time (Unix timestamp) when the status will expire; 0 if never */
    expiration_date: number,
  }

  export type emojiStatus$Input = {
    /** Describes a custom emoji to be shown instead of the Telegram Premium badge */
    readonly _: 'emojiStatus',
    /** Identifier of the custom emoji in stickerFormatTgs format */
    readonly custom_emoji_id?: number | string,
    /** Point in time (Unix timestamp) when the status will expire; 0 if never */
    readonly expiration_date?: number,
  }

  export type emojiStatuses = {
    /** Contains a list of custom emoji identifiers, which can be set as emoji statuses */
    _: 'emojiStatuses',
    /** The list of custom emoji identifiers */
    custom_emoji_ids: Array<number | string>,
  }

  export type usernames = {
    /** Describes usernames assigned to a user, a supergroup, or a channel */
    _: 'usernames',
    /**
     * List of active usernames; the first one must be shown as the primary username.
     * The order of active usernames can be changed with reorderActiveUsernames, reorderBotActiveUsernames
     * or reorderSupergroupActiveUsernames
     */
    active_usernames: Array<string>,
    /**
     * List of currently disabled usernames; the username can be activated with toggleUsernameIsActive,
     * toggleBotUsernameIsActive, or toggleSupergroupUsernameIsActive
     */
    disabled_usernames: Array<string>,
    /** The active username, which can be changed with setUsername or setSupergroupUsername */
    editable_username: string,
  }

  export type user = {
    /** Represents a user */
    _: 'user',
    /** User identifier */
    id: number,
    /** First name of the user */
    first_name: string,
    /** Last name of the user */
    last_name: string,
    /** Usernames of the user; may be null */
    usernames?: usernames,
    /** Phone number of the user */
    phone_number: string,
    /** Current online status of the user */
    status: UserStatus,
    /** Profile photo of the user; may be null */
    profile_photo?: profilePhoto,
    /**
     * Emoji status to be shown instead of the default Telegram Premium badge; may
     * be null. For Telegram Premium users only
     */
    emoji_status?: emojiStatus,
    /** The user is a contact of the current user */
    is_contact: boolean,
    /**
     * The user is a contact of the current user and the current user is a contact
     * of the user
     */
    is_mutual_contact: boolean,
    /** The user is a close friend of the current user; implies that the user is a contact */
    is_close_friend: boolean,
    /** True, if the user is verified */
    is_verified: boolean,
    /** True, if the user is a Telegram Premium user */
    is_premium: boolean,
    /** True, if the user is Telegram support account */
    is_support: boolean,
    /**
     * If non-empty, it contains a human-readable description of the reason why access
     * to this user must be restricted
     */
    restriction_reason: string,
    /** True, if many users reported this user as a scam */
    is_scam: boolean,
    /** True, if many users reported this user as a fake account */
    is_fake: boolean,
    /** True, if the user has non-expired stories available to the current user */
    has_active_stories: boolean,
    /** True, if the user has unread non-expired stories available to the current user */
    has_unread_active_stories: boolean,
    /**
     * If false, the user is inaccessible, and the only information known about the
     * user is inside this class. Identifier of the user can't be passed to any method
     */
    have_access: boolean,
    /** Type of the user */
    type: UserType,
    /** IETF language tag of the user's language; only available to bots */
    language_code: string,
    /**
     * True, if the user added the current bot to attachment menu; only available to
     * bots
     */
    added_to_attachment_menu: boolean,
  }

  export type botInfo = {
    /** Contains information about a bot */
    _: 'botInfo',
    /**
     * The text that is shown on the bot's profile page and is sent together with the
     * link when users share the bot
     */
    short_description: string,
    /** The text shown in the chat with the bot if the chat is empty */
    description: string,
    /** Photo shown in the chat with the bot if the chat is empty; may be null */
    photo?: photo,
    /** Animation shown in the chat with the bot if the chat is empty; may be null */
    animation?: animation,
    /**
     * Information about a button to show instead of the bot commands menu button;
     * may be null if ordinary bot commands menu must be shown
     */
    menu_button?: botMenuButton,
    /** List of the bot commands */
    commands: Array<botCommand>,
    /**
     * Default administrator rights for adding the bot to basic group and supergroup
     * chats; may be null
     */
    default_group_administrator_rights?: chatAdministratorRights,
    /** Default administrator rights for adding the bot to channels; may be null */
    default_channel_administrator_rights?: chatAdministratorRights,
    /** The internal link, which can be used to edit bot commands; may be null */
    edit_commands_link?: InternalLinkType,
    /** The internal link, which can be used to edit bot description; may be null */
    edit_description_link?: InternalLinkType,
    /**
     * The internal link, which can be used to edit the photo or animation shown in
     * the chat with the bot if the chat is empty; may be null
     */
    edit_description_media_link?: InternalLinkType,
    /** The internal link, which can be used to edit bot settings; may be null */
    edit_settings_link?: InternalLinkType,
  }

  export type userFullInfo = {
    /** Contains full information about a user */
    _: 'userFullInfo',
    /**
     * User profile photo set by the current user for the contact; may be null. If
     * null and user.profile_photo is null, then the photo is empty; otherwise, it
     * is unknown. If non-null, then it is the same photo as in user.profile_photo
     * and chat.photo. This photo isn't returned in the list of user photos
     */
    personal_photo?: chatPhoto,
    /**
     * User profile photo; may be null. If null and user.profile_photo is null, then
     * the photo is empty; otherwise, it is unknown. If non-null and personal_photo
     * is null, then it is the same photo as in user.profile_photo and chat.photo
     */
    photo?: chatPhoto,
    /**
     * User profile photo visible if the main photo is hidden by privacy settings;
     * may be null. If null and user.profile_photo is null, then the photo is empty;
     * otherwise, it is unknown. If non-null and both photo and personal_photo are
     * null, then it is the same photo as in user.profile_photo and chat.photo. This
     * photo isn't returned in the list of user photos
     */
    public_photo?: chatPhoto,
    /** Block list to which the user is added; may be null if none */
    block_list?: BlockList,
    /** True, if the user can be called */
    can_be_called: boolean,
    /** True, if a video call can be created with the user */
    supports_video_calls: boolean,
    /** True, if the user can't be called due to their privacy settings */
    has_private_calls: boolean,
    /**
     * True, if the user can't be linked in forwarded messages due to their privacy
     * settings
     */
    has_private_forwards: boolean,
    /** True, if voice and video notes can't be sent or forwarded to the user */
    has_restricted_voice_and_video_note_messages: boolean,
    /** True, if the user has pinned stories */
    has_pinned_stories: boolean,
    /**
     * True, if the current user needs to explicitly allow to share their phone number
     * with the user when the method addContact is used
     */
    need_phone_number_privacy_exception: boolean,
    /** A short user bio; may be null for bots */
    bio?: formattedText,
    /** The list of available options for gifting Telegram Premium to the user */
    premium_gift_options: Array<premiumPaymentOption>,
    /**
     * Number of group chats where both the other user and the current user are a member;
     * 0 for the current user
     */
    group_in_common_count: number,
    /** For bots, information about the bot; may be null if the user isn't a bot */
    bot_info?: botInfo,
  }

  export type users = {
    /** Represents a list of users */
    _: 'users',
    /** Approximate total number of users found */
    total_count: number,
    /** A list of user identifiers */
    user_ids: Array<number>,
  }

  export type chatAdministrator = {
    /** Contains information about a chat administrator */
    _: 'chatAdministrator',
    /** User identifier of the administrator */
    user_id: number,
    /** Custom title of the administrator */
    custom_title: string,
    /** True, if the user is the owner of the chat */
    is_owner: boolean,
  }

  export type chatAdministrators = {
    /** Represents a list of chat administrators */
    _: 'chatAdministrators',
    /** A list of chat administrators */
    administrators: Array<chatAdministrator>,
  }

  export type chatMemberStatusCreator = {
    /** The user is the owner of the chat and has all the administrator privileges */
    _: 'chatMemberStatusCreator',
    /**
     * A custom title of the owner; 0-16 characters without emojis; applicable to supergroups
     * only
     */
    custom_title: string,
    /**
     * True, if the creator isn't shown in the chat member list and sends messages
     * anonymously; applicable to supergroups only
     */
    is_anonymous: boolean,
    /** True, if the user is a member of the chat */
    is_member: boolean,
  }

  export type chatMemberStatusCreator$Input = {
    /** The user is the owner of the chat and has all the administrator privileges */
    readonly _: 'chatMemberStatusCreator',
    /**
     * A custom title of the owner; 0-16 characters without emojis; applicable to supergroups
     * only
     */
    readonly custom_title?: string,
    /**
     * True, if the creator isn't shown in the chat member list and sends messages
     * anonymously; applicable to supergroups only
     */
    readonly is_anonymous?: boolean,
    /** True, if the user is a member of the chat */
    readonly is_member?: boolean,
  }

  export type chatMemberStatusAdministrator = {
    /**
     * The user is a member of the chat and has some additional privileges. In basic
     * groups, administrators can edit and delete messages sent by others, add new
     * members, ban unprivileged members, and manage video chats. In supergroups and
     * channels, there are more detailed options for administrator privileges
     */
    _: 'chatMemberStatusAdministrator',
    /**
     * A custom title of the administrator; 0-16 characters without emojis; applicable
     * to supergroups only
     */
    custom_title: string,
    /**
     * True, if the current user can edit the administrator privileges for the called
     * user
     */
    can_be_edited: boolean,
    /** Rights of the administrator */
    rights: chatAdministratorRights,
  }

  export type chatMemberStatusAdministrator$Input = {
    /**
     * The user is a member of the chat and has some additional privileges. In basic
     * groups, administrators can edit and delete messages sent by others, add new
     * members, ban unprivileged members, and manage video chats. In supergroups and
     * channels, there are more detailed options for administrator privileges
     */
    readonly _: 'chatMemberStatusAdministrator',
    /**
     * A custom title of the administrator; 0-16 characters without emojis; applicable
     * to supergroups only
     */
    readonly custom_title?: string,
    /**
     * True, if the current user can edit the administrator privileges for the called
     * user
     */
    readonly can_be_edited?: boolean,
    /** Rights of the administrator */
    readonly rights?: chatAdministratorRights$Input,
  }

  export type chatMemberStatusMember = {
    /** The user is a member of the chat, without any additional privileges or restrictions */
    _: 'chatMemberStatusMember',
  }

  export type chatMemberStatusMember$Input = {
    /** The user is a member of the chat, without any additional privileges or restrictions */
    readonly _: 'chatMemberStatusMember',
  }

  export type chatMemberStatusRestricted = {
    /**
     * The user is under certain restrictions in the chat. Not supported in basic groups
     * and channels
     */
    _: 'chatMemberStatusRestricted',
    /** True, if the user is a member of the chat */
    is_member: boolean,
    /**
     * Point in time (Unix timestamp) when restrictions will be lifted from the user;
     * 0 if never. If the user is restricted for more than 366 days or for less than
     * 30 seconds from the current time, the user is considered to be restricted forever
     */
    restricted_until_date: number,
    /** User permissions in the chat */
    permissions: chatPermissions,
  }

  export type chatMemberStatusRestricted$Input = {
    /**
     * The user is under certain restrictions in the chat. Not supported in basic groups
     * and channels
     */
    readonly _: 'chatMemberStatusRestricted',
    /** True, if the user is a member of the chat */
    readonly is_member?: boolean,
    /**
     * Point in time (Unix timestamp) when restrictions will be lifted from the user;
     * 0 if never. If the user is restricted for more than 366 days or for less than
     * 30 seconds from the current time, the user is considered to be restricted forever
     */
    readonly restricted_until_date?: number,
    /** User permissions in the chat */
    readonly permissions?: chatPermissions$Input,
  }

  export type chatMemberStatusLeft = {
    /** The user or the chat is not a chat member */
    _: 'chatMemberStatusLeft',
  }

  export type chatMemberStatusLeft$Input = {
    /** The user or the chat is not a chat member */
    readonly _: 'chatMemberStatusLeft',
  }

  export type chatMemberStatusBanned = {
    /**
     * The user or the chat was banned (and hence is not a member of the chat). Implies
     * the user can't return to the chat, view messages, or be used as a participant
     * identifier to join a video chat of the chat
     */
    _: 'chatMemberStatusBanned',
    /**
     * Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If
     * the user is banned for more than 366 days or for less than 30 seconds from the
     * current time, the user is considered to be banned forever. Always 0 in basic
     * groups
     */
    banned_until_date: number,
  }

  export type chatMemberStatusBanned$Input = {
    /**
     * The user or the chat was banned (and hence is not a member of the chat). Implies
     * the user can't return to the chat, view messages, or be used as a participant
     * identifier to join a video chat of the chat
     */
    readonly _: 'chatMemberStatusBanned',
    /**
     * Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If
     * the user is banned for more than 366 days or for less than 30 seconds from the
     * current time, the user is considered to be banned forever. Always 0 in basic
     * groups
     */
    readonly banned_until_date?: number,
  }

  export type chatMember = {
    /** Describes a user or a chat as a member of another chat */
    _: 'chatMember',
    /**
     * Identifier of the chat member. Currently, other chats can be only Left or Banned.
     * Only supergroups and channels can have other chats as Left or Banned members
     * and these chats must be supergroups or channels
     */
    member_id: MessageSender,
    /**
     * Identifier of a user that invited/promoted/banned this member in the chat; 0
     * if unknown
     */
    inviter_user_id: number,
    /**
     * Point in time (Unix timestamp) when the user joined/was promoted/was banned
     * in the chat
     */
    joined_chat_date: number,
    /** Status of the member in the chat */
    status: ChatMemberStatus,
  }

  export type chatMembers = {
    /** Contains a list of chat members */
    _: 'chatMembers',
    /** Approximate total number of chat members found */
    total_count: number,
    /** A list of chat members */
    members: Array<chatMember>,
  }

  export type chatMembersFilterContacts$Input = {
    /** Returns contacts of the user */
    readonly _: 'chatMembersFilterContacts',
  }

  export type chatMembersFilterAdministrators$Input = {
    /** Returns the owner and administrators */
    readonly _: 'chatMembersFilterAdministrators',
  }

  export type chatMembersFilterMembers$Input = {
    /** Returns all chat members, including restricted chat members */
    readonly _: 'chatMembersFilterMembers',
  }

  export type chatMembersFilterMention$Input = {
    /** Returns users which can be mentioned in the chat */
    readonly _: 'chatMembersFilterMention',
    /** If non-zero, the identifier of the current message thread */
    readonly message_thread_id?: number,
  }

  export type chatMembersFilterRestricted$Input = {
    /**
     * Returns users under certain restrictions in the chat; can be used only by administrators
     * in a supergroup
     */
    readonly _: 'chatMembersFilterRestricted',
  }

  export type chatMembersFilterBanned$Input = {
    /**
     * Returns users banned from the chat; can be used only by administrators in a
     * supergroup or in a channel
     */
    readonly _: 'chatMembersFilterBanned',
  }

  export type chatMembersFilterBots$Input = {
    /** Returns bot members of the chat */
    readonly _: 'chatMembersFilterBots',
  }

  export type supergroupMembersFilterRecent$Input = {
    /** Returns recently active users in reverse chronological order */
    readonly _: 'supergroupMembersFilterRecent',
  }

  export type supergroupMembersFilterContacts$Input = {
    /** Returns contacts of the user, which are members of the supergroup or channel */
    readonly _: 'supergroupMembersFilterContacts',
    /** Query to search for */
    readonly query?: string,
  }

  export type supergroupMembersFilterAdministrators$Input = {
    /** Returns the owner and administrators */
    readonly _: 'supergroupMembersFilterAdministrators',
  }

  export type supergroupMembersFilterSearch$Input = {
    /** Used to search for supergroup or channel members via a (string) query */
    readonly _: 'supergroupMembersFilterSearch',
    /** Query to search for */
    readonly query?: string,
  }

  export type supergroupMembersFilterRestricted$Input = {
    /** Returns restricted supergroup members; can be used only by administrators */
    readonly _: 'supergroupMembersFilterRestricted',
    /** Query to search for */
    readonly query?: string,
  }

  export type supergroupMembersFilterBanned$Input = {
    /** Returns users banned from the supergroup or channel; can be used only by administrators */
    readonly _: 'supergroupMembersFilterBanned',
    /** Query to search for */
    readonly query?: string,
  }

  export type supergroupMembersFilterMention$Input = {
    /** Returns users which can be mentioned in the supergroup */
    readonly _: 'supergroupMembersFilterMention',
    /** Query to search for */
    readonly query?: string,
    /** If non-zero, the identifier of the current message thread */
    readonly message_thread_id?: number,
  }

  export type supergroupMembersFilterBots$Input = {
    /** Returns bot members of the supergroup or channel */
    readonly _: 'supergroupMembersFilterBots',
  }

  export type chatInviteLink = {
    /** Contains a chat invite link */
    _: 'chatInviteLink',
    /** Chat invite link */
    invite_link: string,
    /** Name of the link */
    name: string,
    /** User identifier of an administrator created the link */
    creator_user_id: number,
    /** Point in time (Unix timestamp) when the link was created */
    date: number,
    /**
     * Point in time (Unix timestamp) when the link was last edited; 0 if never or
     * unknown
     */
    edit_date: number,
    /** Point in time (Unix timestamp) when the link will expire; 0 if never */
    expiration_date: number,
    /**
     * The maximum number of members, which can join the chat using the link simultaneously;
     * 0 if not limited. Always 0 if the link requires approval
     */
    member_limit: number,
    /** Number of chat members, which joined the chat using the link */
    member_count: number,
    /** Number of pending join requests created using this link */
    pending_join_request_count: number,
    /**
     * True, if the link only creates join request. If true, total number of joining
     * members will be unlimited
     */
    creates_join_request: boolean,
    /**
     * True, if the link is primary. Primary invite link can't have name, expiration
     * date, or usage limit. There is exactly one primary invite link for each administrator
     * with can_invite_users right at a given time
     */
    is_primary: boolean,
    /** True, if the link was revoked */
    is_revoked: boolean,
  }

  export type chatInviteLinks = {
    /** Contains a list of chat invite links */
    _: 'chatInviteLinks',
    /** Approximate total number of chat invite links found */
    total_count: number,
    /** List of invite links */
    invite_links: Array<chatInviteLink>,
  }

  export type chatInviteLinkCount = {
    /**
     * Describes a chat administrator with a number of active and revoked chat invite
     * links
     */
    _: 'chatInviteLinkCount',
    /** Administrator's user identifier */
    user_id: number,
    /** Number of active invite links */
    invite_link_count: number,
    /** Number of revoked invite links */
    revoked_invite_link_count: number,
  }

  export type chatInviteLinkCounts = {
    /** Contains a list of chat invite link counts */
    _: 'chatInviteLinkCounts',
    /** List of invite link counts */
    invite_link_counts: Array<chatInviteLinkCount>,
  }

  export type chatInviteLinkMember = {
    /** Describes a chat member joined a chat via an invite link */
    _: 'chatInviteLinkMember',
    /** User identifier */
    user_id: number,
    /** Point in time (Unix timestamp) when the user joined the chat */
    joined_chat_date: number,
    /** True, if the user has joined the chat using an invite link for a chat folder */
    via_chat_folder_invite_link: boolean,
    /** User identifier of the chat administrator, approved user join request */
    approver_user_id: number,
  }

  export type chatInviteLinkMember$Input = {
    /** Describes a chat member joined a chat via an invite link */
    readonly _: 'chatInviteLinkMember',
    /** User identifier */
    readonly user_id?: number,
    /** Point in time (Unix timestamp) when the user joined the chat */
    readonly joined_chat_date?: number,
    /** True, if the user has joined the chat using an invite link for a chat folder */
    readonly via_chat_folder_invite_link?: boolean,
    /** User identifier of the chat administrator, approved user join request */
    readonly approver_user_id?: number,
  }

  export type chatInviteLinkMembers = {
    /** Contains a list of chat members joined a chat via an invite link */
    _: 'chatInviteLinkMembers',
    /** Approximate total number of chat members found */
    total_count: number,
    /** List of chat members, joined a chat via an invite link */
    members: Array<chatInviteLinkMember>,
  }

  export type inviteLinkChatTypeBasicGroup = {
    /** The link is an invite link for a basic group */
    _: 'inviteLinkChatTypeBasicGroup',
  }

  export type inviteLinkChatTypeSupergroup = {
    /** The link is an invite link for a supergroup */
    _: 'inviteLinkChatTypeSupergroup',
  }

  export type inviteLinkChatTypeChannel = {
    /** The link is an invite link for a channel */
    _: 'inviteLinkChatTypeChannel',
  }

  export type chatInviteLinkInfo = {
    /** Contains information about a chat invite link */
    _: 'chatInviteLinkInfo',
    /**
     * Chat identifier of the invite link; 0 if the user has no access to the chat
     * before joining
     */
    chat_id: number,
    /**
     * If non-zero, the amount of time for which read access to the chat will remain
     * available, in seconds
     */
    accessible_for: number,
    /** Type of the chat */
    type: InviteLinkChatType,
    /** Title of the chat */
    title: string,
    /** Chat photo; may be null */
    photo?: chatPhotoInfo,
    /** Chat description */
    description: string,
    /** Number of members in the chat */
    member_count: number,
    /** User identifiers of some chat members that may be known to the current user */
    member_user_ids: Array<number>,
    /** True, if the link only creates join request */
    creates_join_request: boolean,
    /**
     * True, if the chat is a public supergroup or channel, i.e. it has a username
     * or it is a location-based supergroup
     */
    is_public: boolean,
    /** True, if the chat is verified */
    is_verified: boolean,
    /** True, if many users reported this chat as a scam */
    is_scam: boolean,
    /** True, if many users reported this chat as a fake account */
    is_fake: boolean,
  }

  export type chatJoinRequest = {
    /** Describes a user that sent a join request and waits for administrator approval */
    _: 'chatJoinRequest',
    /** User identifier */
    user_id: number,
    /** Point in time (Unix timestamp) when the user sent the join request */
    date: number,
    /** A short bio of the user */
    bio: string,
  }

  export type chatJoinRequest$Input = {
    /** Describes a user that sent a join request and waits for administrator approval */
    readonly _: 'chatJoinRequest',
    /** User identifier */
    readonly user_id?: number,
    /** Point in time (Unix timestamp) when the user sent the join request */
    readonly date?: number,
    /** A short bio of the user */
    readonly bio?: string,
  }

  export type chatJoinRequests = {
    /** Contains a list of requests to join a chat */
    _: 'chatJoinRequests',
    /** Approximate total number of requests found */
    total_count: number,
    /** List of the requests */
    requests: Array<chatJoinRequest>,
  }

  export type chatJoinRequestsInfo = {
    /** Contains information about pending join requests for a chat */
    _: 'chatJoinRequestsInfo',
    /** Total number of pending join requests */
    total_count: number,
    /** Identifiers of at most 3 users sent the newest pending join requests */
    user_ids: Array<number>,
  }

  export type basicGroup = {
    /**
     * Represents a basic group of 0-200 users (must be upgraded to a supergroup to
     * accommodate more than 200 users)
     */
    _: 'basicGroup',
    /** Group identifier */
    id: number,
    /** Number of members in the group */
    member_count: number,
    /** Status of the current user in the group */
    status: ChatMemberStatus,
    /** True, if the group is active */
    is_active: boolean,
    /** Identifier of the supergroup to which this group was upgraded; 0 if none */
    upgraded_to_supergroup_id: number,
  }

  export type basicGroupFullInfo = {
    /** Contains full information about a basic group */
    _: 'basicGroupFullInfo',
    /**
     * Chat photo; may be null if empty or unknown. If non-null, then it is the same
     * photo as in chat.photo
     */
    photo?: chatPhoto,
    /** Group description. Updated only after the basic group is opened */
    description: string,
    /** User identifier of the creator of the group; 0 if unknown */
    creator_user_id: number,
    /** Group members */
    members: Array<chatMember>,
    /**
     * True, if non-administrators and non-bots can be hidden in responses to getSupergroupMembers
     * and searchChatMembers for non-administrators after upgrading the basic group
     * to a supergroup
     */
    can_hide_members: boolean,
    /**
     * True, if aggressive anti-spam checks can be enabled or disabled in the supergroup
     * after upgrading the basic group to a supergroup
     */
    can_toggle_aggressive_anti_spam: boolean,
    /**
     * Primary invite link for this group; may be null. For chat administrators with
     * can_invite_users right only. Updated only after the basic group is opened
     */
    invite_link?: chatInviteLink,
    /** List of commands of bots in the group */
    bot_commands: Array<botCommands>,
  }

  export type supergroup = {
    /**
     * Represents a supergroup or channel with zero or more members (subscribers in
     * the case of channels). From the point of view of the system, a channel is a
     * special kind of a supergroup: only administrators can post and see the list
     * of members, and posts from all administrators use the name and photo of the
     * channel instead of individual names and profile photos. Unlike supergroups,
     * channels can have an unlimited number of subscribers
     */
    _: 'supergroup',
    /** Supergroup or channel identifier */
    id: number,
    /** Usernames of the supergroup or channel; may be null */
    usernames?: usernames,
    /**
     * Point in time (Unix timestamp) when the current user joined, or the point in
     * time when the supergroup or channel was created, in case the user is not a member
     */
    date: number,
    /**
     * Status of the current user in the supergroup or channel; custom title will always
     * be empty
     */
    status: ChatMemberStatus,
    /**
     * Number of members in the supergroup or channel; 0 if unknown. Currently, it
     * is guaranteed to be known only if the supergroup or channel was received through
     * searchPublicChats, searchChatsNearby, getInactiveSupergroupChats, getSuitableDiscussionChats,
     * getGroupsInCommon, getUserPrivacySettingRules, or in chatFolderInviteLinkInfo.missing_chat_ids
     */
    member_count: number,
    /**
     * True, if the channel has a discussion group, or the supergroup is the designated
     * discussion group for a channel
     */
    has_linked_chat: boolean,
    /**
     * True, if the supergroup is connected to a location, i.e. the supergroup is a
     * location-based supergroup
     */
    has_location: boolean,
    /**
     * True, if messages sent to the channel need to contain information about the
     * sender. This field is only applicable to channels
     */
    sign_messages: boolean,
    /**
     * True, if users need to join the supergroup before they can send messages. Always
     * true for channels and non-discussion supergroups
     */
    join_to_send_messages: boolean,
    /**
     * True, if all users directly joining the supergroup need to be approved by supergroup
     * administrators. Always false for channels and supergroups without username,
     * location, or a linked chat
     */
    join_by_request: boolean,
    /** True, if the slow mode is enabled in the supergroup */
    is_slow_mode_enabled: boolean,
    /** True, if the supergroup is a channel */
    is_channel: boolean,
    /**
     * True, if the supergroup is a broadcast group, i.e. only administrators can send
     * messages and there is no limit on the number of members
     */
    is_broadcast_group: boolean,
    /** True, if the supergroup must be shown as a forum by default */
    is_forum: boolean,
    /** True, if the supergroup or channel is verified */
    is_verified: boolean,
    /**
     * If non-empty, contains a human-readable description of the reason why access
     * to this supergroup or channel must be restricted
     */
    restriction_reason: string,
    /** True, if many users reported this supergroup or channel as a scam */
    is_scam: boolean,
    /** True, if many users reported this supergroup or channel as a fake account */
    is_fake: boolean,
    /** True, if the channel has non-expired stories available to the current user */
    has_active_stories: boolean,
    /**
     * True, if the channel has unread non-expired stories available to the current
     * user
     */
    has_unread_active_stories: boolean,
  }

  export type supergroupFullInfo = {
    /** Contains full information about a supergroup or channel */
    _: 'supergroupFullInfo',
    /**
     * Chat photo; may be null if empty or unknown. If non-null, then it is the same
     * photo as in chat.photo
     */
    photo?: chatPhoto,
    /** Supergroup or channel description */
    description: string,
    /** Number of members in the supergroup or channel; 0 if unknown */
    member_count: number,
    /** Number of privileged users in the supergroup or channel; 0 if unknown */
    administrator_count: number,
    /** Number of restricted users in the supergroup; 0 if unknown */
    restricted_count: number,
    /** Number of users banned from chat; 0 if unknown */
    banned_count: number,
    /**
     * Chat identifier of a discussion group for the channel, or a channel, for which
     * the supergroup is the designated discussion group; 0 if none or unknown
     */
    linked_chat_id: number,
    /**
     * Delay between consecutive sent messages for non-administrator supergroup members,
     * in seconds
     */
    slow_mode_delay: number,
    /**
     * Time left before next message can be sent in the supergroup, in seconds. An
     * updateSupergroupFullInfo update is not triggered when value of this field changes,
     * but both new and old values are non-zero
     */
    slow_mode_delay_expires_in: number,
    /** True, if members of the chat can be retrieved via getSupergroupMembers or searchChatMembers */
    can_get_members: boolean,
    /**
     * True, if non-administrators can receive only administrators and bots using getSupergroupMembers
     * or searchChatMembers
     */
    has_hidden_members: boolean,
    /**
     * True, if non-administrators and non-bots can be hidden in responses to getSupergroupMembers
     * and searchChatMembers for non-administrators
     */
    can_hide_members: boolean,
    /** True, if the supergroup sticker set can be changed */
    can_set_sticker_set: boolean,
    /** True, if the supergroup location can be changed */
    can_set_location: boolean,
    /** True, if the supergroup or channel statistics are available */
    can_get_statistics: boolean,
    /** True, if aggressive anti-spam checks can be enabled or disabled in the supergroup */
    can_toggle_aggressive_anti_spam: boolean,
    /**
     * True, if new chat members will have access to old messages. In public, discussion,
     * of forum groups and all channels, old messages are always available, so this
     * option affects only private non-forum supergroups without a linked chat. The
     * value of this field is only available to chat administrators
     */
    is_all_history_available: boolean,
    /**
     * True, if aggressive anti-spam checks are enabled in the supergroup. The value
     * of this field is only available to chat administrators
     */
    has_aggressive_anti_spam_enabled: boolean,
    /** True, if the channel has pinned stories */
    has_pinned_stories: boolean,
    /** Identifier of the supergroup sticker set; 0 if none */
    sticker_set_id: number | string,
    /** Location to which the supergroup is connected; may be null if none */
    location?: chatLocation,
    /**
     * Primary invite link for the chat; may be null. For chat administrators with
     * can_invite_users right only
     */
    invite_link?: chatInviteLink,
    /** List of commands of bots in the group */
    bot_commands: Array<botCommands>,
    /** Identifier of the basic group from which supergroup was upgraded; 0 if none */
    upgraded_from_basic_group_id: number,
    /**
     * Identifier of the last message in the basic group from which supergroup was
     * upgraded; 0 if none
     */
    upgraded_from_max_message_id: number,
  }

  export type secretChatStatePending = {
    /** The secret chat is not yet created; waiting for the other user to get online */
    _: 'secretChatStatePending',
  }

  export type secretChatStateReady = {
    /** The secret chat is ready to use */
    _: 'secretChatStateReady',
  }

  export type secretChatStateClosed = {
    /** The secret chat is closed */
    _: 'secretChatStateClosed',
  }

  export type secretChat = {
    /** Represents a secret chat */
    _: 'secretChat',
    /** Secret chat identifier */
    id: number,
    /** Identifier of the chat partner */
    user_id: number,
    /** State of the secret chat */
    state: SecretChatState,
    /** True, if the chat was created by the current user; false otherwise */
    is_outbound: boolean,
    /**
     * Hash of the currently used key for comparison with the hash of the chat partner's
     * key. This is a string of 36 little-endian bytes, which must be split into groups
     * of 2 bits, each denoting a pixel of one of 4 colors FFFFFF, D5E6F3, 2D5775,
     * and 2F99C9. The pixels must be used to make a 12x12 square image filled from
     * left to right, top to bottom. Alternatively, the first 32 bytes of the hash
     * can be converted to the hexadecimal format and printed as 32 2-digit hex numbers
     */
    key_hash: string,
    /**
     * Secret chat layer; determines features supported by the chat partner's application.
     * Nested text entities and underline and strikethrough entities are supported
     * if the layer >= 101, files bigger than 2000MB are supported if the layer >=
     * 143, spoiler and custom emoji text entities are supported if the layer >= 144
     */
    layer: number,
  }

  export type messageSenderUser = {
    /** The message was sent by a known user */
    _: 'messageSenderUser',
    /** Identifier of the user that sent the message */
    user_id: number,
  }

  export type messageSenderUser$Input = {
    /** The message was sent by a known user */
    readonly _: 'messageSenderUser',
    /** Identifier of the user that sent the message */
    readonly user_id?: number,
  }

  export type messageSenderChat = {
    /** The message was sent on behalf of a chat */
    _: 'messageSenderChat',
    /** Identifier of the chat that sent the message */
    chat_id: number,
  }

  export type messageSenderChat$Input = {
    /** The message was sent on behalf of a chat */
    readonly _: 'messageSenderChat',
    /** Identifier of the chat that sent the message */
    readonly chat_id?: number,
  }

  export type messageSenders = {
    /** Represents a list of message senders */
    _: 'messageSenders',
    /** Approximate total number of messages senders found */
    total_count: number,
    /** List of message senders */
    senders: Array<MessageSender>,
  }

  export type chatMessageSender = {
    /** Represents a message sender, which can be used to send messages in a chat */
    _: 'chatMessageSender',
    /** Available message senders */
    sender: MessageSender,
    /** True, if Telegram Premium is needed to use the message sender */
    needs_premium: boolean,
  }

  export type chatMessageSenders = {
    /**
     * Represents a list of message senders, which can be used to send messages in
     * a chat
     */
    _: 'chatMessageSenders',
    /** List of available message senders */
    senders: Array<chatMessageSender>,
  }

  export type messageViewer = {
    /** Represents a viewer of a message */
    _: 'messageViewer',
    /** User identifier of the viewer */
    user_id: number,
    /** Approximate point in time (Unix timestamp) when the message was viewed */
    view_date: number,
  }

  export type messageViewers = {
    /** Represents a list of message viewers */
    _: 'messageViewers',
    /** List of message viewers */
    viewers: Array<messageViewer>,
  }

  export type messageForwardOriginUser = {
    /** The message was originally sent by a known user */
    _: 'messageForwardOriginUser',
    /** Identifier of the user that originally sent the message */
    sender_user_id: number,
  }

  export type messageForwardOriginChat = {
    /** The message was originally sent on behalf of a chat */
    _: 'messageForwardOriginChat',
    /** Identifier of the chat that originally sent the message */
    sender_chat_id: number,
    /**
     * For messages originally sent by an anonymous chat administrator, original message
     * author signature
     */
    author_signature: string,
  }

  export type messageForwardOriginHiddenUser = {
    /**
     * The message was originally sent by a user, which is hidden by their privacy
     * settings
     */
    _: 'messageForwardOriginHiddenUser',
    /** Name of the sender */
    sender_name: string,
  }

  export type messageForwardOriginChannel = {
    /** The message was originally a post in a channel */
    _: 'messageForwardOriginChannel',
    /** Identifier of the chat from which the message was originally forwarded */
    chat_id: number,
    /** Message identifier of the original message */
    message_id: number,
    /** Original post author signature */
    author_signature: string,
  }

  export type messageForwardOriginMessageImport = {
    /** The message was imported from an exported message history */
    _: 'messageForwardOriginMessageImport',
    /** Name of the sender */
    sender_name: string,
  }

  export type reactionTypeEmoji = {
    /** A reaction with an emoji */
    _: 'reactionTypeEmoji',
    /** Text representation of the reaction */
    emoji: string,
  }

  export type reactionTypeEmoji$Input = {
    /** A reaction with an emoji */
    readonly _: 'reactionTypeEmoji',
    /** Text representation of the reaction */
    readonly emoji?: string,
  }

  export type reactionTypeCustomEmoji = {
    /** A reaction with a custom emoji */
    _: 'reactionTypeCustomEmoji',
    /** Unique identifier of the custom emoji */
    custom_emoji_id: number | string,
  }

  export type reactionTypeCustomEmoji$Input = {
    /** A reaction with a custom emoji */
    readonly _: 'reactionTypeCustomEmoji',
    /** Unique identifier of the custom emoji */
    readonly custom_emoji_id?: number | string,
  }

  export type messageForwardInfo = {
    /** Contains information about a forwarded message */
    _: 'messageForwardInfo',
    /** Origin of a forwarded message */
    origin: MessageForwardOrigin,
    /** Point in time (Unix timestamp) when the message was originally sent */
    date: number,
    /** The type of a public service announcement for the forwarded message */
    public_service_announcement_type: string,
    /**
     * For messages forwarded to the chat with the current user (Saved Messages), to
     * the Replies bot chat, or to the channel's discussion group, the identifier of
     * the chat from which the message was forwarded last time; 0 if unknown
     */
    from_chat_id: number,
    /**
     * For messages forwarded to the chat with the current user (Saved Messages), to
     * the Replies bot chat, or to the channel's discussion group, the identifier of
     * the original message from which the new message was forwarded last time; 0 if
     * unknown
     */
    from_message_id: number,
  }

  export type messageReplyInfo = {
    /** Contains information about replies to a message */
    _: 'messageReplyInfo',
    /** Number of times the message was directly or indirectly replied */
    reply_count: number,
    /**
     * Identifiers of at most 3 recent repliers to the message; available in channels
     * with a discussion supergroup. The users and chats are expected to be inaccessible:
     * only their photo and name will be available
     */
    recent_replier_ids: Array<MessageSender>,
    /** Identifier of the last read incoming reply to the message */
    last_read_inbox_message_id: number,
    /** Identifier of the last read outgoing reply to the message */
    last_read_outbox_message_id: number,
    /** Identifier of the last reply to the message */
    last_message_id: number,
  }

  export type messageReaction = {
    /** Contains information about a reaction to a message */
    _: 'messageReaction',
    /** Type of the reaction */
    type: ReactionType,
    /** Number of times the reaction was added */
    total_count: number,
    /** True, if the reaction is chosen by the current user */
    is_chosen: boolean,
    /**
     * Identifiers of at most 3 recent message senders, added the reaction; available
     * in private, basic group and supergroup chats
     */
    recent_sender_ids: Array<MessageSender>,
  }

  export type messageInteractionInfo = {
    /** Contains information about interactions with a message */
    _: 'messageInteractionInfo',
    /** Number of times the message was viewed */
    view_count: number,
    /** Number of times the message was forwarded */
    forward_count: number,
    /**
     * Information about direct or indirect replies to the message; may be null. Currently,
     * available only in channels with a discussion supergroup and discussion supergroups
     * for messages, which are not replies itself
     */
    reply_info?: messageReplyInfo,
    /** The list of reactions added to the message */
    reactions: Array<messageReaction>,
  }

  export type unreadReaction = {
    /** Contains information about an unread reaction to a message */
    _: 'unreadReaction',
    /** Type of the reaction */
    type: ReactionType,
    /** Identifier of the sender, added the reaction */
    sender_id: MessageSender,
    /** True, if the reaction was added with a big animation */
    is_big: boolean,
  }

  export type messageSendingStatePending = {
    /** The message is being sent now, but has not yet been delivered to the server */
    _: 'messageSendingStatePending',
    /** Non-persistent message sending identifier, specified by the application */
    sending_id: number,
  }

  export type messageSendingStateFailed = {
    /** The message failed to be sent */
    _: 'messageSendingStateFailed',
    /** The cause of the message sending failure */
    error: error,
    /** True, if the message can be re-sent */
    can_retry: boolean,
    /** True, if the message can be re-sent only on behalf of a different sender */
    need_another_sender: boolean,
    /**
     * Time left before the message can be re-sent, in seconds. No update is sent when
     * this field changes
     */
    retry_after: number,
  }

  export type messageReplyToMessage = {
    /** Describes a replied message */
    _: 'messageReplyToMessage',
    /**
     * The identifier of the chat to which the replied message belongs; ignored for
     * outgoing replies. For example, messages in the Replies chat are replies to messages
     * in different chats
     */
    chat_id: number,
    /** The identifier of the replied message */
    message_id: number,
  }

  export type messageReplyToMessage$Input = {
    /** Describes a replied message */
    readonly _: 'messageReplyToMessage',
    /**
     * The identifier of the chat to which the replied message belongs; ignored for
     * outgoing replies. For example, messages in the Replies chat are replies to messages
     * in different chats
     */
    readonly chat_id?: number,
    /** The identifier of the replied message */
    readonly message_id?: number,
  }

  export type messageReplyToStory = {
    /** Describes a replied story */
    _: 'messageReplyToStory',
    /**
     * The identifier of the sender of the replied story. Currently, stories can be
     * replied only in the sender's chat
     */
    story_sender_chat_id: number,
    /** The identifier of the replied story */
    story_id: number,
  }

  export type messageReplyToStory$Input = {
    /** Describes a replied story */
    readonly _: 'messageReplyToStory',
    /**
     * The identifier of the sender of the replied story. Currently, stories can be
     * replied only in the sender's chat
     */
    readonly story_sender_chat_id?: number,
    /** The identifier of the replied story */
    readonly story_id?: number,
  }

  export type message = {
    /** Describes a message */
    _: 'message',
    /** Message identifier; unique for the chat to which the message belongs */
    id: number,
    /** Identifier of the sender of the message */
    sender_id: MessageSender,
    /** Chat identifier */
    chat_id: number,
    /**
     * The sending state of the message; may be null if the message isn't being sent
     * and didn't fail to be sent
     */
    sending_state?: MessageSendingState,
    /** The scheduling state of the message; may be null if the message isn't scheduled */
    scheduling_state?: MessageSchedulingState,
    /** True, if the message is outgoing */
    is_outgoing: boolean,
    /** True, if the message is pinned */
    is_pinned: boolean,
    /**
     * True, if the message can be edited. For live location and poll messages this
     * fields shows whether editMessageLiveLocation or stopPoll can be used with this
     * message by the application
     */
    can_be_edited: boolean,
    /** True, if the message can be forwarded */
    can_be_forwarded: boolean,
    /** True, if content of the message can be saved locally or copied */
    can_be_saved: boolean,
    /**
     * True, if the message can be deleted only for the current user while other users
     * will continue to see it
     */
    can_be_deleted_only_for_self: boolean,
    /** True, if the message can be deleted for all users */
    can_be_deleted_for_all_users: boolean,
    /** True, if the list of added reactions is available through getMessageAddedReactions */
    can_get_added_reactions: boolean,
    /** True, if the message statistics are available through getMessageStatistics */
    can_get_statistics: boolean,
    /**
     * True, if information about the message thread is available through getMessageThread
     * and getMessageThreadHistory
     */
    can_get_message_thread: boolean,
    /** True, if chat members already viewed the message can be received through getMessageViewers */
    can_get_viewers: boolean,
    /**
     * True, if media timestamp links can be generated for media timestamp entities
     * in the message text, caption or web page description through getMessageLink
     */
    can_get_media_timestamp_links: boolean,
    /** True, if reactions on the message can be reported through reportMessageReactions */
    can_report_reactions: boolean,
    /**
     * True, if media timestamp entities refers to a media in this message as opposed
     * to a media in the replied message
     */
    has_timestamped_media: boolean,
    /**
     * True, if the message is a channel post. All messages to channels are channel
     * posts, all other messages are not channel posts
     */
    is_channel_post: boolean,
    /** True, if the message is a forum topic message */
    is_topic_message: boolean,
    /** True, if the message contains an unread mention for the current user */
    contains_unread_mention: boolean,
    /** Point in time (Unix timestamp) when the message was sent */
    date: number,
    /** Point in time (Unix timestamp) when the message was last edited */
    edit_date: number,
    /** Information about the initial message sender; may be null if none or unknown */
    forward_info?: messageForwardInfo,
    /** Information about interactions with the message; may be null if none */
    interaction_info?: messageInteractionInfo,
    /** Information about unread reactions added to the message */
    unread_reactions: Array<unreadReaction>,
    /**
     * Information about the message or the story this message is replying to; may
     * be null if none
     */
    reply_to?: MessageReplyTo,
    /**
     * If non-zero, the identifier of the message thread the message belongs to; unique
     * within the chat to which the message belongs
     */
    message_thread_id: number,
    /** The message's self-destruct type; may be null if none */
    self_destruct_type?: MessageSelfDestructType,
    /**
     * Time left before the message self-destruct timer expires, in seconds; 0 if self-desctruction
     * isn't scheduled yet
     */
    self_destruct_in: number,
    /**
     * Time left before the message will be automatically deleted by message_auto_delete_time
     * setting of the chat, in seconds; 0 if never
     */
    auto_delete_in: number,
    /** If non-zero, the user identifier of the bot through which this message was sent */
    via_bot_user_id: number,
    /** For channel posts and anonymous group messages, optional author signature */
    author_signature: string,
    /**
     * Unique identifier of an album this message belongs to. Only audios, documents,
     * photos and videos can be grouped together in albums
     */
    media_album_id: number | string,
    /**
     * If non-empty, contains a human-readable description of the reason why access
     * to this message must be restricted
     */
    restriction_reason: string,
    /** Content of the message */
    content: MessageContent,
    /** Reply markup for the message; may be null if none */
    reply_markup?: ReplyMarkup,
  }

  export type messages = {
    /** Contains a list of messages */
    _: 'messages',
    /** Approximate total number of messages found */
    total_count: number,
    /** List of messages; messages may be null */
    messages: Array<message | null>,
  }

  export type foundMessages = {
    /** Contains a list of messages found by a search */
    _: 'foundMessages',
    /** Approximate total number of messages found; -1 if unknown */
    total_count: number,
    /** List of messages */
    messages: Array<message>,
    /** The offset for the next request. If empty, there are no more results */
    next_offset: string,
  }

  export type foundChatMessages = {
    /** Contains a list of messages found by a search in a given chat */
    _: 'foundChatMessages',
    /** Approximate total number of messages found; -1 if unknown */
    total_count: number,
    /** List of messages */
    messages: Array<message>,
    /** The offset for the next request. If 0, there are no more results */
    next_from_message_id: number,
  }

  export type messagePosition = {
    /** Contains information about a message in a specific position */
    _: 'messagePosition',
    /** 0-based message position in the full list of suitable messages */
    position: number,
    /** Message identifier */
    message_id: number,
    /** Point in time (Unix timestamp) when the message was sent */
    date: number,
  }

  export type messagePositions = {
    /** Contains a list of message positions */
    _: 'messagePositions',
    /** Total number of messages found */
    total_count: number,
    /** List of message positions */
    positions: Array<messagePosition>,
  }

  export type messageCalendarDay = {
    /** Contains information about found messages sent on a specific day */
    _: 'messageCalendarDay',
    /** Total number of found messages sent on the day */
    total_count: number,
    /** First message sent on the day */
    message: message,
  }

  export type messageCalendar = {
    /**
     * Contains information about found messages, split by days according to the option
     * "utc_time_offset"
     */
    _: 'messageCalendar',
    /** Total number of found messages */
    total_count: number,
    /** Information about messages sent */
    days: Array<messageCalendarDay>,
  }

  export type messageSourceChatHistory$Input = {
    /** The message is from a chat history */
    readonly _: 'messageSourceChatHistory',
  }

  export type messageSourceMessageThreadHistory$Input = {
    /** The message is from a message thread history */
    readonly _: 'messageSourceMessageThreadHistory',
  }

  export type messageSourceForumTopicHistory$Input = {
    /** The message is from a forum topic history */
    readonly _: 'messageSourceForumTopicHistory',
  }

  export type messageSourceHistoryPreview$Input = {
    /** The message is from chat, message thread or forum topic history preview */
    readonly _: 'messageSourceHistoryPreview',
  }

  export type messageSourceChatList$Input = {
    /** The message is from a chat list or a forum topic list */
    readonly _: 'messageSourceChatList',
  }

  export type messageSourceSearch$Input = {
    /**
     * The message is from search results, including file downloads, local file list,
     * outgoing document messages, calendar
     */
    readonly _: 'messageSourceSearch',
  }

  export type messageSourceChatEventLog$Input = {
    /** The message is from a chat event log */
    readonly _: 'messageSourceChatEventLog',
  }

  export type messageSourceNotification$Input = {
    /** The message is from a notification */
    readonly _: 'messageSourceNotification',
  }

  export type messageSourceScreenshot$Input = {
    /**
     * The message was screenshotted; the source must be used only if the message content
     * was visible during the screenshot
     */
    readonly _: 'messageSourceScreenshot',
  }

  export type messageSourceOther$Input = {
    /** The message is from some other source */
    readonly _: 'messageSourceOther',
  }

  export type messageSponsorTypeBot = {
    /** The sponsor is a bot */
    _: 'messageSponsorTypeBot',
    /** User identifier of the bot */
    bot_user_id: number,
    /** An internal link to be opened when the sponsored message is clicked */
    link: InternalLinkType,
  }

  export type messageSponsorTypePublicChannel = {
    /** The sponsor is a public channel chat */
    _: 'messageSponsorTypePublicChannel',
    /** Sponsor chat identifier */
    chat_id: number,
    /**
     * An internal link to be opened when the sponsored message is clicked; may be
     * null if the sponsor chat needs to be opened instead
     */
    link?: InternalLinkType,
  }

  export type messageSponsorTypePrivateChannel = {
    /** The sponsor is a private channel chat */
    _: 'messageSponsorTypePrivateChannel',
    /** Title of the chat */
    title: string,
    /** Invite link for the channel */
    invite_link: string,
  }

  export type messageSponsorTypeWebsite = {
    /** The sponsor is a website */
    _: 'messageSponsorTypeWebsite',
    /** URL of the website */
    url: string,
    /** Name of the website */
    name: string,
  }

  export type messageSponsor = {
    /** Information about the sponsor of a message */
    _: 'messageSponsor',
    /** Type of the sponsor */
    type: MessageSponsorType,
    /** Photo of the sponsor; may be null if must not be shown */
    photo?: chatPhotoInfo,
    /**
     * Additional optional information about the sponsor to be shown along with the
     * message
     */
    info: string,
  }

  export type sponsoredMessage = {
    /** Describes a sponsored message */
    _: 'sponsoredMessage',
    /**
     * Message identifier; unique for the chat to which the sponsored message belongs
     * among both ordinary and sponsored messages
     */
    message_id: number,
    /** True, if the message needs to be labeled as "recommended" instead of "sponsored" */
    is_recommended: boolean,
    /** Content of the message. Currently, can be only of the type messageText */
    content: MessageContent,
    /** Information about the sponsor of the message */
    sponsor: messageSponsor,
    /**
     * If non-empty, additional information about the sponsored message to be shown
     * along with the message
     */
    additional_info: string,
  }

  export type sponsoredMessages = {
    /** Contains a list of sponsored messages */
    _: 'sponsoredMessages',
    /** List of sponsored messages */
    messages: Array<sponsoredMessage>,
    /**
     * The minimum number of messages between shown sponsored messages, or 0 if only
     * one sponsored message must be shown after all ordinary messages
     */
    messages_between: number,
  }

  export type fileDownload = {
    /** Describes a file added to file download list */
    _: 'fileDownload',
    /** File identifier */
    file_id: number,
    /** The message with the file */
    message: message,
    /** Point in time (Unix timestamp) when the file was added to the download list */
    add_date: number,
    /**
     * Point in time (Unix timestamp) when the file downloading was completed; 0 if
     * the file downloading isn't completed
     */
    complete_date: number,
    /** True, if downloading of the file is paused */
    is_paused: boolean,
  }

  export type downloadedFileCounts = {
    /** Contains number of being downloaded and recently downloaded files found */
    _: 'downloadedFileCounts',
    /** Number of active file downloads found, including paused */
    active_count: number,
    /** Number of paused file downloads found */
    paused_count: number,
    /** Number of completed file downloads found */
    completed_count: number,
  }

  export type foundFileDownloads = {
    /** Contains a list of downloaded files, found by a search */
    _: 'foundFileDownloads',
    /** Total number of suitable files, ignoring offset */
    total_counts: downloadedFileCounts,
    /** The list of files */
    files: Array<fileDownload>,
    /** The offset for the next request. If empty, there are no more results */
    next_offset: string,
  }

  export type notificationSettingsScopePrivateChats = {
    /**
     * Notification settings applied to all private and secret chats when the corresponding
     * chat setting has a default value
     */
    _: 'notificationSettingsScopePrivateChats',
  }

  export type notificationSettingsScopePrivateChats$Input = {
    /**
     * Notification settings applied to all private and secret chats when the corresponding
     * chat setting has a default value
     */
    readonly _: 'notificationSettingsScopePrivateChats',
  }

  export type notificationSettingsScopeGroupChats = {
    /**
     * Notification settings applied to all basic group and supergroup chats when the
     * corresponding chat setting has a default value
     */
    _: 'notificationSettingsScopeGroupChats',
  }

  export type notificationSettingsScopeGroupChats$Input = {
    /**
     * Notification settings applied to all basic group and supergroup chats when the
     * corresponding chat setting has a default value
     */
    readonly _: 'notificationSettingsScopeGroupChats',
  }

  export type notificationSettingsScopeChannelChats = {
    /**
     * Notification settings applied to all channel chats when the corresponding chat
     * setting has a default value
     */
    _: 'notificationSettingsScopeChannelChats',
  }

  export type notificationSettingsScopeChannelChats$Input = {
    /**
     * Notification settings applied to all channel chats when the corresponding chat
     * setting has a default value
     */
    readonly _: 'notificationSettingsScopeChannelChats',
  }

  export type chatNotificationSettings = {
    /** Contains information about notification settings for a chat or a forum topic */
    _: 'chatNotificationSettings',
    /**
     * If true, mute_for is ignored and the value for the relevant type of chat or
     * the forum chat is used instead
     */
    use_default_mute_for: boolean,
    /** Time left before notifications will be unmuted, in seconds */
    mute_for: number,
    /**
     * If true, the value for the relevant type of chat or the forum chat is used instead
     * of sound_id
     */
    use_default_sound: boolean,
    /**
     * Identifier of the notification sound to be played for messages; 0 if sound is
     * disabled
     */
    sound_id: number | string,
    /**
     * If true, show_preview is ignored and the value for the relevant type of chat
     * or the forum chat is used instead
     */
    use_default_show_preview: boolean,
    /** True, if message content must be displayed in notifications */
    show_preview: boolean,
    /**
     * If true, mute_stories is ignored and the value for the relevant type of chat
     * is used instead
     */
    use_default_mute_stories: boolean,
    /** True, if story notifications are disabled for the chat */
    mute_stories: boolean,
    /** If true, the value for the relevant type of chat is used instead of story_sound_id */
    use_default_story_sound: boolean,
    /**
     * Identifier of the notification sound to be played for stories; 0 if sound is
     * disabled
     */
    story_sound_id: number | string,
    /**
     * If true, show_story_sender is ignored and the value for the relevant type of
     * chat is used instead
     */
    use_default_show_story_sender: boolean,
    /** True, if the sender of stories must be displayed in notifications */
    show_story_sender: boolean,
    /**
     * If true, disable_pinned_message_notifications is ignored and the value for the
     * relevant type of chat or the forum chat is used instead
     */
    use_default_disable_pinned_message_notifications: boolean,
    /**
     * If true, notifications for incoming pinned messages will be created as for an
     * ordinary unread message
     */
    disable_pinned_message_notifications: boolean,
    /**
     * If true, disable_mention_notifications is ignored and the value for the relevant
     * type of chat or the forum chat is used instead
     */
    use_default_disable_mention_notifications: boolean,
    /**
     * If true, notifications for messages with mentions will be created as for an
     * ordinary unread message
     */
    disable_mention_notifications: boolean,
  }

  export type chatNotificationSettings$Input = {
    /** Contains information about notification settings for a chat or a forum topic */
    readonly _: 'chatNotificationSettings',
    /**
     * If true, mute_for is ignored and the value for the relevant type of chat or
     * the forum chat is used instead
     */
    readonly use_default_mute_for?: boolean,
    /** Time left before notifications will be unmuted, in seconds */
    readonly mute_for?: number,
    /**
     * If true, the value for the relevant type of chat or the forum chat is used instead
     * of sound_id
     */
    readonly use_default_sound?: boolean,
    /**
     * Identifier of the notification sound to be played for messages; 0 if sound is
     * disabled
     */
    readonly sound_id?: number | string,
    /**
     * If true, show_preview is ignored and the value for the relevant type of chat
     * or the forum chat is used instead
     */
    readonly use_default_show_preview?: boolean,
    /** True, if message content must be displayed in notifications */
    readonly show_preview?: boolean,
    /**
     * If true, mute_stories is ignored and the value for the relevant type of chat
     * is used instead
     */
    readonly use_default_mute_stories?: boolean,
    /** True, if story notifications are disabled for the chat */
    readonly mute_stories?: boolean,
    /** If true, the value for the relevant type of chat is used instead of story_sound_id */
    readonly use_default_story_sound?: boolean,
    /**
     * Identifier of the notification sound to be played for stories; 0 if sound is
     * disabled
     */
    readonly story_sound_id?: number | string,
    /**
     * If true, show_story_sender is ignored and the value for the relevant type of
     * chat is used instead
     */
    readonly use_default_show_story_sender?: boolean,
    /** True, if the sender of stories must be displayed in notifications */
    readonly show_story_sender?: boolean,
    /**
     * If true, disable_pinned_message_notifications is ignored and the value for the
     * relevant type of chat or the forum chat is used instead
     */
    readonly use_default_disable_pinned_message_notifications?: boolean,
    /**
     * If true, notifications for incoming pinned messages will be created as for an
     * ordinary unread message
     */
    readonly disable_pinned_message_notifications?: boolean,
    /**
     * If true, disable_mention_notifications is ignored and the value for the relevant
     * type of chat or the forum chat is used instead
     */
    readonly use_default_disable_mention_notifications?: boolean,
    /**
     * If true, notifications for messages with mentions will be created as for an
     * ordinary unread message
     */
    readonly disable_mention_notifications?: boolean,
  }

  export type scopeNotificationSettings = {
    /** Contains information about notification settings for several chats */
    _: 'scopeNotificationSettings',
    /** Time left before notifications will be unmuted, in seconds */
    mute_for: number,
    /** Identifier of the notification sound to be played; 0 if sound is disabled */
    sound_id: number | string,
    /** True, if message content must be displayed in notifications */
    show_preview: boolean,
    /**
     * If true, mute_stories is ignored and story notifications are received only for
     * the first 5 chats from topChatCategoryUsers
     */
    use_default_mute_stories: boolean,
    /** True, if story notifications are disabled for the chat */
    mute_stories: boolean,
    /**
     * Identifier of the notification sound to be played for stories; 0 if sound is
     * disabled
     */
    story_sound_id: number | string,
    /** True, if the sender of stories must be displayed in notifications */
    show_story_sender: boolean,
    /**
     * True, if notifications for incoming pinned messages will be created as for an
     * ordinary unread message
     */
    disable_pinned_message_notifications: boolean,
    /**
     * True, if notifications for messages with mentions will be created as for an
     * ordinary unread message
     */
    disable_mention_notifications: boolean,
  }

  export type scopeNotificationSettings$Input = {
    /** Contains information about notification settings for several chats */
    readonly _: 'scopeNotificationSettings',
    /** Time left before notifications will be unmuted, in seconds */
    readonly mute_for?: number,
    /** Identifier of the notification sound to be played; 0 if sound is disabled */
    readonly sound_id?: number | string,
    /** True, if message content must be displayed in notifications */
    readonly show_preview?: boolean,
    /**
     * If true, mute_stories is ignored and story notifications are received only for
     * the first 5 chats from topChatCategoryUsers
     */
    readonly use_default_mute_stories?: boolean,
    /** True, if story notifications are disabled for the chat */
    readonly mute_stories?: boolean,
    /**
     * Identifier of the notification sound to be played for stories; 0 if sound is
     * disabled
     */
    readonly story_sound_id?: number | string,
    /** True, if the sender of stories must be displayed in notifications */
    readonly show_story_sender?: boolean,
    /**
     * True, if notifications for incoming pinned messages will be created as for an
     * ordinary unread message
     */
    readonly disable_pinned_message_notifications?: boolean,
    /**
     * True, if notifications for messages with mentions will be created as for an
     * ordinary unread message
     */
    readonly disable_mention_notifications?: boolean,
  }

  export type draftMessage = {
    /** Contains information about a message draft */
    _: 'draftMessage',
    /** Identifier of the replied message; 0 if none */
    reply_to_message_id: number,
    /** Point in time (Unix timestamp) when the draft was created */
    date: number,
    /** Content of the message draft; must be of the type inputMessageText */
    input_message_text: InputMessageContent,
  }

  export type draftMessage$Input = {
    /** Contains information about a message draft */
    readonly _: 'draftMessage',
    /** Identifier of the replied message; 0 if none */
    readonly reply_to_message_id?: number,
    /** Point in time (Unix timestamp) when the draft was created */
    readonly date?: number,
    /** Content of the message draft; must be of the type inputMessageText */
    readonly input_message_text?: InputMessageContent$Input,
  }

  export type chatTypePrivate = {
    /** An ordinary chat with a user */
    _: 'chatTypePrivate',
    /** User identifier */
    user_id: number,
  }

  export type chatTypeBasicGroup = {
    /** A basic group (a chat with 0-200 other users) */
    _: 'chatTypeBasicGroup',
    /** Basic group identifier */
    basic_group_id: number,
  }

  export type chatTypeSupergroup = {
    /** A supergroup or channel (with unlimited members) */
    _: 'chatTypeSupergroup',
    /** Supergroup or channel identifier */
    supergroup_id: number,
    /** True, if the supergroup is a channel */
    is_channel: boolean,
  }

  export type chatTypeSecret = {
    /** A secret chat with a user */
    _: 'chatTypeSecret',
    /** Secret chat identifier */
    secret_chat_id: number,
    /** User identifier of the secret chat peer */
    user_id: number,
  }

  export type chatFolderIcon = {
    /** Represents an icon for a chat folder */
    _: 'chatFolderIcon',
    /**
     * The chosen icon name for short folder representation; one of "All", "Unread",
     * "Unmuted", "Bots", "Channels", "Groups", "Private", "Custom", "Setup", "Cat",
     * "Crown", "Favorite", "Flower", "Game", "Home", "Love", "Mask", "Party", "Sport",
     * "Study", "Trade", "Travel", "Work", "Airplane", "Book", "Light", "Like", "Money",
     * "Note", "Palette"
     */
    name: string,
  }

  export type chatFolderIcon$Input = {
    /** Represents an icon for a chat folder */
    readonly _: 'chatFolderIcon',
    /**
     * The chosen icon name for short folder representation; one of "All", "Unread",
     * "Unmuted", "Bots", "Channels", "Groups", "Private", "Custom", "Setup", "Cat",
     * "Crown", "Favorite", "Flower", "Game", "Home", "Love", "Mask", "Party", "Sport",
     * "Study", "Trade", "Travel", "Work", "Airplane", "Book", "Light", "Like", "Money",
     * "Note", "Palette"
     */
    readonly name?: string,
  }

  export type chatFolder = {
    /** Represents a folder for user chats */
    _: 'chatFolder',
    /** The title of the folder; 1-12 characters without line feeds */
    title: string,
    /**
     * The chosen icon for the chat folder; may be null. If null, use getChatFolderDefaultIconName
     * to get default icon name for the folder
     */
    icon?: chatFolderIcon,
    /** True, if at least one link has been created for the folder */
    is_shareable: boolean,
    /**
     * The chat identifiers of pinned chats in the folder. There can be up to getOption("chat_folder_chosen_chat_count_max")
     * pinned and always included non-secret chats and the same number of secret chats,
     * but the limit can be increased with Telegram Premium
     */
    pinned_chat_ids: Array<number>,
    /**
     * The chat identifiers of always included chats in the folder. There can be up
     * to getOption("chat_folder_chosen_chat_count_max") pinned and always included
     * non-secret chats and the same number of secret chats, but the limit can be increased
     * with Telegram Premium
     */
    included_chat_ids: Array<number>,
    /**
     * The chat identifiers of always excluded chats in the folder. There can be up
     * to getOption("chat_folder_chosen_chat_count_max") always excluded non-secret
     * chats and the same number of secret chats, but the limit can be increased with
     * Telegram Premium
     */
    excluded_chat_ids: Array<number>,
    /** True, if muted chats need to be excluded */
    exclude_muted: boolean,
    /** True, if read chats need to be excluded */
    exclude_read: boolean,
    /** True, if archived chats need to be excluded */
    exclude_archived: boolean,
    /** True, if contacts need to be included */
    include_contacts: boolean,
    /** True, if non-contact users need to be included */
    include_non_contacts: boolean,
    /** True, if bots need to be included */
    include_bots: boolean,
    /** True, if basic groups and supergroups need to be included */
    include_groups: boolean,
    /** True, if channels need to be included */
    include_channels: boolean,
  }

  export type chatFolder$Input = {
    /** Represents a folder for user chats */
    readonly _: 'chatFolder',
    /** The title of the folder; 1-12 characters without line feeds */
    readonly title?: string,
    /**
     * The chosen icon for the chat folder; may be null. If null, use getChatFolderDefaultIconName
     * to get default icon name for the folder
     */
    readonly icon?: chatFolderIcon$Input,
    /** True, if at least one link has been created for the folder */
    readonly is_shareable?: boolean,
    /**
     * The chat identifiers of pinned chats in the folder. There can be up to getOption("chat_folder_chosen_chat_count_max")
     * pinned and always included non-secret chats and the same number of secret chats,
     * but the limit can be increased with Telegram Premium
     */
    readonly pinned_chat_ids?: ReadonlyArray<number>,
    /**
     * The chat identifiers of always included chats in the folder. There can be up
     * to getOption("chat_folder_chosen_chat_count_max") pinned and always included
     * non-secret chats and the same number of secret chats, but the limit can be increased
     * with Telegram Premium
     */
    readonly included_chat_ids?: ReadonlyArray<number>,
    /**
     * The chat identifiers of always excluded chats in the folder. There can be up
     * to getOption("chat_folder_chosen_chat_count_max") always excluded non-secret
     * chats and the same number of secret chats, but the limit can be increased with
     * Telegram Premium
     */
    readonly excluded_chat_ids?: ReadonlyArray<number>,
    /** True, if muted chats need to be excluded */
    readonly exclude_muted?: boolean,
    /** True, if read chats need to be excluded */
    readonly exclude_read?: boolean,
    /** True, if archived chats need to be excluded */
    readonly exclude_archived?: boolean,
    /** True, if contacts need to be included */
    readonly include_contacts?: boolean,
    /** True, if non-contact users need to be included */
    readonly include_non_contacts?: boolean,
    /** True, if bots need to be included */
    readonly include_bots?: boolean,
    /** True, if basic groups and supergroups need to be included */
    readonly include_groups?: boolean,
    /** True, if channels need to be included */
    readonly include_channels?: boolean,
  }

  export type chatFolderInfo = {
    /** Contains basic information about a chat folder */
    _: 'chatFolderInfo',
    /** Unique chat folder identifier */
    id: number,
    /** The title of the folder; 1-12 characters without line feeds */
    title: string,
    /** The chosen or default icon for the chat folder */
    icon: chatFolderIcon,
    /** True, if at least one link has been created for the folder */
    is_shareable: boolean,
    /** True, if the chat folder has invite links created by the current user */
    has_my_invite_links: boolean,
  }

  export type chatFolderInviteLink = {
    /** Contains a chat folder invite link */
    _: 'chatFolderInviteLink',
    /** The chat folder invite link */
    invite_link: string,
    /** Name of the link */
    name: string,
    /** Identifiers of chats, included in the link */
    chat_ids: Array<number>,
  }

  export type chatFolderInviteLinks = {
    /** Represents a list of chat folder invite links */
    _: 'chatFolderInviteLinks',
    /** List of the invite links */
    invite_links: Array<chatFolderInviteLink>,
  }

  export type chatFolderInviteLinkInfo = {
    /** Contains information about an invite link to a chat folder */
    _: 'chatFolderInviteLinkInfo',
    /**
     * Basic information about the chat folder; chat folder identifier will be 0 if
     * the user didn't have the chat folder yet
     */
    chat_folder_info: chatFolderInfo,
    /** Identifiers of the chats from the link, which aren't added to the folder yet */
    missing_chat_ids: Array<number>,
    /** Identifiers of the chats from the link, which are added to the folder already */
    added_chat_ids: Array<number>,
  }

  export type recommendedChatFolder = {
    /** Describes a recommended chat folder */
    _: 'recommendedChatFolder',
    /** The chat folder */
    folder: chatFolder,
    /** Chat folder description */
    description: string,
  }

  export type recommendedChatFolders = {
    /** Contains a list of recommended chat folders */
    _: 'recommendedChatFolders',
    /** List of recommended chat folders */
    chat_folders: Array<recommendedChatFolder>,
  }

  export type archiveChatListSettings = {
    /**
     * Contains settings for automatic moving of chats to and from the Archive chat
     * lists
     */
    _: 'archiveChatListSettings',
    /**
     * True, if new chats from non-contacts will be automatically archived and muted.
     * Can be set to true only if the option "can_archive_and_mute_new_chats_from_unknown_users"
     * is true
     */
    archive_and_mute_new_chats_from_unknown_users: boolean,
    /**
     * True, if unmuted chats will be kept in the Archive chat list when they get a
     * new message
     */
    keep_unmuted_chats_archived: boolean,
    /**
     * True, if unmuted chats, that are always included or pinned in a folder, will
     * be kept in the Archive chat list when they get a new message. Ignored if keep_unmuted_chats_archived
     * == true
     */
    keep_chats_from_folders_archived: boolean,
  }

  export type archiveChatListSettings$Input = {
    /**
     * Contains settings for automatic moving of chats to and from the Archive chat
     * lists
     */
    readonly _: 'archiveChatListSettings',
    /**
     * True, if new chats from non-contacts will be automatically archived and muted.
     * Can be set to true only if the option "can_archive_and_mute_new_chats_from_unknown_users"
     * is true
     */
    readonly archive_and_mute_new_chats_from_unknown_users?: boolean,
    /**
     * True, if unmuted chats will be kept in the Archive chat list when they get a
     * new message
     */
    readonly keep_unmuted_chats_archived?: boolean,
    /**
     * True, if unmuted chats, that are always included or pinned in a folder, will
     * be kept in the Archive chat list when they get a new message. Ignored if keep_unmuted_chats_archived
     * == true
     */
    readonly keep_chats_from_folders_archived?: boolean,
  }

  export type chatListMain = {
    /** A main list of chats */
    _: 'chatListMain',
  }

  export type chatListMain$Input = {
    /** A main list of chats */
    readonly _: 'chatListMain',
  }

  export type chatListArchive = {
    /**
     * A list of chats usually located at the top of the main chat list. Unmuted chats
     * are automatically moved from the Archive to the Main chat list when a new message
     * arrives
     */
    _: 'chatListArchive',
  }

  export type chatListArchive$Input = {
    /**
     * A list of chats usually located at the top of the main chat list. Unmuted chats
     * are automatically moved from the Archive to the Main chat list when a new message
     * arrives
     */
    readonly _: 'chatListArchive',
  }

  export type chatListFolder = {
    /** A list of chats added to a chat folder */
    _: 'chatListFolder',
    /** Chat folder identifier */
    chat_folder_id: number,
  }

  export type chatListFolder$Input = {
    /** A list of chats added to a chat folder */
    readonly _: 'chatListFolder',
    /** Chat folder identifier */
    readonly chat_folder_id?: number,
  }

  export type chatLists = {
    /** Contains a list of chat lists */
    _: 'chatLists',
    /** List of chat lists */
    chat_lists: Array<ChatList>,
  }

  export type chatSourceMtprotoProxy = {
    /** The chat is sponsored by the user's MTProxy server */
    _: 'chatSourceMtprotoProxy',
  }

  export type chatSourcePublicServiceAnnouncement = {
    /** The chat contains a public service announcement */
    _: 'chatSourcePublicServiceAnnouncement',
    /** The type of the announcement */
    type: string,
    /** The text of the announcement */
    text: string,
  }

  export type chatPosition = {
    /** Describes a position of a chat in a chat list */
    _: 'chatPosition',
    /** The chat list */
    list: ChatList,
    /**
     * A parameter used to determine order of the chat in the chat list. Chats must
     * be sorted by the pair (order, chat.id) in descending order
     */
    order: number | string,
    /** True, if the chat is pinned in the chat list */
    is_pinned: boolean,
    /** Source of the chat in the chat list; may be null */
    source?: ChatSource,
  }

  export type chatAvailableReactionsAll = {
    /** All reactions are available in the chat */
    _: 'chatAvailableReactionsAll',
  }

  export type chatAvailableReactionsAll$Input = {
    /** All reactions are available in the chat */
    readonly _: 'chatAvailableReactionsAll',
  }

  export type chatAvailableReactionsSome = {
    /** Only specific reactions are available in the chat */
    _: 'chatAvailableReactionsSome',
    /** The list of reactions */
    reactions: Array<ReactionType>,
  }

  export type chatAvailableReactionsSome$Input = {
    /** Only specific reactions are available in the chat */
    readonly _: 'chatAvailableReactionsSome',
    /** The list of reactions */
    readonly reactions?: ReadonlyArray<ReactionType$Input>,
  }

  export type videoChat = {
    /** Describes a video chat */
    _: 'videoChat',
    /**
     * Group call identifier of an active video chat; 0 if none. Full information about
     * the video chat can be received through the method getGroupCall
     */
    group_call_id: number,
    /** True, if the video chat has participants */
    has_participants: boolean,
    /** Default group call participant identifier to join the video chat; may be null */
    default_participant_id?: MessageSender,
  }

  export type chat = {
    /** A chat. (Can be a private chat, basic group, supergroup, or secret chat) */
    _: 'chat',
    /** Chat unique identifier */
    id: number,
    /** Type of the chat */
    type: ChatType,
    /** Chat title */
    title: string,
    /** Chat photo; may be null */
    photo?: chatPhotoInfo,
    /** Actions that non-administrator chat members are allowed to take in the chat */
    permissions: chatPermissions,
    /** Last message in the chat; may be null if none or unknown */
    last_message?: message,
    /** Positions of the chat in chat lists */
    positions: Array<chatPosition>,
    /**
     * Identifier of a user or chat that is selected to send messages in the chat;
     * may be null if the user can't change message sender
     */
    message_sender_id?: MessageSender,
    /** Block list to which the chat is added; may be null if none */
    block_list?: BlockList,
    /** True, if chat content can't be saved locally, forwarded, or copied */
    has_protected_content: boolean,
    /** True, if translation of all messages in the chat must be suggested to the user */
    is_translatable: boolean,
    /** True, if the chat is marked as unread */
    is_marked_as_unread: boolean,
    /** True, if the chat has scheduled messages */
    has_scheduled_messages: boolean,
    /**
     * True, if the chat messages can be deleted only for the current user while other
     * users will continue to see the messages
     */
    can_be_deleted_only_for_self: boolean,
    /** True, if the chat messages can be deleted for all users */
    can_be_deleted_for_all_users: boolean,
    /**
     * True, if the chat can be reported to Telegram moderators through reportChat
     * or reportChatPhoto
     */
    can_be_reported: boolean,
    /**
     * Default value of the disable_notification parameter, used when a message is
     * sent to the chat
     */
    default_disable_notification: boolean,
    /** Number of unread messages in the chat */
    unread_count: number,
    /** Identifier of the last read incoming message */
    last_read_inbox_message_id: number,
    /** Identifier of the last read outgoing message */
    last_read_outbox_message_id: number,
    /** Number of unread messages with a mention/reply in the chat */
    unread_mention_count: number,
    /** Number of messages with unread reactions in the chat */
    unread_reaction_count: number,
    /** Notification settings for the chat */
    notification_settings: chatNotificationSettings,
    /** Types of reaction, available in the chat */
    available_reactions: ChatAvailableReactions,
    /**
     * Current message auto-delete or self-destruct timer setting for the chat, in
     * seconds; 0 if disabled. Self-destruct timer in secret chats starts after the
     * message or its content is viewed. Auto-delete timer in other chats starts from
     * the send date
     */
    message_auto_delete_time: number,
    /** Background set for the chat; may be null if none */
    background?: chatBackground,
    /** If non-empty, name of a theme, set for the chat */
    theme_name: string,
    /**
     * Information about actions which must be possible to do through the chat action
     * bar; may be null if none
     */
    action_bar?: ChatActionBar,
    /** Information about video chat of the chat */
    video_chat: videoChat,
    /** Information about pending join requests; may be null if none */
    pending_join_requests?: chatJoinRequestsInfo,
    /**
     * Identifier of the message from which reply markup needs to be used; 0 if there
     * is no default custom reply markup in the chat
     */
    reply_markup_message_id: number,
    /** A draft of a message in the chat; may be null if none */
    draft_message?: draftMessage,
    /**
     * Application-specific data associated with the chat. (For example, the chat scroll
     * position or local chat notification settings can be stored here.) Persistent
     * if the message database is used
     */
    client_data: string,
  }

  export type chats = {
    /** Represents a list of chats */
    _: 'chats',
    /** Approximate total number of chats found */
    total_count: number,
    /** List of chat identifiers */
    chat_ids: Array<number>,
  }

  export type chatNearby = {
    /** Describes a chat located nearby */
    _: 'chatNearby',
    /** Chat identifier */
    chat_id: number,
    /** Distance to the chat location, in meters */
    distance: number,
  }

  export type chatsNearby = {
    /** Represents a list of chats located nearby */
    _: 'chatsNearby',
    /** List of users nearby */
    users_nearby: Array<chatNearby>,
    /** List of location-based supergroups nearby */
    supergroups_nearby: Array<chatNearby>,
  }

  export type publicChatTypeHasUsername$Input = {
    /** The chat is public, because it has an active username */
    readonly _: 'publicChatTypeHasUsername',
  }

  export type publicChatTypeIsLocationBased$Input = {
    /** The chat is public, because it is a location-based supergroup */
    readonly _: 'publicChatTypeIsLocationBased',
  }

  export type chatActionBarReportSpam = {
    /**
     * The chat can be reported as spam using the method reportChat with the reason
     * reportReasonSpam. If the chat is a private chat with a user with an emoji status,
     * then a notice about emoji status usage must be shown
     */
    _: 'chatActionBarReportSpam',
    /**
     * If true, the chat was automatically archived and can be moved back to the main
     * chat list using addChatToList simultaneously with setting chat notification
     * settings to default using setChatNotificationSettings
     */
    can_unarchive: boolean,
  }

  export type chatActionBarReportUnrelatedLocation = {
    /**
     * The chat is a location-based supergroup, which can be reported as having unrelated
     * location using the method reportChat with the reason reportReasonUnrelatedLocation
     */
    _: 'chatActionBarReportUnrelatedLocation',
  }

  export type chatActionBarInviteMembers = {
    /** The chat is a recently created group chat to which new members can be invited */
    _: 'chatActionBarInviteMembers',
  }

  export type chatActionBarReportAddBlock = {
    /**
     * The chat is a private or secret chat, which can be reported using the method
     * reportChat, or the other user can be blocked using the method setMessageSenderBlockList,
     * or the other user can be added to the contact list using the method addContact.
     * If the chat is a private chat with a user with an emoji status, then a notice
     * about emoji status usage must be shown
     */
    _: 'chatActionBarReportAddBlock',
    /**
     * If true, the chat was automatically archived and can be moved back to the main
     * chat list using addChatToList simultaneously with setting chat notification
     * settings to default using setChatNotificationSettings
     */
    can_unarchive: boolean,
    /**
     * If non-negative, the current user was found by the peer through searchChatsNearby
     * and this is the distance between the users
     */
    distance: number,
  }

  export type chatActionBarAddContact = {
    /**
     * The chat is a private or secret chat and the other user can be added to the
     * contact list using the method addContact
     */
    _: 'chatActionBarAddContact',
  }

  export type chatActionBarSharePhoneNumber = {
    /**
     * The chat is a private or secret chat with a mutual contact and the user's phone
     * number can be shared with the other user using the method sharePhoneNumber
     */
    _: 'chatActionBarSharePhoneNumber',
  }

  export type chatActionBarJoinRequest = {
    /**
     * The chat is a private chat with an administrator of a chat to which the user
     * sent join request
     */
    _: 'chatActionBarJoinRequest',
    /** Title of the chat to which the join request was sent */
    title: string,
    /** True, if the join request was sent to a channel chat */
    is_channel: boolean,
    /** Point in time (Unix timestamp) when the join request was sent */
    request_date: number,
  }

  export type keyboardButtonTypeText = {
    /** A simple button, with text that must be sent when the button is pressed */
    _: 'keyboardButtonTypeText',
  }

  export type keyboardButtonTypeText$Input = {
    /** A simple button, with text that must be sent when the button is pressed */
    readonly _: 'keyboardButtonTypeText',
  }

  export type keyboardButtonTypeRequestPhoneNumber = {
    /**
     * A button that sends the user's phone number when pressed; available only in
     * private chats
     */
    _: 'keyboardButtonTypeRequestPhoneNumber',
  }

  export type keyboardButtonTypeRequestPhoneNumber$Input = {
    /**
     * A button that sends the user's phone number when pressed; available only in
     * private chats
     */
    readonly _: 'keyboardButtonTypeRequestPhoneNumber',
  }

  export type keyboardButtonTypeRequestLocation = {
    /**
     * A button that sends the user's location when pressed; available only in private
     * chats
     */
    _: 'keyboardButtonTypeRequestLocation',
  }

  export type keyboardButtonTypeRequestLocation$Input = {
    /**
     * A button that sends the user's location when pressed; available only in private
     * chats
     */
    readonly _: 'keyboardButtonTypeRequestLocation',
  }

  export type keyboardButtonTypeRequestPoll = {
    /**
     * A button that allows the user to create and send a poll when pressed; available
     * only in private chats
     */
    _: 'keyboardButtonTypeRequestPoll',
    /** If true, only regular polls must be allowed to create */
    force_regular: boolean,
    /** If true, only polls in quiz mode must be allowed to create */
    force_quiz: boolean,
  }

  export type keyboardButtonTypeRequestPoll$Input = {
    /**
     * A button that allows the user to create and send a poll when pressed; available
     * only in private chats
     */
    readonly _: 'keyboardButtonTypeRequestPoll',
    /** If true, only regular polls must be allowed to create */
    readonly force_regular?: boolean,
    /** If true, only polls in quiz mode must be allowed to create */
    readonly force_quiz?: boolean,
  }

  export type keyboardButtonTypeRequestUser = {
    /**
     * A button that requests a user to be shared by the current user; available only
     * in private chats. Use the method shareUserWithBot to complete the request
     */
    _: 'keyboardButtonTypeRequestUser',
    /** Unique button identifier */
    id: number,
    /** True, if the shared user must or must not be a bot */
    restrict_user_is_bot: boolean,
    /**
     * True, if the shared user must be a bot; otherwise, the shared user must no be
     * a bot. Ignored if restrict_user_is_bot is false
     */
    user_is_bot: boolean,
    /** True, if the shared user must or must not be a Telegram Premium user */
    restrict_user_is_premium: boolean,
    /**
     * True, if the shared user must be a Telegram Premium user; otherwise, the shared
     * user must no be a Telegram Premium user. Ignored if restrict_user_is_premium
     * is false
     */
    user_is_premium: boolean,
  }

  export type keyboardButtonTypeRequestUser$Input = {
    /**
     * A button that requests a user to be shared by the current user; available only
     * in private chats. Use the method shareUserWithBot to complete the request
     */
    readonly _: 'keyboardButtonTypeRequestUser',
    /** Unique button identifier */
    readonly id?: number,
    /** True, if the shared user must or must not be a bot */
    readonly restrict_user_is_bot?: boolean,
    /**
     * True, if the shared user must be a bot; otherwise, the shared user must no be
     * a bot. Ignored if restrict_user_is_bot is false
     */
    readonly user_is_bot?: boolean,
    /** True, if the shared user must or must not be a Telegram Premium user */
    readonly restrict_user_is_premium?: boolean,
    /**
     * True, if the shared user must be a Telegram Premium user; otherwise, the shared
     * user must no be a Telegram Premium user. Ignored if restrict_user_is_premium
     * is false
     */
    readonly user_is_premium?: boolean,
  }

  export type keyboardButtonTypeRequestChat = {
    /**
     * A button that requests a chat to be shared by the current user; available only
     * in private chats. Use the method shareChatWithBot to complete the request
     */
    _: 'keyboardButtonTypeRequestChat',
    /** Unique button identifier */
    id: number,
    /**
     * True, if the chat must be a channel; otherwise, a basic group or a supergroup
     * chat is shared
     */
    chat_is_channel: boolean,
    /** True, if the chat must or must not be a forum supergroup */
    restrict_chat_is_forum: boolean,
    /**
     * True, if the chat must be a forum supergroup; otherwise, the chat must not be
     * a forum supergroup. Ignored if restrict_chat_is_forum is false
     */
    chat_is_forum: boolean,
    /** True, if the chat must or must not have a username */
    restrict_chat_has_username: boolean,
    /**
     * True, if the chat must have a username; otherwise, the chat must not have a
     * username. Ignored if restrict_chat_has_username is false
     */
    chat_has_username: boolean,
    /** True, if the chat must be created by the current user */
    chat_is_created: boolean,
    /** Expected user administrator rights in the chat; may be null if they aren't restricted */
    user_administrator_rights?: chatAdministratorRights,
    /** Expected bot administrator rights in the chat; may be null if they aren't restricted */
    bot_administrator_rights?: chatAdministratorRights,
    /**
     * True, if the bot must be a member of the chat; for basic group and supergroup
     * chats only
     */
    bot_is_member: boolean,
  }

  export type keyboardButtonTypeRequestChat$Input = {
    /**
     * A button that requests a chat to be shared by the current user; available only
     * in private chats. Use the method shareChatWithBot to complete the request
     */
    readonly _: 'keyboardButtonTypeRequestChat',
    /** Unique button identifier */
    readonly id?: number,
    /**
     * True, if the chat must be a channel; otherwise, a basic group or a supergroup
     * chat is shared
     */
    readonly chat_is_channel?: boolean,
    /** True, if the chat must or must not be a forum supergroup */
    readonly restrict_chat_is_forum?: boolean,
    /**
     * True, if the chat must be a forum supergroup; otherwise, the chat must not be
     * a forum supergroup. Ignored if restrict_chat_is_forum is false
     */
    readonly chat_is_forum?: boolean,
    /** True, if the chat must or must not have a username */
    readonly restrict_chat_has_username?: boolean,
    /**
     * True, if the chat must have a username; otherwise, the chat must not have a
     * username. Ignored if restrict_chat_has_username is false
     */
    readonly chat_has_username?: boolean,
    /** True, if the chat must be created by the current user */
    readonly chat_is_created?: boolean,
    /** Expected user administrator rights in the chat; may be null if they aren't restricted */
    readonly user_administrator_rights?: chatAdministratorRights$Input,
    /** Expected bot administrator rights in the chat; may be null if they aren't restricted */
    readonly bot_administrator_rights?: chatAdministratorRights$Input,
    /**
     * True, if the bot must be a member of the chat; for basic group and supergroup
     * chats only
     */
    readonly bot_is_member?: boolean,
  }

  export type keyboardButtonTypeWebApp = {
    /** A button that opens a Web App by calling getWebAppUrl */
    _: 'keyboardButtonTypeWebApp',
    /** An HTTP URL to pass to getWebAppUrl */
    url: string,
  }

  export type keyboardButtonTypeWebApp$Input = {
    /** A button that opens a Web App by calling getWebAppUrl */
    readonly _: 'keyboardButtonTypeWebApp',
    /** An HTTP URL to pass to getWebAppUrl */
    readonly url?: string,
  }

  export type keyboardButton = {
    /** Represents a single button in a bot keyboard */
    _: 'keyboardButton',
    /** Text of the button */
    text: string,
    /** Type of the button */
    type: KeyboardButtonType,
  }

  export type keyboardButton$Input = {
    /** Represents a single button in a bot keyboard */
    readonly _: 'keyboardButton',
    /** Text of the button */
    readonly text?: string,
    /** Type of the button */
    readonly type?: KeyboardButtonType$Input,
  }

  export type inlineKeyboardButtonTypeUrl = {
    /** A button that opens a specified URL */
    _: 'inlineKeyboardButtonTypeUrl',
    /** HTTP or tg:// URL to open */
    url: string,
  }

  export type inlineKeyboardButtonTypeUrl$Input = {
    /** A button that opens a specified URL */
    readonly _: 'inlineKeyboardButtonTypeUrl',
    /** HTTP or tg:// URL to open */
    readonly url?: string,
  }

  export type inlineKeyboardButtonTypeLoginUrl = {
    /**
     * A button that opens a specified URL and automatically authorize the current
     * user by calling getLoginUrlInfo
     */
    _: 'inlineKeyboardButtonTypeLoginUrl',
    /** An HTTP URL to pass to getLoginUrlInfo */
    url: string,
    /** Unique button identifier */
    id: number,
    /** If non-empty, new text of the button in forwarded messages */
    forward_text: string,
  }

  export type inlineKeyboardButtonTypeLoginUrl$Input = {
    /**
     * A button that opens a specified URL and automatically authorize the current
     * user by calling getLoginUrlInfo
     */
    readonly _: 'inlineKeyboardButtonTypeLoginUrl',
    /** An HTTP URL to pass to getLoginUrlInfo */
    readonly url?: string,
    /** Unique button identifier */
    readonly id?: number,
    /** If non-empty, new text of the button in forwarded messages */
    readonly forward_text?: string,
  }

  export type inlineKeyboardButtonTypeWebApp = {
    /** A button that opens a Web App by calling openWebApp */
    _: 'inlineKeyboardButtonTypeWebApp',
    /** An HTTP URL to pass to openWebApp */
    url: string,
  }

  export type inlineKeyboardButtonTypeWebApp$Input = {
    /** A button that opens a Web App by calling openWebApp */
    readonly _: 'inlineKeyboardButtonTypeWebApp',
    /** An HTTP URL to pass to openWebApp */
    readonly url?: string,
  }

  export type inlineKeyboardButtonTypeCallback = {
    /** A button that sends a callback query to a bot */
    _: 'inlineKeyboardButtonTypeCallback',
    /** Data to be sent to the bot via a callback query */
    data: string,
  }

  export type inlineKeyboardButtonTypeCallback$Input = {
    /** A button that sends a callback query to a bot */
    readonly _: 'inlineKeyboardButtonTypeCallback',
    /** Data to be sent to the bot via a callback query */
    readonly data?: string,
  }

  export type inlineKeyboardButtonTypeCallbackWithPassword = {
    /**
     * A button that asks for the 2-step verification password of the current user
     * and then sends a callback query to a bot
     */
    _: 'inlineKeyboardButtonTypeCallbackWithPassword',
    /** Data to be sent to the bot via a callback query */
    data: string,
  }

  export type inlineKeyboardButtonTypeCallbackWithPassword$Input = {
    /**
     * A button that asks for the 2-step verification password of the current user
     * and then sends a callback query to a bot
     */
    readonly _: 'inlineKeyboardButtonTypeCallbackWithPassword',
    /** Data to be sent to the bot via a callback query */
    readonly data?: string,
  }

  export type inlineKeyboardButtonTypeCallbackGame = {
    /**
     * A button with a game that sends a callback query to a bot. This button must
     * be in the first column and row of the keyboard and can be attached only to a
     * message with content of the type messageGame
     */
    _: 'inlineKeyboardButtonTypeCallbackGame',
  }

  export type inlineKeyboardButtonTypeCallbackGame$Input = {
    /**
     * A button with a game that sends a callback query to a bot. This button must
     * be in the first column and row of the keyboard and can be attached only to a
     * message with content of the type messageGame
     */
    readonly _: 'inlineKeyboardButtonTypeCallbackGame',
  }

  export type inlineKeyboardButtonTypeSwitchInline = {
    /**
     * A button that forces an inline query to the bot to be inserted in the input
     * field
     */
    _: 'inlineKeyboardButtonTypeSwitchInline',
    /** Inline query to be sent to the bot */
    query: string,
    /** Target chat from which to send the inline query */
    target_chat: TargetChat,
  }

  export type inlineKeyboardButtonTypeSwitchInline$Input = {
    /**
     * A button that forces an inline query to the bot to be inserted in the input
     * field
     */
    readonly _: 'inlineKeyboardButtonTypeSwitchInline',
    /** Inline query to be sent to the bot */
    readonly query?: string,
    /** Target chat from which to send the inline query */
    readonly target_chat?: TargetChat$Input,
  }

  export type inlineKeyboardButtonTypeBuy = {
    /**
     * A button to buy something. This button must be in the first column and row of
     * the keyboard and can be attached only to a message with content of the type
     * messageInvoice
     */
    _: 'inlineKeyboardButtonTypeBuy',
  }

  export type inlineKeyboardButtonTypeBuy$Input = {
    /**
     * A button to buy something. This button must be in the first column and row of
     * the keyboard and can be attached only to a message with content of the type
     * messageInvoice
     */
    readonly _: 'inlineKeyboardButtonTypeBuy',
  }

  export type inlineKeyboardButtonTypeUser = {
    /**
     * A button with a user reference to be handled in the same way as textEntityTypeMentionName
     * entities
     */
    _: 'inlineKeyboardButtonTypeUser',
    /** User identifier */
    user_id: number,
  }

  export type inlineKeyboardButtonTypeUser$Input = {
    /**
     * A button with a user reference to be handled in the same way as textEntityTypeMentionName
     * entities
     */
    readonly _: 'inlineKeyboardButtonTypeUser',
    /** User identifier */
    readonly user_id?: number,
  }

  export type inlineKeyboardButton = {
    /** Represents a single button in an inline keyboard */
    _: 'inlineKeyboardButton',
    /** Text of the button */
    text: string,
    /** Type of the button */
    type: InlineKeyboardButtonType,
  }

  export type inlineKeyboardButton$Input = {
    /** Represents a single button in an inline keyboard */
    readonly _: 'inlineKeyboardButton',
    /** Text of the button */
    readonly text?: string,
    /** Type of the button */
    readonly type?: InlineKeyboardButtonType$Input,
  }

  export type replyMarkupRemoveKeyboard = {
    /**
     * Instructs application to remove the keyboard once this message has been received.
     * This kind of keyboard can't be received in an incoming message; instead, updateChatReplyMarkup
     * with message_id == 0 will be sent
     */
    _: 'replyMarkupRemoveKeyboard',
    /**
     * True, if the keyboard is removed only for the mentioned users or the target
     * user of a reply
     */
    is_personal: boolean,
  }

  export type replyMarkupRemoveKeyboard$Input = {
    /**
     * Instructs application to remove the keyboard once this message has been received.
     * This kind of keyboard can't be received in an incoming message; instead, updateChatReplyMarkup
     * with message_id == 0 will be sent
     */
    readonly _: 'replyMarkupRemoveKeyboard',
    /**
     * True, if the keyboard is removed only for the mentioned users or the target
     * user of a reply
     */
    readonly is_personal?: boolean,
  }

  export type replyMarkupForceReply = {
    /** Instructs application to force a reply to this message */
    _: 'replyMarkupForceReply',
    /**
     * True, if a forced reply must automatically be shown to the current user. For
     * outgoing messages, specify true to show the forced reply only for the mentioned
     * users and for the target user of a reply
     */
    is_personal: boolean,
    /**
     * If non-empty, the placeholder to be shown in the input field when the reply
     * is active; 0-64 characters
     */
    input_field_placeholder: string,
  }

  export type replyMarkupForceReply$Input = {
    /** Instructs application to force a reply to this message */
    readonly _: 'replyMarkupForceReply',
    /**
     * True, if a forced reply must automatically be shown to the current user. For
     * outgoing messages, specify true to show the forced reply only for the mentioned
     * users and for the target user of a reply
     */
    readonly is_personal?: boolean,
    /**
     * If non-empty, the placeholder to be shown in the input field when the reply
     * is active; 0-64 characters
     */
    readonly input_field_placeholder?: string,
  }

  export type replyMarkupShowKeyboard = {
    /** Contains a custom keyboard layout to quickly reply to bots */
    _: 'replyMarkupShowKeyboard',
    /** A list of rows of bot keyboard buttons */
    rows: Array<Array<keyboardButton>>,
    /**
     * True, if the keyboard is supposed to always be shown when the ordinary keyboard
     * is hidden
     */
    is_persistent: boolean,
    /** True, if the application needs to resize the keyboard vertically */
    resize_keyboard: boolean,
    /** True, if the application needs to hide the keyboard after use */
    one_time: boolean,
    /**
     * True, if the keyboard must automatically be shown to the current user. For outgoing
     * messages, specify true to show the keyboard only for the mentioned users and
     * for the target user of a reply
     */
    is_personal: boolean,
    /**
     * If non-empty, the placeholder to be shown in the input field when the keyboard
     * is active; 0-64 characters
     */
    input_field_placeholder: string,
  }

  export type replyMarkupShowKeyboard$Input = {
    /** Contains a custom keyboard layout to quickly reply to bots */
    readonly _: 'replyMarkupShowKeyboard',
    /** A list of rows of bot keyboard buttons */
    readonly rows?: ReadonlyArray<ReadonlyArray<keyboardButton$Input>>,
    /**
     * True, if the keyboard is supposed to always be shown when the ordinary keyboard
     * is hidden
     */
    readonly is_persistent?: boolean,
    /** True, if the application needs to resize the keyboard vertically */
    readonly resize_keyboard?: boolean,
    /** True, if the application needs to hide the keyboard after use */
    readonly one_time?: boolean,
    /**
     * True, if the keyboard must automatically be shown to the current user. For outgoing
     * messages, specify true to show the keyboard only for the mentioned users and
     * for the target user of a reply
     */
    readonly is_personal?: boolean,
    /**
     * If non-empty, the placeholder to be shown in the input field when the keyboard
     * is active; 0-64 characters
     */
    readonly input_field_placeholder?: string,
  }

  export type replyMarkupInlineKeyboard = {
    /** Contains an inline keyboard layout */
    _: 'replyMarkupInlineKeyboard',
    /** A list of rows of inline keyboard buttons */
    rows: Array<Array<inlineKeyboardButton>>,
  }

  export type replyMarkupInlineKeyboard$Input = {
    /** Contains an inline keyboard layout */
    readonly _: 'replyMarkupInlineKeyboard',
    /** A list of rows of inline keyboard buttons */
    readonly rows?: ReadonlyArray<ReadonlyArray<inlineKeyboardButton$Input>>,
  }

  export type loginUrlInfoOpen = {
    /** An HTTP URL needs to be open */
    _: 'loginUrlInfoOpen',
    /** The URL to open */
    url: string,
    /** True, if there is no need to show an ordinary open URL confirmation */
    skip_confirmation: boolean,
  }

  export type loginUrlInfoRequestConfirmation = {
    /** An authorization confirmation dialog needs to be shown to the user */
    _: 'loginUrlInfoRequestConfirmation',
    /** An HTTP URL to be opened */
    url: string,
    /** A domain of the URL */
    domain: string,
    /** User identifier of a bot linked with the website */
    bot_user_id: number,
    /** True, if the user must be asked for the permission to the bot to send them messages */
    request_write_access: boolean,
  }

  export type foundWebApp = {
    /** Contains information about a Web App found by its short name */
    _: 'foundWebApp',
    /** The Web App */
    web_app: webApp,
    /** True, if the app supports "settings_button_pressed" event */
    supports_settings: boolean,
    /** True, if the user must be asked for the permission to the bot to send them messages */
    request_write_access: boolean,
    /**
     * True, if there is no need to show an ordinary open URL confirmation before opening
     * the Web App. The field must be ignored and confirmation must be shown anyway
     * if the Web App link was hidden
     */
    skip_confirmation: boolean,
  }

  export type webAppInfo = {
    /** Contains information about a Web App */
    _: 'webAppInfo',
    /** Unique identifier for the Web App launch */
    launch_id: number | string,
    /** A Web App URL to open in a web view */
    url: string,
  }

  export type messageThreadInfo = {
    /** Contains information about a message thread */
    _: 'messageThreadInfo',
    /** Identifier of the chat to which the message thread belongs */
    chat_id: number,
    /** Message thread identifier, unique within the chat */
    message_thread_id: number,
    /** Information about the message thread; may be null for forum topic threads */
    reply_info?: messageReplyInfo,
    /** Approximate number of unread messages in the message thread */
    unread_message_count: number,
    /**
     * The messages from which the thread starts. The messages are returned in a reverse
     * chronological order (i.e., in order of decreasing message_id)
     */
    messages: Array<message>,
    /** A draft of a message in the message thread; may be null if none */
    draft_message?: draftMessage,
  }

  export type forumTopicIcon = {
    /** Describes a forum topic icon */
    _: 'forumTopicIcon',
    /** Color of the topic icon in RGB format */
    color: number,
    /** Unique identifier of the custom emoji shown on the topic icon; 0 if none */
    custom_emoji_id: number | string,
  }

  export type forumTopicIcon$Input = {
    /** Describes a forum topic icon */
    readonly _: 'forumTopicIcon',
    /** Color of the topic icon in RGB format */
    readonly color?: number,
    /** Unique identifier of the custom emoji shown on the topic icon; 0 if none */
    readonly custom_emoji_id?: number | string,
  }

  export type forumTopicInfo = {
    /** Contains basic information about a forum topic */
    _: 'forumTopicInfo',
    /** Message thread identifier of the topic */
    message_thread_id: number,
    /** Name of the topic */
    name: string,
    /** Icon of the topic */
    icon: forumTopicIcon,
    /** Point in time (Unix timestamp) when the topic was created */
    creation_date: number,
    /** Identifier of the creator of the topic */
    creator_id: MessageSender,
    /** True, if the topic is the General topic list */
    is_general: boolean,
    /** True, if the topic was created by the current user */
    is_outgoing: boolean,
    /** True, if the topic is closed */
    is_closed: boolean,
    /**
     * True, if the topic is hidden above the topic list and closed; for General topic
     * only
     */
    is_hidden: boolean,
  }

  export type forumTopic = {
    /** Describes a forum topic */
    _: 'forumTopic',
    /** Basic information about the topic */
    info: forumTopicInfo,
    /** Last message in the topic; may be null if unknown */
    last_message?: message,
    /** True, if the topic is pinned in the topic list */
    is_pinned: boolean,
    /** Number of unread messages in the topic */
    unread_count: number,
    /** Identifier of the last read incoming message */
    last_read_inbox_message_id: number,
    /** Identifier of the last read outgoing message */
    last_read_outbox_message_id: number,
    /** Number of unread messages with a mention/reply in the topic */
    unread_mention_count: number,
    /** Number of messages with unread reactions in the topic */
    unread_reaction_count: number,
    /** Notification settings for the topic */
    notification_settings: chatNotificationSettings,
    /** A draft of a message in the topic; may be null if none */
    draft_message?: draftMessage,
  }

  export type forumTopics = {
    /** Describes a list of forum topics */
    _: 'forumTopics',
    /** Approximate total number of forum topics found */
    total_count: number,
    /** List of forum topics */
    topics: Array<forumTopic>,
    /** Offset date for the next getForumTopics request */
    next_offset_date: number,
    /** Offset message identifier for the next getForumTopics request */
    next_offset_message_id: number,
    /** Offset message thread identifier for the next getForumTopics request */
    next_offset_message_thread_id: number,
  }

  export type richTextPlain = {
    /** A plain text */
    _: 'richTextPlain',
    /** Text */
    text: string,
  }

  export type richTextBold = {
    /** A bold rich text */
    _: 'richTextBold',
    /** Text */
    text: RichText,
  }

  export type richTextItalic = {
    /** An italicized rich text */
    _: 'richTextItalic',
    /** Text */
    text: RichText,
  }

  export type richTextUnderline = {
    /** An underlined rich text */
    _: 'richTextUnderline',
    /** Text */
    text: RichText,
  }

  export type richTextStrikethrough = {
    /** A strikethrough rich text */
    _: 'richTextStrikethrough',
    /** Text */
    text: RichText,
  }

  export type richTextFixed = {
    /** A fixed-width rich text */
    _: 'richTextFixed',
    /** Text */
    text: RichText,
  }

  export type richTextUrl = {
    /** A rich text URL link */
    _: 'richTextUrl',
    /** Text */
    text: RichText,
    /** URL */
    url: string,
    /** True, if the URL has cached instant view server-side */
    is_cached: boolean,
  }

  export type richTextEmailAddress = {
    /** A rich text email link */
    _: 'richTextEmailAddress',
    /** Text */
    text: RichText,
    /** Email address */
    email_address: string,
  }

  export type richTextSubscript = {
    /** A subscript rich text */
    _: 'richTextSubscript',
    /** Text */
    text: RichText,
  }

  export type richTextSuperscript = {
    /** A superscript rich text */
    _: 'richTextSuperscript',
    /** Text */
    text: RichText,
  }

  export type richTextMarked = {
    /** A marked rich text */
    _: 'richTextMarked',
    /** Text */
    text: RichText,
  }

  export type richTextPhoneNumber = {
    /** A rich text phone number */
    _: 'richTextPhoneNumber',
    /** Text */
    text: RichText,
    /** Phone number */
    phone_number: string,
  }

  export type richTextIcon = {
    /** A small image inside the text */
    _: 'richTextIcon',
    /** The image represented as a document. The image can be in GIF, JPEG or PNG format */
    document: document,
    /** Width of a bounding box in which the image must be shown; 0 if unknown */
    width: number,
    /** Height of a bounding box in which the image must be shown; 0 if unknown */
    height: number,
  }

  export type richTextReference = {
    /** A reference to a richTexts object on the same web page */
    _: 'richTextReference',
    /** The text */
    text: RichText,
    /**
     * The name of a richTextAnchor object, which is the first element of the target
     * richTexts object
     */
    anchor_name: string,
    /** An HTTP URL, opening the reference */
    url: string,
  }

  export type richTextAnchor = {
    /** An anchor */
    _: 'richTextAnchor',
    /** Anchor name */
    name: string,
  }

  export type richTextAnchorLink = {
    /** A link to an anchor on the same web page */
    _: 'richTextAnchorLink',
    /** The link text */
    text: RichText,
    /** The anchor name. If the name is empty, the link must bring back to top */
    anchor_name: string,
    /** An HTTP URL, opening the anchor */
    url: string,
  }

  export type richTexts = {
    /** A concatenation of rich texts */
    _: 'richTexts',
    /** Texts */
    texts: Array<RichText>,
  }

  export type pageBlockCaption = {
    /**
     * Contains a caption of an instant view web page block, consisting of a text and
     * a trailing credit
     */
    _: 'pageBlockCaption',
    /** Content of the caption */
    text: RichText,
    /** Block credit (like HTML tag <cite>) */
    credit: RichText,
  }

  export type pageBlockListItem = {
    /** Describes an item of a list page block */
    _: 'pageBlockListItem',
    /** Item label */
    label: string,
    /** Item blocks */
    page_blocks: Array<PageBlock>,
  }

  export type pageBlockHorizontalAlignmentLeft = {
    /** The content must be left-aligned */
    _: 'pageBlockHorizontalAlignmentLeft',
  }

  export type pageBlockHorizontalAlignmentCenter = {
    /** The content must be center-aligned */
    _: 'pageBlockHorizontalAlignmentCenter',
  }

  export type pageBlockHorizontalAlignmentRight = {
    /** The content must be right-aligned */
    _: 'pageBlockHorizontalAlignmentRight',
  }

  export type pageBlockVerticalAlignmentTop = {
    /** The content must be top-aligned */
    _: 'pageBlockVerticalAlignmentTop',
  }

  export type pageBlockVerticalAlignmentMiddle = {
    /** The content must be middle-aligned */
    _: 'pageBlockVerticalAlignmentMiddle',
  }

  export type pageBlockVerticalAlignmentBottom = {
    /** The content must be bottom-aligned */
    _: 'pageBlockVerticalAlignmentBottom',
  }

  export type pageBlockTableCell = {
    /** Represents a cell of a table */
    _: 'pageBlockTableCell',
    /** Cell text; may be null. If the text is null, then the cell must be invisible */
    text?: RichText,
    /** True, if it is a header cell */
    is_header: boolean,
    /** The number of columns the cell spans */
    colspan: number,
    /** The number of rows the cell spans */
    rowspan: number,
    /** Horizontal cell content alignment */
    align: PageBlockHorizontalAlignment,
    /** Vertical cell content alignment */
    valign: PageBlockVerticalAlignment,
  }

  export type pageBlockRelatedArticle = {
    /** Contains information about a related article */
    _: 'pageBlockRelatedArticle',
    /** Related article URL */
    url: string,
    /** Article title; may be empty */
    title: string,
    /** Article description; may be empty */
    description: string,
    /** Article photo; may be null */
    photo?: photo,
    /** Article author; may be empty */
    author: string,
    /** Point in time (Unix timestamp) when the article was published; 0 if unknown */
    publish_date: number,
  }

  export type pageBlockTitle = {
    /** The title of a page */
    _: 'pageBlockTitle',
    /** Title */
    title: RichText,
  }

  export type pageBlockSubtitle = {
    /** The subtitle of a page */
    _: 'pageBlockSubtitle',
    /** Subtitle */
    subtitle: RichText,
  }

  export type pageBlockAuthorDate = {
    /** The author and publishing date of a page */
    _: 'pageBlockAuthorDate',
    /** Author */
    author: RichText,
    /** Point in time (Unix timestamp) when the article was published; 0 if unknown */
    publish_date: number,
  }

  export type pageBlockHeader = {
    /** A header */
    _: 'pageBlockHeader',
    /** Header */
    header: RichText,
  }

  export type pageBlockSubheader = {
    /** A subheader */
    _: 'pageBlockSubheader',
    /** Subheader */
    subheader: RichText,
  }

  export type pageBlockKicker = {
    /** A kicker */
    _: 'pageBlockKicker',
    /** Kicker */
    kicker: RichText,
  }

  export type pageBlockParagraph = {
    /** A text paragraph */
    _: 'pageBlockParagraph',
    /** Paragraph text */
    text: RichText,
  }

  export type pageBlockPreformatted = {
    /** A preformatted text paragraph */
    _: 'pageBlockPreformatted',
    /** Paragraph text */
    text: RichText,
    /** Programming language for which the text needs to be formatted */
    language: string,
  }

  export type pageBlockFooter = {
    /** The footer of a page */
    _: 'pageBlockFooter',
    /** Footer */
    footer: RichText,
  }

  export type pageBlockDivider = {
    /** An empty block separating a page */
    _: 'pageBlockDivider',
  }

  export type pageBlockAnchor = {
    /**
     * An invisible anchor on a page, which can be used in a URL to open the page from
     * the specified anchor
     */
    _: 'pageBlockAnchor',
    /** Name of the anchor */
    name: string,
  }

  export type pageBlockList = {
    /** A list of data blocks */
    _: 'pageBlockList',
    /** The items of the list */
    items: Array<pageBlockListItem>,
  }

  export type pageBlockBlockQuote = {
    /** A block quote */
    _: 'pageBlockBlockQuote',
    /** Quote text */
    text: RichText,
    /** Quote credit */
    credit: RichText,
  }

  export type pageBlockPullQuote = {
    /** A pull quote */
    _: 'pageBlockPullQuote',
    /** Quote text */
    text: RichText,
    /** Quote credit */
    credit: RichText,
  }

  export type pageBlockAnimation = {
    /** An animation */
    _: 'pageBlockAnimation',
    /** Animation file; may be null */
    animation?: animation,
    /** Animation caption */
    caption: pageBlockCaption,
    /** True, if the animation must be played automatically */
    need_autoplay: boolean,
  }

  export type pageBlockAudio = {
    /** An audio file */
    _: 'pageBlockAudio',
    /** Audio file; may be null */
    audio?: audio,
    /** Audio file caption */
    caption: pageBlockCaption,
  }

  export type pageBlockPhoto = {
    /** A photo */
    _: 'pageBlockPhoto',
    /** Photo file; may be null */
    photo?: photo,
    /** Photo caption */
    caption: pageBlockCaption,
    /** URL that needs to be opened when the photo is clicked */
    url: string,
  }

  export type pageBlockVideo = {
    /** A video */
    _: 'pageBlockVideo',
    /** Video file; may be null */
    video?: video,
    /** Video caption */
    caption: pageBlockCaption,
    /** True, if the video must be played automatically */
    need_autoplay: boolean,
    /** True, if the video must be looped */
    is_looped: boolean,
  }

  export type pageBlockVoiceNote = {
    /** A voice note */
    _: 'pageBlockVoiceNote',
    /** Voice note; may be null */
    voice_note?: voiceNote,
    /** Voice note caption */
    caption: pageBlockCaption,
  }

  export type pageBlockCover = {
    /** A page cover */
    _: 'pageBlockCover',
    /** Cover */
    cover: PageBlock,
  }

  export type pageBlockEmbedded = {
    /** An embedded web page */
    _: 'pageBlockEmbedded',
    /** Web page URL, if available */
    url: string,
    /** HTML-markup of the embedded page */
    html: string,
    /** Poster photo, if available; may be null */
    poster_photo?: photo,
    /** Block width; 0 if unknown */
    width: number,
    /** Block height; 0 if unknown */
    height: number,
    /** Block caption */
    caption: pageBlockCaption,
    /** True, if the block must be full width */
    is_full_width: boolean,
    /** True, if scrolling needs to be allowed */
    allow_scrolling: boolean,
  }

  export type pageBlockEmbeddedPost = {
    /** An embedded post */
    _: 'pageBlockEmbeddedPost',
    /** Web page URL */
    url: string,
    /** Post author */
    author: string,
    /** Post author photo; may be null */
    author_photo?: photo,
    /** Point in time (Unix timestamp) when the post was created; 0 if unknown */
    date: number,
    /** Post content */
    page_blocks: Array<PageBlock>,
    /** Post caption */
    caption: pageBlockCaption,
  }

  export type pageBlockCollage = {
    /** A collage */
    _: 'pageBlockCollage',
    /** Collage item contents */
    page_blocks: Array<PageBlock>,
    /** Block caption */
    caption: pageBlockCaption,
  }

  export type pageBlockSlideshow = {
    /** A slideshow */
    _: 'pageBlockSlideshow',
    /** Slideshow item contents */
    page_blocks: Array<PageBlock>,
    /** Block caption */
    caption: pageBlockCaption,
  }

  export type pageBlockChatLink = {
    /** A link to a chat */
    _: 'pageBlockChatLink',
    /** Chat title */
    title: string,
    /** Chat photo; may be null */
    photo?: chatPhotoInfo,
    /** Chat username by which all other information about the chat can be resolved */
    username: string,
  }

  export type pageBlockTable = {
    /** A table */
    _: 'pageBlockTable',
    /** Table caption */
    caption: RichText,
    /** Table cells */
    cells: Array<Array<pageBlockTableCell>>,
    /** True, if the table is bordered */
    is_bordered: boolean,
    /** True, if the table is striped */
    is_striped: boolean,
  }

  export type pageBlockDetails = {
    /** A collapsible block */
    _: 'pageBlockDetails',
    /** Always visible heading for the block */
    header: RichText,
    /** Block contents */
    page_blocks: Array<PageBlock>,
    /** True, if the block is open by default */
    is_open: boolean,
  }

  export type pageBlockRelatedArticles = {
    /** Related articles */
    _: 'pageBlockRelatedArticles',
    /** Block header */
    header: RichText,
    /** List of related articles */
    articles: Array<pageBlockRelatedArticle>,
  }

  export type pageBlockMap = {
    /** A map */
    _: 'pageBlockMap',
    /** Location of the map center */
    location: location,
    /** Map zoom level */
    zoom: number,
    /** Map width */
    width: number,
    /** Map height */
    height: number,
    /** Block caption */
    caption: pageBlockCaption,
  }

  export type webPageInstantView = {
    /** Describes an instant view page for a web page */
    _: 'webPageInstantView',
    /** Content of the web page */
    page_blocks: Array<PageBlock>,
    /** Number of the instant view views; 0 if unknown */
    view_count: number,
    /** Version of the instant view; currently, can be 1 or 2 */
    version: number,
    /** True, if the instant view must be shown from right to left */
    is_rtl: boolean,
    /**
     * True, if the instant view contains the full page. A network request might be
     * needed to get the full web page instant view
     */
    is_full: boolean,
    /** An internal link to be opened to leave feedback about the instant view */
    feedback_link: InternalLinkType,
  }

  export type webPage = {
    /** Describes a web page preview */
    _: 'webPage',
    /** Original URL of the link */
    url: string,
    /** URL to display */
    display_url: string,
    /**
     * Type of the web page. Can be: article, photo, audio, video, document, profile,
     * app, or something else
     */
    type: string,
    /** Short name of the site (e.g., Google Docs, App Store) */
    site_name: string,
    /** Title of the content */
    title: string,
    /** Description of the content */
    description: formattedText,
    /** Image representing the content; may be null */
    photo?: photo,
    /** URL to show in the embedded preview */
    embed_url: string,
    /** MIME type of the embedded preview, (e.g., text/html or video/mp4) */
    embed_type: string,
    /** Width of the embedded preview */
    embed_width: number,
    /** Height of the embedded preview */
    embed_height: number,
    /** Duration of the content, in seconds */
    duration: number,
    /** Author of the content */
    author: string,
    /** Preview of the content as an animation, if available; may be null */
    animation?: animation,
    /** Preview of the content as an audio file, if available; may be null */
    audio?: audio,
    /** Preview of the content as a document, if available; may be null */
    document?: document,
    /**
     * Preview of the content as a sticker for small WEBP files, if available; may
     * be null
     */
    sticker?: sticker,
    /** Preview of the content as a video, if available; may be null */
    video?: video,
    /** Preview of the content as a video note, if available; may be null */
    video_note?: videoNote,
    /** Preview of the content as a voice note, if available; may be null */
    voice_note?: voiceNote,
    /** The identifier of the sender of the previewed story; 0 if none */
    story_sender_chat_id: number,
    /** The identifier of the previewed story; 0 if none */
    story_id: number,
    /** Version of web page instant view (currently, can be 1 or 2); 0 if none */
    instant_view_version: number,
  }

  export type countryInfo = {
    /** Contains information about a country */
    _: 'countryInfo',
    /** A two-letter ISO 3166-1 alpha-2 country code */
    country_code: string,
    /** Native name of the country */
    name: string,
    /** English name of the country */
    english_name: string,
    /** True, if the country must be hidden from the list of all countries */
    is_hidden: boolean,
    /** List of country calling codes */
    calling_codes: Array<string>,
  }

  export type countries = {
    /** Contains information about countries */
    _: 'countries',
    /** The list of countries */
    countries: Array<countryInfo>,
  }

  export type phoneNumberInfo = {
    /** Contains information about a phone number */
    _: 'phoneNumberInfo',
    /** Information about the country to which the phone number belongs; may be null */
    country?: countryInfo,
    /** The part of the phone number denoting country calling code or its part */
    country_calling_code: string,
    /**
     * The phone number without country calling code formatted accordingly to local
     * rules. Expected digits are returned as '-', but even more digits might be entered
     * by the user
     */
    formatted_phone_number: string,
    /** True, if the phone number was bought on Fragment and isn't tied to a SIM card */
    is_anonymous: boolean,
  }

  export type bankCardActionOpenUrl = {
    /** Describes an action associated with a bank card number */
    _: 'bankCardActionOpenUrl',
    /** Action text */
    text: string,
    /** The URL to be opened */
    url: string,
  }

  export type bankCardInfo = {
    /** Information about a bank card */
    _: 'bankCardInfo',
    /** Title of the bank card description */
    title: string,
    /** Actions that can be done with the bank card number */
    actions: Array<bankCardActionOpenUrl>,
  }

  export type address = {
    /** Describes an address */
    _: 'address',
    /** A two-letter ISO 3166-1 alpha-2 country code */
    country_code: string,
    /** State, if applicable */
    state: string,
    /** City */
    city: string,
    /** First line of the address */
    street_line1: string,
    /** Second line of the address */
    street_line2: string,
    /** Address postal code */
    postal_code: string,
  }

  export type address$Input = {
    /** Describes an address */
    readonly _: 'address',
    /** A two-letter ISO 3166-1 alpha-2 country code */
    readonly country_code?: string,
    /** State, if applicable */
    readonly state?: string,
    /** City */
    readonly city?: string,
    /** First line of the address */
    readonly street_line1?: string,
    /** Second line of the address */
    readonly street_line2?: string,
    /** Address postal code */
    readonly postal_code?: string,
  }

  export type themeParameters$Input = {
    /** Contains parameters of the application theme */
    readonly _: 'themeParameters',
    /** A color of the background in the RGB24 format */
    readonly background_color?: number,
    /** A secondary color for the background in the RGB24 format */
    readonly secondary_background_color?: number,
    /** A color of text in the RGB24 format */
    readonly text_color?: number,
    /** A color of hints in the RGB24 format */
    readonly hint_color?: number,
    /** A color of links in the RGB24 format */
    readonly link_color?: number,
    /** A color of the buttons in the RGB24 format */
    readonly button_color?: number,
    /** A color of text on the buttons in the RGB24 format */
    readonly button_text_color?: number,
  }

  export type labeledPricePart = {
    /** Portion of the price of a product (e.g., "delivery cost", "tax amount") */
    _: 'labeledPricePart',
    /** Label for this portion of the product price */
    label: string,
    /** Currency amount in the smallest units of the currency */
    amount: number,
  }

  export type labeledPricePart$Input = {
    /** Portion of the price of a product (e.g., "delivery cost", "tax amount") */
    readonly _: 'labeledPricePart',
    /** Label for this portion of the product price */
    readonly label?: string,
    /** Currency amount in the smallest units of the currency */
    readonly amount?: number,
  }

  export type invoice = {
    /** Product invoice */
    _: 'invoice',
    /** ISO 4217 currency code */
    currency: string,
    /** A list of objects used to calculate the total price of the product */
    price_parts: Array<labeledPricePart>,
    /** The maximum allowed amount of tip in the smallest units of the currency */
    max_tip_amount: number,
    /** Suggested amounts of tip in the smallest units of the currency */
    suggested_tip_amounts: Array<number>,
    /**
     * An HTTP URL with terms of service for recurring payments. If non-empty, the
     * invoice payment will result in recurring payments and the user must accept the
     * terms of service before allowed to pay
     */
    recurring_payment_terms_of_service_url: string,
    /**
     * An HTTP URL with terms of service for non-recurring payments. If non-empty,
     * then the user must accept the terms of service before allowed to pay
     */
    terms_of_service_url: string,
    /** True, if the payment is a test payment */
    is_test: boolean,
    /** True, if the user's name is needed for payment */
    need_name: boolean,
    /** True, if the user's phone number is needed for payment */
    need_phone_number: boolean,
    /** True, if the user's email address is needed for payment */
    need_email_address: boolean,
    /** True, if the user's shipping address is needed for payment */
    need_shipping_address: boolean,
    /** True, if the user's phone number will be sent to the provider */
    send_phone_number_to_provider: boolean,
    /** True, if the user's email address will be sent to the provider */
    send_email_address_to_provider: boolean,
    /** True, if the total price depends on the shipping method */
    is_flexible: boolean,
  }

  export type invoice$Input = {
    /** Product invoice */
    readonly _: 'invoice',
    /** ISO 4217 currency code */
    readonly currency?: string,
    /** A list of objects used to calculate the total price of the product */
    readonly price_parts?: ReadonlyArray<labeledPricePart$Input>,
    /** The maximum allowed amount of tip in the smallest units of the currency */
    readonly max_tip_amount?: number,
    /** Suggested amounts of tip in the smallest units of the currency */
    readonly suggested_tip_amounts?: ReadonlyArray<number>,
    /**
     * An HTTP URL with terms of service for recurring payments. If non-empty, the
     * invoice payment will result in recurring payments and the user must accept the
     * terms of service before allowed to pay
     */
    readonly recurring_payment_terms_of_service_url?: string,
    /**
     * An HTTP URL with terms of service for non-recurring payments. If non-empty,
     * then the user must accept the terms of service before allowed to pay
     */
    readonly terms_of_service_url?: string,
    /** True, if the payment is a test payment */
    readonly is_test?: boolean,
    /** True, if the user's name is needed for payment */
    readonly need_name?: boolean,
    /** True, if the user's phone number is needed for payment */
    readonly need_phone_number?: boolean,
    /** True, if the user's email address is needed for payment */
    readonly need_email_address?: boolean,
    /** True, if the user's shipping address is needed for payment */
    readonly need_shipping_address?: boolean,
    /** True, if the user's phone number will be sent to the provider */
    readonly send_phone_number_to_provider?: boolean,
    /** True, if the user's email address will be sent to the provider */
    readonly send_email_address_to_provider?: boolean,
    /** True, if the total price depends on the shipping method */
    readonly is_flexible?: boolean,
  }

  export type orderInfo = {
    /** Order information */
    _: 'orderInfo',
    /** Name of the user */
    name: string,
    /** Phone number of the user */
    phone_number: string,
    /** Email address of the user */
    email_address: string,
    /** Shipping address for this order; may be null */
    shipping_address?: address,
  }

  export type orderInfo$Input = {
    /** Order information */
    readonly _: 'orderInfo',
    /** Name of the user */
    readonly name?: string,
    /** Phone number of the user */
    readonly phone_number?: string,
    /** Email address of the user */
    readonly email_address?: string,
    /** Shipping address for this order; may be null */
    readonly shipping_address?: address$Input,
  }

  export type shippingOption = {
    /** One shipping option */
    _: 'shippingOption',
    /** Shipping option identifier */
    id: string,
    /** Option title */
    title: string,
    /** A list of objects used to calculate the total shipping costs */
    price_parts: Array<labeledPricePart>,
  }

  export type shippingOption$Input = {
    /** One shipping option */
    readonly _: 'shippingOption',
    /** Shipping option identifier */
    readonly id?: string,
    /** Option title */
    readonly title?: string,
    /** A list of objects used to calculate the total shipping costs */
    readonly price_parts?: ReadonlyArray<labeledPricePart$Input>,
  }

  export type savedCredentials = {
    /** Contains information about saved payment credentials */
    _: 'savedCredentials',
    /** Unique identifier of the saved credentials */
    id: string,
    /** Title of the saved credentials */
    title: string,
  }

  export type inputCredentialsSaved$Input = {
    /**
     * Applies if a user chooses some previously saved payment credentials. To use
     * their previously saved credentials, the user must have a valid temporary password
     */
    readonly _: 'inputCredentialsSaved',
    /** Identifier of the saved credentials */
    readonly saved_credentials_id?: string,
  }

  export type inputCredentialsNew$Input = {
    /** Applies if a user enters new credentials on a payment provider website */
    readonly _: 'inputCredentialsNew',
    /** JSON-encoded data with the credential identifier from the payment provider */
    readonly data?: string,
    /** True, if the credential identifier can be saved on the server side */
    readonly allow_save?: boolean,
  }

  export type inputCredentialsApplePay$Input = {
    /** Applies if a user enters new credentials using Apple Pay */
    readonly _: 'inputCredentialsApplePay',
    /** JSON-encoded data with the credential identifier */
    readonly data?: string,
  }

  export type inputCredentialsGooglePay$Input = {
    /** Applies if a user enters new credentials using Google Pay */
    readonly _: 'inputCredentialsGooglePay',
    /** JSON-encoded data with the credential identifier */
    readonly data?: string,
  }

  export type paymentProviderSmartGlocal = {
    /** Smart Glocal payment provider */
    _: 'paymentProviderSmartGlocal',
    /** Public payment token */
    public_token: string,
  }

  export type paymentProviderStripe = {
    /** Stripe payment provider */
    _: 'paymentProviderStripe',
    /** Stripe API publishable key */
    publishable_key: string,
    /** True, if the user country must be provided */
    need_country: boolean,
    /** True, if the user ZIP/postal code must be provided */
    need_postal_code: boolean,
    /** True, if the cardholder name must be provided */
    need_cardholder_name: boolean,
  }

  export type paymentProviderOther = {
    /** Some other payment provider, for which a web payment form must be shown */
    _: 'paymentProviderOther',
    /** Payment form URL */
    url: string,
  }

  export type paymentOption = {
    /** Describes an additional payment option */
    _: 'paymentOption',
    /** Title for the payment option */
    title: string,
    /** Payment form URL to be opened in a web view */
    url: string,
  }

  export type paymentForm = {
    /** Contains information about an invoice payment form */
    _: 'paymentForm',
    /** The payment form identifier */
    id: number | string,
    /** Full information about the invoice */
    invoice: invoice,
    /** User identifier of the seller bot */
    seller_bot_user_id: number,
    /** User identifier of the payment provider bot */
    payment_provider_user_id: number,
    /** Information about the payment provider */
    payment_provider: PaymentProvider,
    /** The list of additional payment options */
    additional_payment_options: Array<paymentOption>,
    /** Saved server-side order information; may be null */
    saved_order_info?: orderInfo,
    /** The list of saved payment credentials */
    saved_credentials: Array<savedCredentials>,
    /** True, if the user can choose to save credentials */
    can_save_credentials: boolean,
    /**
     * True, if the user will be able to save credentials, if sets up a 2-step verification
     * password
     */
    need_password: boolean,
    /** Product title */
    product_title: string,
    /** Product description */
    product_description: formattedText,
    /** Product photo; may be null */
    product_photo?: photo,
  }

  export type validatedOrderInfo = {
    /**
     * Contains a temporary identifier of validated order information, which is stored
     * for one hour, and the available shipping options
     */
    _: 'validatedOrderInfo',
    /** Temporary identifier of the order information */
    order_info_id: string,
    /** Available shipping options */
    shipping_options: Array<shippingOption>,
  }

  export type paymentResult = {
    /** Contains the result of a payment request */
    _: 'paymentResult',
    /**
     * True, if the payment request was successful; otherwise, the verification_url
     * will be non-empty
     */
    success: boolean,
    /** URL for additional payment credentials verification */
    verification_url: string,
  }

  export type paymentReceipt = {
    /** Contains information about a successful payment */
    _: 'paymentReceipt',
    /** Product title */
    title: string,
    /** Product description */
    description: formattedText,
    /** Product photo; may be null */
    photo?: photo,
    /** Point in time (Unix timestamp) when the payment was made */
    date: number,
    /** User identifier of the seller bot */
    seller_bot_user_id: number,
    /** User identifier of the payment provider bot */
    payment_provider_user_id: number,
    /** Information about the invoice */
    invoice: invoice,
    /** Order information; may be null */
    order_info?: orderInfo,
    /** Chosen shipping option; may be null */
    shipping_option?: shippingOption,
    /** Title of the saved credentials chosen by the buyer */
    credentials_title: string,
    /** The amount of tip chosen by the buyer in the smallest units of the currency */
    tip_amount: number,
  }

  export type inputInvoiceMessage$Input = {
    /** An invoice from a message of the type messageInvoice */
    readonly _: 'inputInvoiceMessage',
    /** Chat identifier of the message */
    readonly chat_id?: number,
    /** Message identifier */
    readonly message_id?: number,
  }

  export type inputInvoiceName$Input = {
    /** An invoice from a link of the type internalLinkTypeInvoice */
    readonly _: 'inputInvoiceName',
    /** Name of the invoice */
    readonly name?: string,
  }

  export type messageExtendedMediaPreview = {
    /** The media is hidden until the invoice is paid */
    _: 'messageExtendedMediaPreview',
    /** Media width; 0 if unknown */
    width: number,
    /** Media height; 0 if unknown */
    height: number,
    /** Media duration; 0 if unknown */
    duration: number,
    /** Media minithumbnail; may be null */
    minithumbnail?: minithumbnail,
    /** Media caption */
    caption: formattedText,
  }

  export type messageExtendedMediaPhoto = {
    /** The media is a photo */
    _: 'messageExtendedMediaPhoto',
    /** The photo */
    photo: photo,
    /** Photo caption */
    caption: formattedText,
  }

  export type messageExtendedMediaVideo = {
    /** The media is a video */
    _: 'messageExtendedMediaVideo',
    /** The video */
    video: video,
    /** Photo caption */
    caption: formattedText,
  }

  export type messageExtendedMediaUnsupported = {
    /** The media is unsupported */
    _: 'messageExtendedMediaUnsupported',
    /** Media caption */
    caption: formattedText,
  }

  export type datedFile = {
    /** File with the date it was uploaded */
    _: 'datedFile',
    /** The file */
    file: file,
    /** Point in time (Unix timestamp) when the file was uploaded */
    date: number,
  }

  export type passportElementTypePersonalDetails = {
    /** A Telegram Passport element containing the user's personal details */
    _: 'passportElementTypePersonalDetails',
  }

  export type passportElementTypePersonalDetails$Input = {
    /** A Telegram Passport element containing the user's personal details */
    readonly _: 'passportElementTypePersonalDetails',
  }

  export type passportElementTypePassport = {
    /** A Telegram Passport element containing the user's passport */
    _: 'passportElementTypePassport',
  }

  export type passportElementTypePassport$Input = {
    /** A Telegram Passport element containing the user's passport */
    readonly _: 'passportElementTypePassport',
  }

  export type passportElementTypeDriverLicense = {
    /** A Telegram Passport element containing the user's driver license */
    _: 'passportElementTypeDriverLicense',
  }

  export type passportElementTypeDriverLicense$Input = {
    /** A Telegram Passport element containing the user's driver license */
    readonly _: 'passportElementTypeDriverLicense',
  }

  export type passportElementTypeIdentityCard = {
    /** A Telegram Passport element containing the user's identity card */
    _: 'passportElementTypeIdentityCard',
  }

  export type passportElementTypeIdentityCard$Input = {
    /** A Telegram Passport element containing the user's identity card */
    readonly _: 'passportElementTypeIdentityCard',
  }

  export type passportElementTypeInternalPassport = {
    /** A Telegram Passport element containing the user's internal passport */
    _: 'passportElementTypeInternalPassport',
  }

  export type passportElementTypeInternalPassport$Input = {
    /** A Telegram Passport element containing the user's internal passport */
    readonly _: 'passportElementTypeInternalPassport',
  }

  export type passportElementTypeAddress = {
    /** A Telegram Passport element containing the user's address */
    _: 'passportElementTypeAddress',
  }

  export type passportElementTypeAddress$Input = {
    /** A Telegram Passport element containing the user's address */
    readonly _: 'passportElementTypeAddress',
  }

  export type passportElementTypeUtilityBill = {
    /** A Telegram Passport element containing the user's utility bill */
    _: 'passportElementTypeUtilityBill',
  }

  export type passportElementTypeUtilityBill$Input = {
    /** A Telegram Passport element containing the user's utility bill */
    readonly _: 'passportElementTypeUtilityBill',
  }

  export type passportElementTypeBankStatement = {
    /** A Telegram Passport element containing the user's bank statement */
    _: 'passportElementTypeBankStatement',
  }

  export type passportElementTypeBankStatement$Input = {
    /** A Telegram Passport element containing the user's bank statement */
    readonly _: 'passportElementTypeBankStatement',
  }

  export type passportElementTypeRentalAgreement = {
    /** A Telegram Passport element containing the user's rental agreement */
    _: 'passportElementTypeRentalAgreement',
  }

  export type passportElementTypeRentalAgreement$Input = {
    /** A Telegram Passport element containing the user's rental agreement */
    readonly _: 'passportElementTypeRentalAgreement',
  }

  export type passportElementTypePassportRegistration = {
    /** A Telegram Passport element containing the registration page of the user's passport */
    _: 'passportElementTypePassportRegistration',
  }

  export type passportElementTypePassportRegistration$Input = {
    /** A Telegram Passport element containing the registration page of the user's passport */
    readonly _: 'passportElementTypePassportRegistration',
  }

  export type passportElementTypeTemporaryRegistration = {
    /** A Telegram Passport element containing the user's temporary registration */
    _: 'passportElementTypeTemporaryRegistration',
  }

  export type passportElementTypeTemporaryRegistration$Input = {
    /** A Telegram Passport element containing the user's temporary registration */
    readonly _: 'passportElementTypeTemporaryRegistration',
  }

  export type passportElementTypePhoneNumber = {
    /** A Telegram Passport element containing the user's phone number */
    _: 'passportElementTypePhoneNumber',
  }

  export type passportElementTypePhoneNumber$Input = {
    /** A Telegram Passport element containing the user's phone number */
    readonly _: 'passportElementTypePhoneNumber',
  }

  export type passportElementTypeEmailAddress = {
    /** A Telegram Passport element containing the user's email address */
    _: 'passportElementTypeEmailAddress',
  }

  export type passportElementTypeEmailAddress$Input = {
    /** A Telegram Passport element containing the user's email address */
    readonly _: 'passportElementTypeEmailAddress',
  }

  export type date = {
    /** Represents a date according to the Gregorian calendar */
    _: 'date',
    /** Day of the month; 1-31 */
    day: number,
    /** Month; 1-12 */
    month: number,
    /** Year; 1-9999 */
    year: number,
  }

  export type date$Input = {
    /** Represents a date according to the Gregorian calendar */
    readonly _: 'date',
    /** Day of the month; 1-31 */
    readonly day?: number,
    /** Month; 1-12 */
    readonly month?: number,
    /** Year; 1-9999 */
    readonly year?: number,
  }

  export type personalDetails = {
    /** Contains the user's personal details */
    _: 'personalDetails',
    /** First name of the user written in English; 1-255 characters */
    first_name: string,
    /** Middle name of the user written in English; 0-255 characters */
    middle_name: string,
    /** Last name of the user written in English; 1-255 characters */
    last_name: string,
    /** Native first name of the user; 1-255 characters */
    native_first_name: string,
    /** Native middle name of the user; 0-255 characters */
    native_middle_name: string,
    /** Native last name of the user; 1-255 characters */
    native_last_name: string,
    /** Birthdate of the user */
    birthdate: date,
    /** Gender of the user, "male" or "female" */
    gender: string,
    /** A two-letter ISO 3166-1 alpha-2 country code of the user's country */
    country_code: string,
    /** A two-letter ISO 3166-1 alpha-2 country code of the user's residence country */
    residence_country_code: string,
  }

  export type personalDetails$Input = {
    /** Contains the user's personal details */
    readonly _: 'personalDetails',
    /** First name of the user written in English; 1-255 characters */
    readonly first_name?: string,
    /** Middle name of the user written in English; 0-255 characters */
    readonly middle_name?: string,
    /** Last name of the user written in English; 1-255 characters */
    readonly last_name?: string,
    /** Native first name of the user; 1-255 characters */
    readonly native_first_name?: string,
    /** Native middle name of the user; 0-255 characters */
    readonly native_middle_name?: string,
    /** Native last name of the user; 1-255 characters */
    readonly native_last_name?: string,
    /** Birthdate of the user */
    readonly birthdate?: date$Input,
    /** Gender of the user, "male" or "female" */
    readonly gender?: string,
    /** A two-letter ISO 3166-1 alpha-2 country code of the user's country */
    readonly country_code?: string,
    /** A two-letter ISO 3166-1 alpha-2 country code of the user's residence country */
    readonly residence_country_code?: string,
  }

  export type identityDocument = {
    /** An identity document */
    _: 'identityDocument',
    /** Document number; 1-24 characters */
    number: string,
    /** Document expiration date; may be null if not applicable */
    expiration_date?: date,
    /** Front side of the document */
    front_side: datedFile,
    /**
     * Reverse side of the document; only for driver license and identity card; may
     * be null
     */
    reverse_side?: datedFile,
    /** Selfie with the document; may be null */
    selfie?: datedFile,
    /** List of files containing a certified English translation of the document */
    translation: Array<datedFile>,
  }

  export type inputIdentityDocument$Input = {
    /** An identity document to be saved to Telegram Passport */
    readonly _: 'inputIdentityDocument',
    /** Document number; 1-24 characters */
    readonly number?: string,
    /** Document expiration date; pass null if not applicable */
    readonly expiration_date?: date$Input,
    /** Front side of the document */
    readonly front_side?: InputFile$Input,
    /**
     * Reverse side of the document; only for driver license and identity card; pass
     * null otherwise
     */
    readonly reverse_side?: InputFile$Input,
    /** Selfie with the document; pass null if unavailable */
    readonly selfie?: InputFile$Input,
    /** List of files containing a certified English translation of the document */
    readonly translation?: ReadonlyArray<InputFile$Input>,
  }

  export type personalDocument = {
    /** A personal document, containing some information about a user */
    _: 'personalDocument',
    /** List of files containing the pages of the document */
    files: Array<datedFile>,
    /** List of files containing a certified English translation of the document */
    translation: Array<datedFile>,
  }

  export type inputPersonalDocument$Input = {
    /** A personal document to be saved to Telegram Passport */
    readonly _: 'inputPersonalDocument',
    /** List of files containing the pages of the document */
    readonly files?: ReadonlyArray<InputFile$Input>,
    /** List of files containing a certified English translation of the document */
    readonly translation?: ReadonlyArray<InputFile$Input>,
  }

  export type passportElementPersonalDetails = {
    /** A Telegram Passport element containing the user's personal details */
    _: 'passportElementPersonalDetails',
    /** Personal details of the user */
    personal_details: personalDetails,
  }

  export type passportElementPassport = {
    /** A Telegram Passport element containing the user's passport */
    _: 'passportElementPassport',
    /** Passport */
    passport: identityDocument,
  }

  export type passportElementDriverLicense = {
    /** A Telegram Passport element containing the user's driver license */
    _: 'passportElementDriverLicense',
    /** Driver license */
    driver_license: identityDocument,
  }

  export type passportElementIdentityCard = {
    /** A Telegram Passport element containing the user's identity card */
    _: 'passportElementIdentityCard',
    /** Identity card */
    identity_card: identityDocument,
  }

  export type passportElementInternalPassport = {
    /** A Telegram Passport element containing the user's internal passport */
    _: 'passportElementInternalPassport',
    /** Internal passport */
    internal_passport: identityDocument,
  }

  export type passportElementAddress = {
    /** A Telegram Passport element containing the user's address */
    _: 'passportElementAddress',
    /** Address */
    address: address,
  }

  export type passportElementUtilityBill = {
    /** A Telegram Passport element containing the user's utility bill */
    _: 'passportElementUtilityBill',
    /** Utility bill */
    utility_bill: personalDocument,
  }

  export type passportElementBankStatement = {
    /** A Telegram Passport element containing the user's bank statement */
    _: 'passportElementBankStatement',
    /** Bank statement */
    bank_statement: personalDocument,
  }

  export type passportElementRentalAgreement = {
    /** A Telegram Passport element containing the user's rental agreement */
    _: 'passportElementRentalAgreement',
    /** Rental agreement */
    rental_agreement: personalDocument,
  }

  export type passportElementPassportRegistration = {
    /** A Telegram Passport element containing the user's passport registration pages */
    _: 'passportElementPassportRegistration',
    /** Passport registration pages */
    passport_registration: personalDocument,
  }

  export type passportElementTemporaryRegistration = {
    /** A Telegram Passport element containing the user's temporary registration */
    _: 'passportElementTemporaryRegistration',
    /** Temporary registration */
    temporary_registration: personalDocument,
  }

  export type passportElementPhoneNumber = {
    /** A Telegram Passport element containing the user's phone number */
    _: 'passportElementPhoneNumber',
    /** Phone number */
    phone_number: string,
  }

  export type passportElementEmailAddress = {
    /** A Telegram Passport element containing the user's email address */
    _: 'passportElementEmailAddress',
    /** Email address */
    email_address: string,
  }

  export type inputPassportElementPersonalDetails$Input = {
    /** A Telegram Passport element to be saved containing the user's personal details */
    readonly _: 'inputPassportElementPersonalDetails',
    /** Personal details of the user */
    readonly personal_details?: personalDetails$Input,
  }

  export type inputPassportElementPassport$Input = {
    /** A Telegram Passport element to be saved containing the user's passport */
    readonly _: 'inputPassportElementPassport',
    /** The passport to be saved */
    readonly passport?: inputIdentityDocument$Input,
  }

  export type inputPassportElementDriverLicense$Input = {
    /** A Telegram Passport element to be saved containing the user's driver license */
    readonly _: 'inputPassportElementDriverLicense',
    /** The driver license to be saved */
    readonly driver_license?: inputIdentityDocument$Input,
  }

  export type inputPassportElementIdentityCard$Input = {
    /** A Telegram Passport element to be saved containing the user's identity card */
    readonly _: 'inputPassportElementIdentityCard',
    /** The identity card to be saved */
    readonly identity_card?: inputIdentityDocument$Input,
  }

  export type inputPassportElementInternalPassport$Input = {
    /** A Telegram Passport element to be saved containing the user's internal passport */
    readonly _: 'inputPassportElementInternalPassport',
    /** The internal passport to be saved */
    readonly internal_passport?: inputIdentityDocument$Input,
  }

  export type inputPassportElementAddress$Input = {
    /** A Telegram Passport element to be saved containing the user's address */
    readonly _: 'inputPassportElementAddress',
    /** The address to be saved */
    readonly address?: address$Input,
  }

  export type inputPassportElementUtilityBill$Input = {
    /** A Telegram Passport element to be saved containing the user's utility bill */
    readonly _: 'inputPassportElementUtilityBill',
    /** The utility bill to be saved */
    readonly utility_bill?: inputPersonalDocument$Input,
  }

  export type inputPassportElementBankStatement$Input = {
    /** A Telegram Passport element to be saved containing the user's bank statement */
    readonly _: 'inputPassportElementBankStatement',
    /** The bank statement to be saved */
    readonly bank_statement?: inputPersonalDocument$Input,
  }

  export type inputPassportElementRentalAgreement$Input = {
    /** A Telegram Passport element to be saved containing the user's rental agreement */
    readonly _: 'inputPassportElementRentalAgreement',
    /** The rental agreement to be saved */
    readonly rental_agreement?: inputPersonalDocument$Input,
  }

  export type inputPassportElementPassportRegistration$Input = {
    /** A Telegram Passport element to be saved containing the user's passport registration */
    readonly _: 'inputPassportElementPassportRegistration',
    /** The passport registration page to be saved */
    readonly passport_registration?: inputPersonalDocument$Input,
  }

  export type inputPassportElementTemporaryRegistration$Input = {
    /** A Telegram Passport element to be saved containing the user's temporary registration */
    readonly _: 'inputPassportElementTemporaryRegistration',
    /** The temporary registration document to be saved */
    readonly temporary_registration?: inputPersonalDocument$Input,
  }

  export type inputPassportElementPhoneNumber$Input = {
    /** A Telegram Passport element to be saved containing the user's phone number */
    readonly _: 'inputPassportElementPhoneNumber',
    /** The phone number to be saved */
    readonly phone_number?: string,
  }

  export type inputPassportElementEmailAddress$Input = {
    /** A Telegram Passport element to be saved containing the user's email address */
    readonly _: 'inputPassportElementEmailAddress',
    /** The email address to be saved */
    readonly email_address?: string,
  }

  export type passportElements = {
    /** Contains information about saved Telegram Passport elements */
    _: 'passportElements',
    /** Telegram Passport elements */
    elements: Array<PassportElement>,
  }

  export type passportElementErrorSourceUnspecified = {
    /**
     * The element contains an error in an unspecified place. The error will be considered
     * resolved when new data is added
     */
    _: 'passportElementErrorSourceUnspecified',
  }

  export type passportElementErrorSourceDataField = {
    /**
     * One of the data fields contains an error. The error will be considered resolved
     * when the value of the field changes
     */
    _: 'passportElementErrorSourceDataField',
    /** Field name */
    field_name: string,
  }

  export type passportElementErrorSourceFrontSide = {
    /**
     * The front side of the document contains an error. The error will be considered
     * resolved when the file with the front side changes
     */
    _: 'passportElementErrorSourceFrontSide',
  }

  export type passportElementErrorSourceReverseSide = {
    /**
     * The reverse side of the document contains an error. The error will be considered
     * resolved when the file with the reverse side changes
     */
    _: 'passportElementErrorSourceReverseSide',
  }

  export type passportElementErrorSourceSelfie = {
    /**
     * The selfie with the document contains an error. The error will be considered
     * resolved when the file with the selfie changes
     */
    _: 'passportElementErrorSourceSelfie',
  }

  export type passportElementErrorSourceTranslationFile = {
    /**
     * One of files with the translation of the document contains an error. The error
     * will be considered resolved when the file changes
     */
    _: 'passportElementErrorSourceTranslationFile',
    /** Index of a file with the error */
    file_index: number,
  }

  export type passportElementErrorSourceTranslationFiles = {
    /**
     * The translation of the document contains an error. The error will be considered
     * resolved when the list of translation files changes
     */
    _: 'passportElementErrorSourceTranslationFiles',
  }

  export type passportElementErrorSourceFile = {
    /**
     * The file contains an error. The error will be considered resolved when the file
     * changes
     */
    _: 'passportElementErrorSourceFile',
    /** Index of a file with the error */
    file_index: number,
  }

  export type passportElementErrorSourceFiles = {
    /**
     * The list of attached files contains an error. The error will be considered resolved
     * when the list of files changes
     */
    _: 'passportElementErrorSourceFiles',
  }

  export type passportElementError = {
    /** Contains the description of an error in a Telegram Passport element */
    _: 'passportElementError',
    /** Type of the Telegram Passport element which has the error */
    type: PassportElementType,
    /** Error message */
    message: string,
    /** Error source */
    source: PassportElementErrorSource,
  }

  export type passportSuitableElement = {
    /**
     * Contains information about a Telegram Passport element that was requested by
     * a service
     */
    _: 'passportSuitableElement',
    /** Type of the element */
    type: PassportElementType,
    /** True, if a selfie is required with the identity document */
    is_selfie_required: boolean,
    /** True, if a certified English translation is required with the document */
    is_translation_required: boolean,
    /**
     * True, if personal details must include the user's name in the language of their
     * country of residence
     */
    is_native_name_required: boolean,
  }

  export type passportRequiredElement = {
    /**
     * Contains a description of the required Telegram Passport element that was requested
     * by a service
     */
    _: 'passportRequiredElement',
    /** List of Telegram Passport elements any of which is enough to provide */
    suitable_elements: Array<passportSuitableElement>,
  }

  export type passportAuthorizationForm = {
    /** Contains information about a Telegram Passport authorization form that was requested */
    _: 'passportAuthorizationForm',
    /** Unique identifier of the authorization form */
    id: number,
    /** Telegram Passport elements that must be provided to complete the form */
    required_elements: Array<passportRequiredElement>,
    /** URL for the privacy policy of the service; may be empty */
    privacy_policy_url: string,
  }

  export type passportElementsWithErrors = {
    /** Contains information about a Telegram Passport elements and corresponding errors */
    _: 'passportElementsWithErrors',
    /** Telegram Passport elements */
    elements: Array<PassportElement>,
    /** Errors in the elements that are already available */
    errors: Array<passportElementError>,
  }

  export type encryptedCredentials = {
    /** Contains encrypted Telegram Passport data credentials */
    _: 'encryptedCredentials',
    /** The encrypted credentials */
    data: string,
    /** The decrypted data hash */
    hash: string,
    /** Secret for data decryption, encrypted with the service's public key */
    secret: string,
  }

  export type encryptedPassportElement = {
    /**
     * Contains information about an encrypted Telegram Passport element; for bots
     * only
     */
    _: 'encryptedPassportElement',
    /** Type of Telegram Passport element */
    type: PassportElementType,
    /** Encrypted JSON-encoded data about the user */
    data: string,
    /** The front side of an identity document */
    front_side: datedFile,
    /** The reverse side of an identity document; may be null */
    reverse_side?: datedFile,
    /** Selfie with the document; may be null */
    selfie?: datedFile,
    /** List of files containing a certified English translation of the document */
    translation: Array<datedFile>,
    /** List of attached files */
    files: Array<datedFile>,
    /** Unencrypted data, phone number or email address */
    value: string,
    /** Hash of the entire element */
    hash: string,
  }

  export type inputPassportElementErrorSourceUnspecified$Input = {
    /**
     * The element contains an error in an unspecified place. The error will be considered
     * resolved when new data is added
     */
    readonly _: 'inputPassportElementErrorSourceUnspecified',
    /** Current hash of the entire element */
    readonly element_hash?: string,
  }

  export type inputPassportElementErrorSourceDataField$Input = {
    /**
     * A data field contains an error. The error is considered resolved when the field's
     * value changes
     */
    readonly _: 'inputPassportElementErrorSourceDataField',
    /** Field name */
    readonly field_name?: string,
    /** Current data hash */
    readonly data_hash?: string,
  }

  export type inputPassportElementErrorSourceFrontSide$Input = {
    /**
     * The front side of the document contains an error. The error is considered resolved
     * when the file with the front side of the document changes
     */
    readonly _: 'inputPassportElementErrorSourceFrontSide',
    /** Current hash of the file containing the front side */
    readonly file_hash?: string,
  }

  export type inputPassportElementErrorSourceReverseSide$Input = {
    /**
     * The reverse side of the document contains an error. The error is considered
     * resolved when the file with the reverse side of the document changes
     */
    readonly _: 'inputPassportElementErrorSourceReverseSide',
    /** Current hash of the file containing the reverse side */
    readonly file_hash?: string,
  }

  export type inputPassportElementErrorSourceSelfie$Input = {
    /**
     * The selfie contains an error. The error is considered resolved when the file
     * with the selfie changes
     */
    readonly _: 'inputPassportElementErrorSourceSelfie',
    /** Current hash of the file containing the selfie */
    readonly file_hash?: string,
  }

  export type inputPassportElementErrorSourceTranslationFile$Input = {
    /**
     * One of the files containing the translation of the document contains an error.
     * The error is considered resolved when the file with the translation changes
     */
    readonly _: 'inputPassportElementErrorSourceTranslationFile',
    /** Current hash of the file containing the translation */
    readonly file_hash?: string,
  }

  export type inputPassportElementErrorSourceTranslationFiles$Input = {
    /**
     * The translation of the document contains an error. The error is considered resolved
     * when the list of files changes
     */
    readonly _: 'inputPassportElementErrorSourceTranslationFiles',
    /** Current hashes of all files with the translation */
    readonly file_hashes?: ReadonlyArray<string>,
  }

  export type inputPassportElementErrorSourceFile$Input = {
    /** The file contains an error. The error is considered resolved when the file changes */
    readonly _: 'inputPassportElementErrorSourceFile',
    /** Current hash of the file which has the error */
    readonly file_hash?: string,
  }

  export type inputPassportElementErrorSourceFiles$Input = {
    /**
     * The list of attached files contains an error. The error is considered resolved
     * when the file list changes
     */
    readonly _: 'inputPassportElementErrorSourceFiles',
    /** Current hashes of all attached files */
    readonly file_hashes?: ReadonlyArray<string>,
  }

  export type inputPassportElementError$Input = {
    /**
     * Contains the description of an error in a Telegram Passport element; for bots
     * only
     */
    readonly _: 'inputPassportElementError',
    /** Type of Telegram Passport element that has the error */
    readonly type?: PassportElementType$Input,
    /** Error message */
    readonly message?: string,
    /** Error source */
    readonly source?: InputPassportElementErrorSource$Input,
  }

  export type messageText = {
    /** A text message */
    _: 'messageText',
    /** Text of the message */
    text: formattedText,
    /** A preview of the web page that's mentioned in the text; may be null */
    web_page?: webPage,
  }

  export type messageAnimation = {
    /** An animation message (GIF-style). */
    _: 'messageAnimation',
    /** The animation description */
    animation: animation,
    /** Animation caption */
    caption: formattedText,
    /** True, if the animation preview must be covered by a spoiler animation */
    has_spoiler: boolean,
    /**
     * True, if the animation thumbnail must be blurred and the animation must be shown
     * only while tapped
     */
    is_secret: boolean,
  }

  export type messageAudio = {
    /** An audio message */
    _: 'messageAudio',
    /** The audio description */
    audio: audio,
    /** Audio caption */
    caption: formattedText,
  }

  export type messageDocument = {
    /** A document message (general file) */
    _: 'messageDocument',
    /** The document description */
    document: document,
    /** Document caption */
    caption: formattedText,
  }

  export type messagePhoto = {
    /** A photo message */
    _: 'messagePhoto',
    /** The photo */
    photo: photo,
    /** Photo caption */
    caption: formattedText,
    /** True, if the photo preview must be covered by a spoiler animation */
    has_spoiler: boolean,
    /** True, if the photo must be blurred and must be shown only while tapped */
    is_secret: boolean,
  }

  export type messageExpiredPhoto = {
    /** A self-destructed photo message */
    _: 'messageExpiredPhoto',
  }

  export type messageSticker = {
    /** A sticker message */
    _: 'messageSticker',
    /** The sticker description */
    sticker: sticker,
    /** True, if premium animation of the sticker must be played */
    is_premium: boolean,
  }

  export type messageVideo = {
    /** A video message */
    _: 'messageVideo',
    /** The video description */
    video: video,
    /** Video caption */
    caption: formattedText,
    /** True, if the video preview must be covered by a spoiler animation */
    has_spoiler: boolean,
    /**
     * True, if the video thumbnail must be blurred and the video must be shown only
     * while tapped
     */
    is_secret: boolean,
  }

  export type messageExpiredVideo = {
    /** A self-destructed video message */
    _: 'messageExpiredVideo',
  }

  export type messageVideoNote = {
    /** A video note message */
    _: 'messageVideoNote',
    /** The video note description */
    video_note: videoNote,
    /** True, if at least one of the recipients has viewed the video note */
    is_viewed: boolean,
    /**
     * True, if the video note thumbnail must be blurred and the video note must be
     * shown only while tapped
     */
    is_secret: boolean,
  }

  export type messageVoiceNote = {
    /** A voice note message */
    _: 'messageVoiceNote',
    /** The voice note description */
    voice_note: voiceNote,
    /** Voice note caption */
    caption: formattedText,
    /** True, if at least one of the recipients has listened to the voice note */
    is_listened: boolean,
  }

  export type messageLocation = {
    /** A message with a location */
    _: 'messageLocation',
    /** The location description */
    location: location,
    /**
     * Time relative to the message send date, for which the location can be updated,
     * in seconds
     */
    live_period: number,
    /**
     * Left time for which the location can be updated, in seconds. updateMessageContent
     * is not sent when this field changes
     */
    expires_in: number,
    /**
     * For live locations, a direction in which the location moves, in degrees; 1-360.
     * If 0 the direction is unknown
     */
    heading: number,
    /**
     * For live locations, a maximum distance to another chat member for proximity
     * alerts, in meters (0-100000). 0 if the notification is disabled. Available only
     * to the message sender
     */
    proximity_alert_radius: number,
  }

  export type messageVenue = {
    /** A message with information about a venue */
    _: 'messageVenue',
    /** The venue description */
    venue: venue,
  }

  export type messageContact = {
    /** A message with a user contact */
    _: 'messageContact',
    /** The contact description */
    contact: contact,
  }

  export type messageAnimatedEmoji = {
    /** A message with an animated emoji */
    _: 'messageAnimatedEmoji',
    /** The animated emoji */
    animated_emoji: animatedEmoji,
    /** The corresponding emoji */
    emoji: string,
  }

  export type messageDice = {
    /** A dice message. The dice value is randomly generated by the server */
    _: 'messageDice',
    /**
     * The animated stickers with the initial dice animation; may be null if unknown.
     * updateMessageContent will be sent when the sticker became known
     */
    initial_state?: DiceStickers,
    /**
     * The animated stickers with the final dice animation; may be null if unknown.
     * updateMessageContent will be sent when the sticker became known
     */
    final_state?: DiceStickers,
    /** Emoji on which the dice throw animation is based */
    emoji: string,
    /** The dice value. If the value is 0, the dice don't have final state yet */
    value: number,
    /**
     * Number of frame after which a success animation like a shower of confetti needs
     * to be shown on updateMessageSendSucceeded
     */
    success_animation_frame_number: number,
  }

  export type messageGame = {
    /** A message with a game */
    _: 'messageGame',
    /** The game description */
    game: game,
  }

  export type messagePoll = {
    /** A message with a poll */
    _: 'messagePoll',
    /** The poll description */
    poll: poll,
  }

  export type messageStory = {
    /** A message with a forwarded story */
    _: 'messageStory',
    /** Identifier of the chat that posted the story */
    story_sender_chat_id: number,
    /** Story identifier */
    story_id: number,
    /** True, if the story was automatically forwarded because of a mention of the user */
    via_mention: boolean,
  }

  export type messageInvoice = {
    /**
     * A message with an invoice from a bot. Use getInternalLink with internalLinkTypeBotStart
     * to share the invoice
     */
    _: 'messageInvoice',
    /** Product title */
    title: string,
    /** Product description */
    description: formattedText,
    /** Product photo; may be null */
    photo?: photo,
    /** Currency for the product price */
    currency: string,
    /** Product total price in the smallest units of the currency */
    total_amount: number,
    /** Unique invoice bot start_parameter to be passed to getInternalLink */
    start_parameter: string,
    /** True, if the invoice is a test invoice */
    is_test: boolean,
    /** True, if the shipping address must be specified */
    need_shipping_address: boolean,
    /** The identifier of the message with the receipt, after the product has been purchased */
    receipt_message_id: number,
    /** Extended media attached to the invoice; may be null */
    extended_media?: MessageExtendedMedia,
  }

  export type messageCall = {
    /** A message with information about an ended call */
    _: 'messageCall',
    /** True, if the call was a video call */
    is_video: boolean,
    /** Reason why the call was discarded */
    discard_reason: CallDiscardReason,
    /** Call duration, in seconds */
    duration: number,
  }

  export type messageVideoChatScheduled = {
    /** A new video chat was scheduled */
    _: 'messageVideoChatScheduled',
    /**
     * Identifier of the video chat. The video chat can be received through the method
     * getGroupCall
     */
    group_call_id: number,
    /**
     * Point in time (Unix timestamp) when the group call is supposed to be started
     * by an administrator
     */
    start_date: number,
  }

  export type messageVideoChatStarted = {
    /** A newly created video chat */
    _: 'messageVideoChatStarted',
    /**
     * Identifier of the video chat. The video chat can be received through the method
     * getGroupCall
     */
    group_call_id: number,
  }

  export type messageVideoChatEnded = {
    /** A message with information about an ended video chat */
    _: 'messageVideoChatEnded',
    /** Call duration, in seconds */
    duration: number,
  }

  export type messageInviteVideoChatParticipants = {
    /** A message with information about an invite to a video chat */
    _: 'messageInviteVideoChatParticipants',
    /**
     * Identifier of the video chat. The video chat can be received through the method
     * getGroupCall
     */
    group_call_id: number,
    /** Invited user identifiers */
    user_ids: Array<number>,
  }

  export type messageBasicGroupChatCreate = {
    /** A newly created basic group */
    _: 'messageBasicGroupChatCreate',
    /** Title of the basic group */
    title: string,
    /** User identifiers of members in the basic group */
    member_user_ids: Array<number>,
  }

  export type messageSupergroupChatCreate = {
    /** A newly created supergroup or channel */
    _: 'messageSupergroupChatCreate',
    /** Title of the supergroup or channel */
    title: string,
  }

  export type messageChatChangeTitle = {
    /** An updated chat title */
    _: 'messageChatChangeTitle',
    /** New chat title */
    title: string,
  }

  export type messageChatChangePhoto = {
    /** An updated chat photo */
    _: 'messageChatChangePhoto',
    /** New chat photo */
    photo: chatPhoto,
  }

  export type messageChatDeletePhoto = {
    /** A deleted chat photo */
    _: 'messageChatDeletePhoto',
  }

  export type messageChatAddMembers = {
    /** New chat members were added */
    _: 'messageChatAddMembers',
    /** User identifiers of the new members */
    member_user_ids: Array<number>,
  }

  export type messageChatJoinByLink = {
    /** A new member joined the chat via an invite link */
    _: 'messageChatJoinByLink',
  }

  export type messageChatJoinByRequest = {
    /** A new member was accepted to the chat by an administrator */
    _: 'messageChatJoinByRequest',
  }

  export type messageChatDeleteMember = {
    /** A chat member was deleted */
    _: 'messageChatDeleteMember',
    /** User identifier of the deleted chat member */
    user_id: number,
  }

  export type messageChatUpgradeTo = {
    /** A basic group was upgraded to a supergroup and was deactivated as the result */
    _: 'messageChatUpgradeTo',
    /** Identifier of the supergroup to which the basic group was upgraded */
    supergroup_id: number,
  }

  export type messageChatUpgradeFrom = {
    /** A supergroup has been created from a basic group */
    _: 'messageChatUpgradeFrom',
    /** Title of the newly created supergroup */
    title: string,
    /** The identifier of the original basic group */
    basic_group_id: number,
  }

  export type messagePinMessage = {
    /** A message has been pinned */
    _: 'messagePinMessage',
    /**
     * Identifier of the pinned message, can be an identifier of a deleted message
     * or 0
     */
    message_id: number,
  }

  export type messageScreenshotTaken = {
    /** A screenshot of a message in the chat has been taken */
    _: 'messageScreenshotTaken',
  }

  export type messageChatSetBackground = {
    /** A new background was set in the chat */
    _: 'messageChatSetBackground',
    /**
     * Identifier of the message with a previously set same background; 0 if none.
     * Can be an identifier of a deleted message
     */
    old_background_message_id: number,
    /** The new background */
    background: chatBackground,
  }

  export type messageChatSetTheme = {
    /** A theme in the chat has been changed */
    _: 'messageChatSetTheme',
    /**
     * If non-empty, name of a new theme, set for the chat. Otherwise, chat theme was
     * reset to the default one
     */
    theme_name: string,
  }

  export type messageChatSetMessageAutoDeleteTime = {
    /** The auto-delete or self-destruct timer for messages in the chat has been changed */
    _: 'messageChatSetMessageAutoDeleteTime',
    /** New value auto-delete or self-destruct time, in seconds; 0 if disabled */
    message_auto_delete_time: number,
    /** If not 0, a user identifier, which default setting was automatically applied */
    from_user_id: number,
  }

  export type messageForumTopicCreated = {
    /** A forum topic has been created */
    _: 'messageForumTopicCreated',
    /** Name of the topic */
    name: string,
    /** Icon of the topic */
    icon: forumTopicIcon,
  }

  export type messageForumTopicEdited = {
    /** A forum topic has been edited */
    _: 'messageForumTopicEdited',
    /** If non-empty, the new name of the topic */
    name: string,
    /** True, if icon's custom_emoji_id is changed */
    edit_icon_custom_emoji_id: boolean,
    /**
     * New unique identifier of the custom emoji shown on the topic icon; 0 if none.
     * Must be ignored if edit_icon_custom_emoji_id is false
     */
    icon_custom_emoji_id: number | string,
  }

  export type messageForumTopicIsClosedToggled = {
    /** A forum topic has been closed or opened */
    _: 'messageForumTopicIsClosedToggled',
    /** True, if the topic was closed; otherwise, the topic was reopened */
    is_closed: boolean,
  }

  export type messageForumTopicIsHiddenToggled = {
    /** A General forum topic has been hidden or unhidden */
    _: 'messageForumTopicIsHiddenToggled',
    /** True, if the topic was hidden; otherwise, the topic was unhidden */
    is_hidden: boolean,
  }

  export type messageSuggestProfilePhoto = {
    /** A profile photo was suggested to a user in a private chat */
    _: 'messageSuggestProfilePhoto',
    /**
     * The suggested chat photo. Use the method setProfilePhoto with inputChatPhotoPrevious
     * to apply the photo
     */
    photo: chatPhoto,
  }

  export type messageCustomServiceAction = {
    /** A non-standard action has happened in the chat */
    _: 'messageCustomServiceAction',
    /** Message text to be shown in the chat */
    text: string,
  }

  export type messageGameScore = {
    /** A new high score was achieved in a game */
    _: 'messageGameScore',
    /** Identifier of the message with the game, can be an identifier of a deleted message */
    game_message_id: number,
    /**
     * Identifier of the game; may be different from the games presented in the message
     * with the game
     */
    game_id: number | string,
    /** New score */
    score: number,
  }

  export type messagePaymentSuccessful = {
    /** A payment has been completed */
    _: 'messagePaymentSuccessful',
    /** Identifier of the chat, containing the corresponding invoice message */
    invoice_chat_id: number,
    /**
     * Identifier of the message with the corresponding invoice; can be 0 or an identifier
     * of a deleted message
     */
    invoice_message_id: number,
    /** Currency for the price of the product */
    currency: string,
    /** Total price for the product, in the smallest units of the currency */
    total_amount: number,
    /** True, if this is a recurring payment */
    is_recurring: boolean,
    /** True, if this is the first recurring payment */
    is_first_recurring: boolean,
    /** Name of the invoice; may be empty if unknown */
    invoice_name: string,
  }

  export type messagePaymentSuccessfulBot = {
    /** A payment has been completed; for bots only */
    _: 'messagePaymentSuccessfulBot',
    /** Currency for price of the product */
    currency: string,
    /** Total price for the product, in the smallest units of the currency */
    total_amount: number,
    /** True, if this is a recurring payment */
    is_recurring: boolean,
    /** True, if this is the first recurring payment */
    is_first_recurring: boolean,
    /** Invoice payload */
    invoice_payload: string,
    /** Identifier of the shipping option chosen by the user; may be empty if not applicable */
    shipping_option_id: string,
    /** Information about the order; may be null */
    order_info?: orderInfo,
    /** Telegram payment identifier */
    telegram_payment_charge_id: string,
    /** Provider payment identifier */
    provider_payment_charge_id: string,
  }

  export type messageGiftedPremium = {
    /** Telegram Premium was gifted to the user */
    _: 'messageGiftedPremium',
    /** The identifier of a user that gifted Telegram Premium; 0 if the gift was anonymous */
    gifter_user_id: number,
    /** Currency for the paid amount */
    currency: string,
    /** The paid amount, in the smallest units of the currency */
    amount: number,
    /** Cryptocurrency used to pay for the gift; may be empty if none */
    cryptocurrency: string,
    /** The paid amount, in the smallest units of the cryptocurrency */
    cryptocurrency_amount: number | string,
    /** Number of month the Telegram Premium subscription will be active */
    month_count: number,
    /** A sticker to be shown in the message; may be null if unknown */
    sticker?: sticker,
  }

  export type messageContactRegistered = {
    /** A contact has registered with Telegram */
    _: 'messageContactRegistered',
  }

  export type messageUserShared = {
    /** The current user shared a user, which was requested by the bot */
    _: 'messageUserShared',
    /** Identifier of the shared user */
    user_id: number,
    /** Identifier of the keyboard button with the request */
    button_id: number,
  }

  export type messageChatShared = {
    /** The current user shared a chat, which was requested by the bot */
    _: 'messageChatShared',
    /** Identifier of the shared chat */
    chat_id: number,
    /** Identifier of the keyboard button with the request */
    button_id: number,
  }

  export type messageWebsiteConnected = {
    /**
     * The current user has connected a website by logging in using Telegram Login
     * Widget on it
     */
    _: 'messageWebsiteConnected',
    /** Domain name of the connected website */
    domain_name: string,
  }

  export type messageBotWriteAccessAllowed = {
    /** The user allowed the bot to send messages */
    _: 'messageBotWriteAccessAllowed',
    /**
     * Information about the Web App, which requested the access; may be null if none
     * or the Web App was opened from the attachment menu
     */
    web_app?: webApp,
    /** True, if user allowed the bot to send messages by an explicit call to allowBotToSendMessages */
    by_request: boolean,
  }

  export type messageWebAppDataSent = {
    /** Data from a Web App has been sent to a bot */
    _: 'messageWebAppDataSent',
    /** Text of the keyboardButtonTypeWebApp button, which opened the Web App */
    button_text: string,
  }

  export type messageWebAppDataReceived = {
    /** Data from a Web App has been received; for bots only */
    _: 'messageWebAppDataReceived',
    /** Text of the keyboardButtonTypeWebApp button, which opened the Web App */
    button_text: string,
    /** The data */
    data: string,
  }

  export type messagePassportDataSent = {
    /** Telegram Passport data has been sent to a bot */
    _: 'messagePassportDataSent',
    /** List of Telegram Passport element types sent */
    types: Array<PassportElementType>,
  }

  export type messagePassportDataReceived = {
    /** Telegram Passport data has been received; for bots only */
    _: 'messagePassportDataReceived',
    /** List of received Telegram Passport elements */
    elements: Array<encryptedPassportElement>,
    /** Encrypted data credentials */
    credentials: encryptedCredentials,
  }

  export type messageProximityAlertTriggered = {
    /** A user in the chat came within proximity alert range */
    _: 'messageProximityAlertTriggered',
    /** The identifier of a user or chat that triggered the proximity alert */
    traveler_id: MessageSender,
    /** The identifier of a user or chat that subscribed for the proximity alert */
    watcher_id: MessageSender,
    /** The distance between the users */
    distance: number,
  }

  export type messageUnsupported = {
    /** A message content that is not supported in the current TDLib version */
    _: 'messageUnsupported',
  }

  export type textEntityTypeMention = {
    /** A mention of a user, a supergroup, or a channel by their username */
    _: 'textEntityTypeMention',
  }

  export type textEntityTypeMention$Input = {
    /** A mention of a user, a supergroup, or a channel by their username */
    readonly _: 'textEntityTypeMention',
  }

  export type textEntityTypeHashtag = {
    /** A hashtag text, beginning with "#" */
    _: 'textEntityTypeHashtag',
  }

  export type textEntityTypeHashtag$Input = {
    /** A hashtag text, beginning with "#" */
    readonly _: 'textEntityTypeHashtag',
  }

  export type textEntityTypeCashtag = {
    /**
     * A cashtag text, beginning with "$" and consisting of capital English letters
     * (e.g., "$USD")
     */
    _: 'textEntityTypeCashtag',
  }

  export type textEntityTypeCashtag$Input = {
    /**
     * A cashtag text, beginning with "$" and consisting of capital English letters
     * (e.g., "$USD")
     */
    readonly _: 'textEntityTypeCashtag',
  }

  export type textEntityTypeBotCommand = {
    /** A bot command, beginning with "/" */
    _: 'textEntityTypeBotCommand',
  }

  export type textEntityTypeBotCommand$Input = {
    /** A bot command, beginning with "/" */
    readonly _: 'textEntityTypeBotCommand',
  }

  export type textEntityTypeUrl = {
    /** An HTTP URL */
    _: 'textEntityTypeUrl',
  }

  export type textEntityTypeUrl$Input = {
    /** An HTTP URL */
    readonly _: 'textEntityTypeUrl',
  }

  export type textEntityTypeEmailAddress = {
    /** An email address */
    _: 'textEntityTypeEmailAddress',
  }

  export type textEntityTypeEmailAddress$Input = {
    /** An email address */
    readonly _: 'textEntityTypeEmailAddress',
  }

  export type textEntityTypePhoneNumber = {
    /** A phone number */
    _: 'textEntityTypePhoneNumber',
  }

  export type textEntityTypePhoneNumber$Input = {
    /** A phone number */
    readonly _: 'textEntityTypePhoneNumber',
  }

  export type textEntityTypeBankCardNumber = {
    /**
     * A bank card number. The getBankCardInfo method can be used to get information
     * about the bank card
     */
    _: 'textEntityTypeBankCardNumber',
  }

  export type textEntityTypeBankCardNumber$Input = {
    /**
     * A bank card number. The getBankCardInfo method can be used to get information
     * about the bank card
     */
    readonly _: 'textEntityTypeBankCardNumber',
  }

  export type textEntityTypeBold = {
    /** A bold text */
    _: 'textEntityTypeBold',
  }

  export type textEntityTypeBold$Input = {
    /** A bold text */
    readonly _: 'textEntityTypeBold',
  }

  export type textEntityTypeItalic = {
    /** An italic text */
    _: 'textEntityTypeItalic',
  }

  export type textEntityTypeItalic$Input = {
    /** An italic text */
    readonly _: 'textEntityTypeItalic',
  }

  export type textEntityTypeUnderline = {
    /** An underlined text */
    _: 'textEntityTypeUnderline',
  }

  export type textEntityTypeUnderline$Input = {
    /** An underlined text */
    readonly _: 'textEntityTypeUnderline',
  }

  export type textEntityTypeStrikethrough = {
    /** A strikethrough text */
    _: 'textEntityTypeStrikethrough',
  }

  export type textEntityTypeStrikethrough$Input = {
    /** A strikethrough text */
    readonly _: 'textEntityTypeStrikethrough',
  }

  export type textEntityTypeSpoiler = {
    /** A spoiler text */
    _: 'textEntityTypeSpoiler',
  }

  export type textEntityTypeSpoiler$Input = {
    /** A spoiler text */
    readonly _: 'textEntityTypeSpoiler',
  }

  export type textEntityTypeCode = {
    /** Text that must be formatted as if inside a code HTML tag */
    _: 'textEntityTypeCode',
  }

  export type textEntityTypeCode$Input = {
    /** Text that must be formatted as if inside a code HTML tag */
    readonly _: 'textEntityTypeCode',
  }

  export type textEntityTypePre = {
    /** Text that must be formatted as if inside a pre HTML tag */
    _: 'textEntityTypePre',
  }

  export type textEntityTypePre$Input = {
    /** Text that must be formatted as if inside a pre HTML tag */
    readonly _: 'textEntityTypePre',
  }

  export type textEntityTypePreCode = {
    /** Text that must be formatted as if inside pre, and code HTML tags */
    _: 'textEntityTypePreCode',
    /** Programming language of the code; as defined by the sender */
    language: string,
  }

  export type textEntityTypePreCode$Input = {
    /** Text that must be formatted as if inside pre, and code HTML tags */
    readonly _: 'textEntityTypePreCode',
    /** Programming language of the code; as defined by the sender */
    readonly language?: string,
  }

  export type textEntityTypeTextUrl = {
    /** A text description shown instead of a raw URL */
    _: 'textEntityTypeTextUrl',
    /** HTTP or tg:// URL to be opened when the link is clicked */
    url: string,
  }

  export type textEntityTypeTextUrl$Input = {
    /** A text description shown instead of a raw URL */
    readonly _: 'textEntityTypeTextUrl',
    /** HTTP or tg:// URL to be opened when the link is clicked */
    readonly url?: string,
  }

  export type textEntityTypeMentionName = {
    /**
     * A text shows instead of a raw mention of the user (e.g., when the user has no
     * username)
     */
    _: 'textEntityTypeMentionName',
    /** Identifier of the mentioned user */
    user_id: number,
  }

  export type textEntityTypeMentionName$Input = {
    /**
     * A text shows instead of a raw mention of the user (e.g., when the user has no
     * username)
     */
    readonly _: 'textEntityTypeMentionName',
    /** Identifier of the mentioned user */
    readonly user_id?: number,
  }

  export type textEntityTypeCustomEmoji = {
    /**
     * A custom emoji. The text behind a custom emoji must be an emoji. Only premium
     * users can use premium custom emoji
     */
    _: 'textEntityTypeCustomEmoji',
    /** Unique identifier of the custom emoji */
    custom_emoji_id: number | string,
  }

  export type textEntityTypeCustomEmoji$Input = {
    /**
     * A custom emoji. The text behind a custom emoji must be an emoji. Only premium
     * users can use premium custom emoji
     */
    readonly _: 'textEntityTypeCustomEmoji',
    /** Unique identifier of the custom emoji */
    readonly custom_emoji_id?: number | string,
  }

  export type textEntityTypeMediaTimestamp = {
    /** A media timestamp */
    _: 'textEntityTypeMediaTimestamp',
    /**
     * Timestamp from which a video/audio/video note/voice note playing must start,
     * in seconds. The media can be in the content or the web page preview of the current
     * message, or in the same places in the replied message
     */
    media_timestamp: number,
  }

  export type textEntityTypeMediaTimestamp$Input = {
    /** A media timestamp */
    readonly _: 'textEntityTypeMediaTimestamp',
    /**
     * Timestamp from which a video/audio/video note/voice note playing must start,
     * in seconds. The media can be in the content or the web page preview of the current
     * message, or in the same places in the replied message
     */
    readonly media_timestamp?: number,
  }

  export type inputThumbnail = {
    /**
     * A thumbnail to be sent along with a file; must be in JPEG or WEBP format for
     * stickers, and less than 200 KB in size
     */
    _: 'inputThumbnail',
    /** Thumbnail file to send. Sending thumbnails by file_id is currently not supported */
    thumbnail: InputFile,
    /** Thumbnail width, usually shouldn't exceed 320. Use 0 if unknown */
    width: number,
    /** Thumbnail height, usually shouldn't exceed 320. Use 0 if unknown */
    height: number,
  }

  export type inputThumbnail$Input = {
    /**
     * A thumbnail to be sent along with a file; must be in JPEG or WEBP format for
     * stickers, and less than 200 KB in size
     */
    readonly _: 'inputThumbnail',
    /** Thumbnail file to send. Sending thumbnails by file_id is currently not supported */
    readonly thumbnail?: InputFile$Input,
    /** Thumbnail width, usually shouldn't exceed 320. Use 0 if unknown */
    readonly width?: number,
    /** Thumbnail height, usually shouldn't exceed 320. Use 0 if unknown */
    readonly height?: number,
  }

  export type messageSchedulingStateSendAtDate = {
    /** The message will be sent at the specified date */
    _: 'messageSchedulingStateSendAtDate',
    /**
     * Point in time (Unix timestamp) when the message will be sent. The date must
     * be within 367 days in the future
     */
    send_date: number,
  }

  export type messageSchedulingStateSendAtDate$Input = {
    /** The message will be sent at the specified date */
    readonly _: 'messageSchedulingStateSendAtDate',
    /**
     * Point in time (Unix timestamp) when the message will be sent. The date must
     * be within 367 days in the future
     */
    readonly send_date?: number,
  }

  export type messageSchedulingStateSendWhenOnline = {
    /**
     * The message will be sent when the peer will be online. Applicable to private
     * chats only and when the exact online status of the peer is known
     */
    _: 'messageSchedulingStateSendWhenOnline',
  }

  export type messageSchedulingStateSendWhenOnline$Input = {
    /**
     * The message will be sent when the peer will be online. Applicable to private
     * chats only and when the exact online status of the peer is known
     */
    readonly _: 'messageSchedulingStateSendWhenOnline',
  }

  export type messageSelfDestructTypeTimer = {
    /**
     * The message will be self-destructed in the specified time after its content
     * was opened
     */
    _: 'messageSelfDestructTypeTimer',
    /**
     * The message's self-destruct time, in seconds; must be between 0 and 60 in private
     * chats
     */
    self_destruct_time: number,
  }

  export type messageSelfDestructTypeTimer$Input = {
    /**
     * The message will be self-destructed in the specified time after its content
     * was opened
     */
    readonly _: 'messageSelfDestructTypeTimer',
    /**
     * The message's self-destruct time, in seconds; must be between 0 and 60 in private
     * chats
     */
    readonly self_destruct_time?: number,
  }

  export type messageSelfDestructTypeImmediately = {
    /** The message can be opened only once and will be self-destructed once closed */
    _: 'messageSelfDestructTypeImmediately',
  }

  export type messageSelfDestructTypeImmediately$Input = {
    /** The message can be opened only once and will be self-destructed once closed */
    readonly _: 'messageSelfDestructTypeImmediately',
  }

  export type messageSendOptions$Input = {
    /** Options to be used when a message is sent */
    readonly _: 'messageSendOptions',
    /** Pass true to disable notification for the message */
    readonly disable_notification?: boolean,
    /** Pass true if the message is sent from the background */
    readonly from_background?: boolean,
    /**
     * Pass true if the content of the message must be protected from forwarding and
     * saving; for bots only
     */
    readonly protect_content?: boolean,
    /**
     * Pass true if the user explicitly chosen a sticker or a custom emoji from an
     * installed sticker set; applicable only to sendMessage and sendMessageAlbum
     */
    readonly update_order_of_installed_sticker_sets?: boolean,
    /**
     * Message scheduling state; pass null to send message immediately. Messages sent
     * to a secret chat, live location messages and self-destructing messages can't
     * be scheduled
     */
    readonly scheduling_state?: MessageSchedulingState$Input,
    /**
     * Non-persistent identifier, which will be returned back in messageSendingStatePending
     * object and can be used to match sent messages and corresponding updateNewMessage
     * updates
     */
    readonly sending_id?: number,
  }

  export type messageCopyOptions = {
    /**
     * Options to be used when a message content is copied without reference to the
     * original sender. Service messages and messageInvoice can't be copied
     */
    _: 'messageCopyOptions',
    /**
     * True, if content of the message needs to be copied without reference to the
     * original sender. Always true if the message is forwarded to a secret chat or
     * is local
     */
    send_copy: boolean,
    /**
     * True, if media caption of the message copy needs to be replaced. Ignored if
     * send_copy is false
     */
    replace_caption: boolean,
    /**
     * New message caption; pass null to copy message without caption. Ignored if replace_caption
     * is false
     */
    new_caption: formattedText,
  }

  export type messageCopyOptions$Input = {
    /**
     * Options to be used when a message content is copied without reference to the
     * original sender. Service messages and messageInvoice can't be copied
     */
    readonly _: 'messageCopyOptions',
    /**
     * True, if content of the message needs to be copied without reference to the
     * original sender. Always true if the message is forwarded to a secret chat or
     * is local
     */
    readonly send_copy?: boolean,
    /**
     * True, if media caption of the message copy needs to be replaced. Ignored if
     * send_copy is false
     */
    readonly replace_caption?: boolean,
    /**
     * New message caption; pass null to copy message without caption. Ignored if replace_caption
     * is false
     */
    readonly new_caption?: formattedText$Input,
  }

  export type inputMessageText = {
    /** A text message */
    _: 'inputMessageText',
    /**
     * Formatted text to be sent; 1-getOption("message_text_length_max") characters.
     * Only Bold, Italic, Underline, Strikethrough, Spoiler, CustomEmoji, Code, Pre,
     * PreCode, TextUrl and MentionName entities are allowed to be specified manually
     */
    text: formattedText,
    /** True, if rich web page previews for URLs in the message text must be disabled */
    disable_web_page_preview: boolean,
    /** True, if a chat message draft must be deleted */
    clear_draft: boolean,
  }

  export type inputMessageText$Input = {
    /** A text message */
    readonly _: 'inputMessageText',
    /**
     * Formatted text to be sent; 1-getOption("message_text_length_max") characters.
     * Only Bold, Italic, Underline, Strikethrough, Spoiler, CustomEmoji, Code, Pre,
     * PreCode, TextUrl and MentionName entities are allowed to be specified manually
     */
    readonly text?: formattedText$Input,
    /** True, if rich web page previews for URLs in the message text must be disabled */
    readonly disable_web_page_preview?: boolean,
    /** True, if a chat message draft must be deleted */
    readonly clear_draft?: boolean,
  }

  export type inputMessageAnimation = {
    /** An animation message (GIF-style). */
    _: 'inputMessageAnimation',
    /** Animation file to be sent */
    animation: InputFile,
    /** Animation thumbnail; pass null to skip thumbnail uploading */
    thumbnail: inputThumbnail,
    /** File identifiers of the stickers added to the animation, if applicable */
    added_sticker_file_ids: Array<number>,
    /** Duration of the animation, in seconds */
    duration: number,
    /** Width of the animation; may be replaced by the server */
    width: number,
    /** Height of the animation; may be replaced by the server */
    height: number,
    /**
     * Animation caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    caption: formattedText,
    /**
     * True, if the animation preview must be covered by a spoiler animation; not supported
     * in secret chats
     */
    has_spoiler: boolean,
  }

  export type inputMessageAnimation$Input = {
    /** An animation message (GIF-style). */
    readonly _: 'inputMessageAnimation',
    /** Animation file to be sent */
    readonly animation?: InputFile$Input,
    /** Animation thumbnail; pass null to skip thumbnail uploading */
    readonly thumbnail?: inputThumbnail$Input,
    /** File identifiers of the stickers added to the animation, if applicable */
    readonly added_sticker_file_ids?: ReadonlyArray<number>,
    /** Duration of the animation, in seconds */
    readonly duration?: number,
    /** Width of the animation; may be replaced by the server */
    readonly width?: number,
    /** Height of the animation; may be replaced by the server */
    readonly height?: number,
    /**
     * Animation caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    readonly caption?: formattedText$Input,
    /**
     * True, if the animation preview must be covered by a spoiler animation; not supported
     * in secret chats
     */
    readonly has_spoiler?: boolean,
  }

  export type inputMessageAudio = {
    /** An audio message */
    _: 'inputMessageAudio',
    /** Audio file to be sent */
    audio: InputFile,
    /** Thumbnail of the cover for the album; pass null to skip thumbnail uploading */
    album_cover_thumbnail: inputThumbnail,
    /** Duration of the audio, in seconds; may be replaced by the server */
    duration: number,
    /** Title of the audio; 0-64 characters; may be replaced by the server */
    title: string,
    /** Performer of the audio; 0-64 characters, may be replaced by the server */
    performer: string,
    /**
     * Audio caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    caption: formattedText,
  }

  export type inputMessageAudio$Input = {
    /** An audio message */
    readonly _: 'inputMessageAudio',
    /** Audio file to be sent */
    readonly audio?: InputFile$Input,
    /** Thumbnail of the cover for the album; pass null to skip thumbnail uploading */
    readonly album_cover_thumbnail?: inputThumbnail$Input,
    /** Duration of the audio, in seconds; may be replaced by the server */
    readonly duration?: number,
    /** Title of the audio; 0-64 characters; may be replaced by the server */
    readonly title?: string,
    /** Performer of the audio; 0-64 characters, may be replaced by the server */
    readonly performer?: string,
    /**
     * Audio caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    readonly caption?: formattedText$Input,
  }

  export type inputMessageDocument = {
    /** A document message (general file) */
    _: 'inputMessageDocument',
    /** Document to be sent */
    document: InputFile,
    /** Document thumbnail; pass null to skip thumbnail uploading */
    thumbnail: inputThumbnail,
    /**
     * If true, automatic file type detection will be disabled and the document will
     * always be sent as file. Always true for files sent to secret chats
     */
    disable_content_type_detection: boolean,
    /**
     * Document caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    caption: formattedText,
  }

  export type inputMessageDocument$Input = {
    /** A document message (general file) */
    readonly _: 'inputMessageDocument',
    /** Document to be sent */
    readonly document?: InputFile$Input,
    /** Document thumbnail; pass null to skip thumbnail uploading */
    readonly thumbnail?: inputThumbnail$Input,
    /**
     * If true, automatic file type detection will be disabled and the document will
     * always be sent as file. Always true for files sent to secret chats
     */
    readonly disable_content_type_detection?: boolean,
    /**
     * Document caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    readonly caption?: formattedText$Input,
  }

  export type inputMessagePhoto = {
    /** A photo message */
    _: 'inputMessagePhoto',
    /**
     * Photo to send. The photo must be at most 10 MB in size. The photo's width and
     * height must not exceed 10000 in total. Width and height ratio must be at most
     * 20
     */
    photo: InputFile,
    /**
     * Photo thumbnail to be sent; pass null to skip thumbnail uploading. The thumbnail
     * is sent to the other party only in secret chats
     */
    thumbnail: inputThumbnail,
    /** File identifiers of the stickers added to the photo, if applicable */
    added_sticker_file_ids: Array<number>,
    /** Photo width */
    width: number,
    /** Photo height */
    height: number,
    /**
     * Photo caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    caption: formattedText,
    /** Photo self-destruct type; pass null if none; private chats only */
    self_destruct_type: MessageSelfDestructType,
    /**
     * True, if the photo preview must be covered by a spoiler animation; not supported
     * in secret chats
     */
    has_spoiler: boolean,
  }

  export type inputMessagePhoto$Input = {
    /** A photo message */
    readonly _: 'inputMessagePhoto',
    /**
     * Photo to send. The photo must be at most 10 MB in size. The photo's width and
     * height must not exceed 10000 in total. Width and height ratio must be at most
     * 20
     */
    readonly photo?: InputFile$Input,
    /**
     * Photo thumbnail to be sent; pass null to skip thumbnail uploading. The thumbnail
     * is sent to the other party only in secret chats
     */
    readonly thumbnail?: inputThumbnail$Input,
    /** File identifiers of the stickers added to the photo, if applicable */
    readonly added_sticker_file_ids?: ReadonlyArray<number>,
    /** Photo width */
    readonly width?: number,
    /** Photo height */
    readonly height?: number,
    /**
     * Photo caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    readonly caption?: formattedText$Input,
    /** Photo self-destruct type; pass null if none; private chats only */
    readonly self_destruct_type?: MessageSelfDestructType$Input,
    /**
     * True, if the photo preview must be covered by a spoiler animation; not supported
     * in secret chats
     */
    readonly has_spoiler?: boolean,
  }

  export type inputMessageSticker = {
    /** A sticker message */
    _: 'inputMessageSticker',
    /** Sticker to be sent */
    sticker: InputFile,
    /** Sticker thumbnail; pass null to skip thumbnail uploading */
    thumbnail: inputThumbnail,
    /** Sticker width */
    width: number,
    /** Sticker height */
    height: number,
    /** Emoji used to choose the sticker */
    emoji: string,
  }

  export type inputMessageSticker$Input = {
    /** A sticker message */
    readonly _: 'inputMessageSticker',
    /** Sticker to be sent */
    readonly sticker?: InputFile$Input,
    /** Sticker thumbnail; pass null to skip thumbnail uploading */
    readonly thumbnail?: inputThumbnail$Input,
    /** Sticker width */
    readonly width?: number,
    /** Sticker height */
    readonly height?: number,
    /** Emoji used to choose the sticker */
    readonly emoji?: string,
  }

  export type inputMessageVideo = {
    /** A video message */
    _: 'inputMessageVideo',
    /** Video to be sent */
    video: InputFile,
    /** Video thumbnail; pass null to skip thumbnail uploading */
    thumbnail: inputThumbnail,
    /** File identifiers of the stickers added to the video, if applicable */
    added_sticker_file_ids: Array<number>,
    /** Duration of the video, in seconds */
    duration: number,
    /** Video width */
    width: number,
    /** Video height */
    height: number,
    /** True, if the video is supposed to be streamed */
    supports_streaming: boolean,
    /**
     * Video caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    caption: formattedText,
    /** Video self-destruct type; pass null if none; private chats only */
    self_destruct_type: MessageSelfDestructType,
    /**
     * True, if the video preview must be covered by a spoiler animation; not supported
     * in secret chats
     */
    has_spoiler: boolean,
  }

  export type inputMessageVideo$Input = {
    /** A video message */
    readonly _: 'inputMessageVideo',
    /** Video to be sent */
    readonly video?: InputFile$Input,
    /** Video thumbnail; pass null to skip thumbnail uploading */
    readonly thumbnail?: inputThumbnail$Input,
    /** File identifiers of the stickers added to the video, if applicable */
    readonly added_sticker_file_ids?: ReadonlyArray<number>,
    /** Duration of the video, in seconds */
    readonly duration?: number,
    /** Video width */
    readonly width?: number,
    /** Video height */
    readonly height?: number,
    /** True, if the video is supposed to be streamed */
    readonly supports_streaming?: boolean,
    /**
     * Video caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    readonly caption?: formattedText$Input,
    /** Video self-destruct type; pass null if none; private chats only */
    readonly self_destruct_type?: MessageSelfDestructType$Input,
    /**
     * True, if the video preview must be covered by a spoiler animation; not supported
     * in secret chats
     */
    readonly has_spoiler?: boolean,
  }

  export type inputMessageVideoNote = {
    /** A video note message */
    _: 'inputMessageVideoNote',
    /** Video note to be sent */
    video_note: InputFile,
    /** Video thumbnail; pass null to skip thumbnail uploading */
    thumbnail: inputThumbnail,
    /** Duration of the video, in seconds */
    duration: number,
    /** Video width and height; must be positive and not greater than 640 */
    length: number,
  }

  export type inputMessageVideoNote$Input = {
    /** A video note message */
    readonly _: 'inputMessageVideoNote',
    /** Video note to be sent */
    readonly video_note?: InputFile$Input,
    /** Video thumbnail; pass null to skip thumbnail uploading */
    readonly thumbnail?: inputThumbnail$Input,
    /** Duration of the video, in seconds */
    readonly duration?: number,
    /** Video width and height; must be positive and not greater than 640 */
    readonly length?: number,
  }

  export type inputMessageVoiceNote = {
    /** A voice note message */
    _: 'inputMessageVoiceNote',
    /** Voice note to be sent */
    voice_note: InputFile,
    /** Duration of the voice note, in seconds */
    duration: number,
    /** Waveform representation of the voice note in 5-bit format */
    waveform: string,
    /**
     * Voice note caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    caption: formattedText,
  }

  export type inputMessageVoiceNote$Input = {
    /** A voice note message */
    readonly _: 'inputMessageVoiceNote',
    /** Voice note to be sent */
    readonly voice_note?: InputFile$Input,
    /** Duration of the voice note, in seconds */
    readonly duration?: number,
    /** Waveform representation of the voice note in 5-bit format */
    readonly waveform?: string,
    /**
     * Voice note caption; pass null to use an empty caption; 0-getOption("message_caption_length_max")
     * characters
     */
    readonly caption?: formattedText$Input,
  }

  export type inputMessageLocation = {
    /** A message with a location */
    _: 'inputMessageLocation',
    /** Location to be sent */
    location: location,
    /**
     * Period for which the location can be updated, in seconds; must be between 60
     * and 86400 for a live location and 0 otherwise
     */
    live_period: number,
    /**
     * For live locations, a direction in which the location moves, in degrees; 1-360.
     * Pass 0 if unknown
     */
    heading: number,
    /**
     * For live locations, a maximum distance to another chat member for proximity
     * alerts, in meters (0-100000). Pass 0 if the notification is disabled. Can't
     * be enabled in channels and Saved Messages
     */
    proximity_alert_radius: number,
  }

  export type inputMessageLocation$Input = {
    /** A message with a location */
    readonly _: 'inputMessageLocation',
    /** Location to be sent */
    readonly location?: location$Input,
    /**
     * Period for which the location can be updated, in seconds; must be between 60
     * and 86400 for a live location and 0 otherwise
     */
    readonly live_period?: number,
    /**
     * For live locations, a direction in which the location moves, in degrees; 1-360.
     * Pass 0 if unknown
     */
    readonly heading?: number,
    /**
     * For live locations, a maximum distance to another chat member for proximity
     * alerts, in meters (0-100000). Pass 0 if the notification is disabled. Can't
     * be enabled in channels and Saved Messages
     */
    readonly proximity_alert_radius?: number,
  }

  export type inputMessageVenue = {
    /** A message with information about a venue */
    _: 'inputMessageVenue',
    /** Venue to send */
    venue: venue,
  }

  export type inputMessageVenue$Input = {
    /** A message with information about a venue */
    readonly _: 'inputMessageVenue',
    /** Venue to send */
    readonly venue?: venue$Input,
  }

  export type inputMessageContact = {
    /** A message containing a user contact */
    _: 'inputMessageContact',
    /** Contact to send */
    contact: contact,
  }

  export type inputMessageContact$Input = {
    /** A message containing a user contact */
    readonly _: 'inputMessageContact',
    /** Contact to send */
    readonly contact?: contact$Input,
  }

  export type inputMessageDice = {
    /** A dice message */
    _: 'inputMessageDice',
    /** Emoji on which the dice throw animation is based */
    emoji: string,
    /** True, if the chat message draft must be deleted */
    clear_draft: boolean,
  }

  export type inputMessageDice$Input = {
    /** A dice message */
    readonly _: 'inputMessageDice',
    /** Emoji on which the dice throw animation is based */
    readonly emoji?: string,
    /** True, if the chat message draft must be deleted */
    readonly clear_draft?: boolean,
  }

  export type inputMessageGame = {
    /** A message with a game; not supported for channels or secret chats */
    _: 'inputMessageGame',
    /** User identifier of the bot that owns the game */
    bot_user_id: number,
    /** Short name of the game */
    game_short_name: string,
  }

  export type inputMessageGame$Input = {
    /** A message with a game; not supported for channels or secret chats */
    readonly _: 'inputMessageGame',
    /** User identifier of the bot that owns the game */
    readonly bot_user_id?: number,
    /** Short name of the game */
    readonly game_short_name?: string,
  }

  export type inputMessageInvoice = {
    /** A message with an invoice; can be used only by bots */
    _: 'inputMessageInvoice',
    /** Invoice */
    invoice: invoice,
    /** Product title; 1-32 characters */
    title: string,
    /** Product description; 0-255 characters */
    description: string,
    /** Product photo URL; optional */
    photo_url: string,
    /** Product photo size */
    photo_size: number,
    /** Product photo width */
    photo_width: number,
    /** Product photo height */
    photo_height: number,
    /** The invoice payload */
    payload: string,
    /** Payment provider token */
    provider_token: string,
    /** JSON-encoded data about the invoice, which will be shared with the payment provider */
    provider_data: string,
    /**
     * Unique invoice bot deep link parameter for the generation of this invoice. If
     * empty, it would be possible to pay directly from forwards of the invoice message
     */
    start_parameter: string,
    /**
     * The content of extended media attached to the invoice. The content of the message
     * to be sent. Must be one of the following types: inputMessagePhoto, inputMessageVideo
     */
    extended_media_content: InputMessageContent,
  }

  export type inputMessageInvoice$Input = {
    /** A message with an invoice; can be used only by bots */
    readonly _: 'inputMessageInvoice',
    /** Invoice */
    readonly invoice?: invoice$Input,
    /** Product title; 1-32 characters */
    readonly title?: string,
    /** Product description; 0-255 characters */
    readonly description?: string,
    /** Product photo URL; optional */
    readonly photo_url?: string,
    /** Product photo size */
    readonly photo_size?: number,
    /** Product photo width */
    readonly photo_width?: number,
    /** Product photo height */
    readonly photo_height?: number,
    /** The invoice payload */
    readonly payload?: string,
    /** Payment provider token */
    readonly provider_token?: string,
    /** JSON-encoded data about the invoice, which will be shared with the payment provider */
    readonly provider_data?: string,
    /**
     * Unique invoice bot deep link parameter for the generation of this invoice. If
     * empty, it would be possible to pay directly from forwards of the invoice message
     */
    readonly start_parameter?: string,
    /**
     * The content of extended media attached to the invoice. The content of the message
     * to be sent. Must be one of the following types: inputMessagePhoto, inputMessageVideo
     */
    readonly extended_media_content?: InputMessageContent$Input,
  }

  export type inputMessagePoll = {
    /**
     * A message with a poll. Polls can't be sent to secret chats. Polls can be sent
     * only to a private chat with a bot
     */
    _: 'inputMessagePoll',
    /** Poll question; 1-255 characters (up to 300 characters for bots) */
    question: string,
    /** List of poll answer options, 2-10 strings 1-100 characters each */
    options: Array<string>,
    /**
     * True, if the poll voters are anonymous. Non-anonymous polls can't be sent or
     * forwarded to channels
     */
    is_anonymous: boolean,
    /** Type of the poll */
    type: PollType,
    /**
     * Amount of time the poll will be active after creation, in seconds; for bots
     * only
     */
    open_period: number,
    /**
     * Point in time (Unix timestamp) when the poll will automatically be closed; for
     * bots only
     */
    close_date: number,
    /** True, if the poll needs to be sent already closed; for bots only */
    is_closed: boolean,
  }

  export type inputMessagePoll$Input = {
    /**
     * A message with a poll. Polls can't be sent to secret chats. Polls can be sent
     * only to a private chat with a bot
     */
    readonly _: 'inputMessagePoll',
    /** Poll question; 1-255 characters (up to 300 characters for bots) */
    readonly question?: string,
    /** List of poll answer options, 2-10 strings 1-100 characters each */
    readonly options?: ReadonlyArray<string>,
    /**
     * True, if the poll voters are anonymous. Non-anonymous polls can't be sent or
     * forwarded to channels
     */
    readonly is_anonymous?: boolean,
    /** Type of the poll */
    readonly type?: PollType$Input,
    /**
     * Amount of time the poll will be active after creation, in seconds; for bots
     * only
     */
    readonly open_period?: number,
    /**
     * Point in time (Unix timestamp) when the poll will automatically be closed; for
     * bots only
     */
    readonly close_date?: number,
    /** True, if the poll needs to be sent already closed; for bots only */
    readonly is_closed?: boolean,
  }

  export type inputMessageStory = {
    /**
     * A message with a forwarded story. Stories can't be sent to secret chats. A story
     * can be forwarded only if story.can_be_forwarded
     */
    _: 'inputMessageStory',
    /** Identifier of the chat that posted the story */
    story_sender_chat_id: number,
    /** Story identifier */
    story_id: number,
  }

  export type inputMessageStory$Input = {
    /**
     * A message with a forwarded story. Stories can't be sent to secret chats. A story
     * can be forwarded only if story.can_be_forwarded
     */
    readonly _: 'inputMessageStory',
    /** Identifier of the chat that posted the story */
    readonly story_sender_chat_id?: number,
    /** Story identifier */
    readonly story_id?: number,
  }

  export type inputMessageForwarded = {
    /** A forwarded message */
    _: 'inputMessageForwarded',
    /** Identifier for the chat this forwarded message came from */
    from_chat_id: number,
    /** Identifier of the message to forward */
    message_id: number,
    /**
     * True, if a game message is being shared from a launched game; applies only to
     * game messages
     */
    in_game_share: boolean,
    /**
     * Options to be used to copy content of the message without reference to the original
     * sender; pass null to forward the message as usual
     */
    copy_options: messageCopyOptions,
  }

  export type inputMessageForwarded$Input = {
    /** A forwarded message */
    readonly _: 'inputMessageForwarded',
    /** Identifier for the chat this forwarded message came from */
    readonly from_chat_id?: number,
    /** Identifier of the message to forward */
    readonly message_id?: number,
    /**
     * True, if a game message is being shared from a launched game; applies only to
     * game messages
     */
    readonly in_game_share?: boolean,
    /**
     * Options to be used to copy content of the message without reference to the original
     * sender; pass null to forward the message as usual
     */
    readonly copy_options?: messageCopyOptions$Input,
  }

  export type searchMessagesFilterEmpty$Input = {
    /** Returns all found messages, no filter is applied */
    readonly _: 'searchMessagesFilterEmpty',
  }

  export type searchMessagesFilterAnimation$Input = {
    /** Returns only animation messages */
    readonly _: 'searchMessagesFilterAnimation',
  }

  export type searchMessagesFilterAudio$Input = {
    /** Returns only audio messages */
    readonly _: 'searchMessagesFilterAudio',
  }

  export type searchMessagesFilterDocument$Input = {
    /** Returns only document messages */
    readonly _: 'searchMessagesFilterDocument',
  }

  export type searchMessagesFilterPhoto$Input = {
    /** Returns only photo messages */
    readonly _: 'searchMessagesFilterPhoto',
  }

  export type searchMessagesFilterVideo$Input = {
    /** Returns only video messages */
    readonly _: 'searchMessagesFilterVideo',
  }

  export type searchMessagesFilterVoiceNote$Input = {
    /** Returns only voice note messages */
    readonly _: 'searchMessagesFilterVoiceNote',
  }

  export type searchMessagesFilterPhotoAndVideo$Input = {
    /** Returns only photo and video messages */
    readonly _: 'searchMessagesFilterPhotoAndVideo',
  }

  export type searchMessagesFilterUrl$Input = {
    /** Returns only messages containing URLs */
    readonly _: 'searchMessagesFilterUrl',
  }

  export type searchMessagesFilterChatPhoto$Input = {
    /** Returns only messages containing chat photos */
    readonly _: 'searchMessagesFilterChatPhoto',
  }

  export type searchMessagesFilterVideoNote$Input = {
    /** Returns only video note messages */
    readonly _: 'searchMessagesFilterVideoNote',
  }

  export type searchMessagesFilterVoiceAndVideoNote$Input = {
    /** Returns only voice and video note messages */
    readonly _: 'searchMessagesFilterVoiceAndVideoNote',
  }

  export type searchMessagesFilterMention$Input = {
    /**
     * Returns only messages with mentions of the current user, or messages that are
     * replies to their messages
     */
    readonly _: 'searchMessagesFilterMention',
  }

  export type searchMessagesFilterUnreadMention$Input = {
    /**
     * Returns only messages with unread mentions of the current user, or messages
     * that are replies to their messages. When using this filter the results can't
     * be additionally filtered by a query, a message thread or by the sending user
     */
    readonly _: 'searchMessagesFilterUnreadMention',
  }

  export type searchMessagesFilterUnreadReaction$Input = {
    /**
     * Returns only messages with unread reactions for the current user. When using
     * this filter the results can't be additionally filtered by a query, a message
     * thread or by the sending user
     */
    readonly _: 'searchMessagesFilterUnreadReaction',
  }

  export type searchMessagesFilterFailedToSend$Input = {
    /**
     * Returns only failed to send messages. This filter can be used only if the message
     * database is used
     */
    readonly _: 'searchMessagesFilterFailedToSend',
  }

  export type searchMessagesFilterPinned$Input = {
    /** Returns only pinned messages */
    readonly _: 'searchMessagesFilterPinned',
  }

  export type chatActionTyping = {
    /** The user is typing a message */
    _: 'chatActionTyping',
  }

  export type chatActionTyping$Input = {
    /** The user is typing a message */
    readonly _: 'chatActionTyping',
  }

  export type chatActionRecordingVideo = {
    /** The user is recording a video */
    _: 'chatActionRecordingVideo',
  }

  export type chatActionRecordingVideo$Input = {
    /** The user is recording a video */
    readonly _: 'chatActionRecordingVideo',
  }

  export type chatActionUploadingVideo = {
    /** The user is uploading a video */
    _: 'chatActionUploadingVideo',
    /** Upload progress, as a percentage */
    progress: number,
  }

  export type chatActionUploadingVideo$Input = {
    /** The user is uploading a video */
    readonly _: 'chatActionUploadingVideo',
    /** Upload progress, as a percentage */
    readonly progress?: number,
  }

  export type chatActionRecordingVoiceNote = {
    /** The user is recording a voice note */
    _: 'chatActionRecordingVoiceNote',
  }

  export type chatActionRecordingVoiceNote$Input = {
    /** The user is recording a voice note */
    readonly _: 'chatActionRecordingVoiceNote',
  }

  export type chatActionUploadingVoiceNote = {
    /** The user is uploading a voice note */
    _: 'chatActionUploadingVoiceNote',
    /** Upload progress, as a percentage */
    progress: number,
  }

  export type chatActionUploadingVoiceNote$Input = {
    /** The user is uploading a voice note */
    readonly _: 'chatActionUploadingVoiceNote',
    /** Upload progress, as a percentage */
    readonly progress?: number,
  }

  export type chatActionUploadingPhoto = {
    /** The user is uploading a photo */
    _: 'chatActionUploadingPhoto',
    /** Upload progress, as a percentage */
    progress: number,
  }

  export type chatActionUploadingPhoto$Input = {
    /** The user is uploading a photo */
    readonly _: 'chatActionUploadingPhoto',
    /** Upload progress, as a percentage */
    readonly progress?: number,
  }

  export type chatActionUploadingDocument = {
    /** The user is uploading a document */
    _: 'chatActionUploadingDocument',
    /** Upload progress, as a percentage */
    progress: number,
  }

  export type chatActionUploadingDocument$Input = {
    /** The user is uploading a document */
    readonly _: 'chatActionUploadingDocument',
    /** Upload progress, as a percentage */
    readonly progress?: number,
  }

  export type chatActionChoosingSticker = {
    /** The user is picking a sticker to send */
    _: 'chatActionChoosingSticker',
  }

  export type chatActionChoosingSticker$Input = {
    /** The user is picking a sticker to send */
    readonly _: 'chatActionChoosingSticker',
  }

  export type chatActionChoosingLocation = {
    /** The user is picking a location or venue to send */
    _: 'chatActionChoosingLocation',
  }

  export type chatActionChoosingLocation$Input = {
    /** The user is picking a location or venue to send */
    readonly _: 'chatActionChoosingLocation',
  }

  export type chatActionChoosingContact = {
    /** The user is picking a contact to send */
    _: 'chatActionChoosingContact',
  }

  export type chatActionChoosingContact$Input = {
    /** The user is picking a contact to send */
    readonly _: 'chatActionChoosingContact',
  }

  export type chatActionStartPlayingGame = {
    /** The user has started to play a game */
    _: 'chatActionStartPlayingGame',
  }

  export type chatActionStartPlayingGame$Input = {
    /** The user has started to play a game */
    readonly _: 'chatActionStartPlayingGame',
  }

  export type chatActionRecordingVideoNote = {
    /** The user is recording a video note */
    _: 'chatActionRecordingVideoNote',
  }

  export type chatActionRecordingVideoNote$Input = {
    /** The user is recording a video note */
    readonly _: 'chatActionRecordingVideoNote',
  }

  export type chatActionUploadingVideoNote = {
    /** The user is uploading a video note */
    _: 'chatActionUploadingVideoNote',
    /** Upload progress, as a percentage */
    progress: number,
  }

  export type chatActionUploadingVideoNote$Input = {
    /** The user is uploading a video note */
    readonly _: 'chatActionUploadingVideoNote',
    /** Upload progress, as a percentage */
    readonly progress?: number,
  }

  export type chatActionWatchingAnimations = {
    /**
     * The user is watching animations sent by the other party by clicking on an animated
     * emoji
     */
    _: 'chatActionWatchingAnimations',
    /** The animated emoji */
    emoji: string,
  }

  export type chatActionWatchingAnimations$Input = {
    /**
     * The user is watching animations sent by the other party by clicking on an animated
     * emoji
     */
    readonly _: 'chatActionWatchingAnimations',
    /** The animated emoji */
    readonly emoji?: string,
  }

  export type chatActionCancel = {
    /** The user has canceled the previous action */
    _: 'chatActionCancel',
  }

  export type chatActionCancel$Input = {
    /** The user has canceled the previous action */
    readonly _: 'chatActionCancel',
  }

  export type userStatusEmpty = {
    /** The user status was never changed */
    _: 'userStatusEmpty',
  }

  export type userStatusOnline = {
    /** The user is online */
    _: 'userStatusOnline',
    /** Point in time (Unix timestamp) when the user's online status will expire */
    expires: number,
  }

  export type userStatusOffline = {
    /** The user is offline */
    _: 'userStatusOffline',
    /** Point in time (Unix timestamp) when the user was last online */
    was_online: number,
  }

  export type userStatusRecently = {
    /** The user was online recently */
    _: 'userStatusRecently',
  }

  export type userStatusLastWeek = {
    /** The user is offline, but was online last week */
    _: 'userStatusLastWeek',
  }

  export type userStatusLastMonth = {
    /** The user is offline, but was online last month */
    _: 'userStatusLastMonth',
  }

  export type stickers = {
    /** Represents a list of stickers */
    _: 'stickers',
    /** List of stickers */
    stickers: Array<sticker>,
  }

  export type emojis = {
    /** Represents a list of emoji */
    _: 'emojis',
    /** List of emojis */
    emojis: Array<string>,
  }

  export type stickerSet = {
    /** Represents a sticker set */
    _: 'stickerSet',
    /** Identifier of the sticker set */
    id: number | string,
    /** Title of the sticker set */
    title: string,
    /** Name of the sticker set */
    name: string,
    /**
     * Sticker set thumbnail in WEBP, TGS, or WEBM format with width and height 100;
     * may be null. The file can be downloaded only before the thumbnail is changed
     */
    thumbnail?: thumbnail,
    /**
     * Sticker set thumbnail's outline represented as a list of closed vector paths;
     * may be empty. The coordinate system origin is in the upper-left corner
     */
    thumbnail_outline: Array<closedVectorPath>,
    /** True, if the sticker set has been installed by the current user */
    is_installed: boolean,
    /**
     * True, if the sticker set has been archived. A sticker set can't be installed
     * and archived simultaneously
     */
    is_archived: boolean,
    /** True, if the sticker set is official */
    is_official: boolean,
    /** Format of the stickers in the set */
    sticker_format: StickerFormat,
    /** Type of the stickers in the set */
    sticker_type: StickerType,
    /** True for already viewed trending sticker sets */
    is_viewed: boolean,
    /** List of stickers in this set */
    stickers: Array<sticker>,
    /**
     * A list of emoji corresponding to the stickers in the same order. The list is
     * only for informational purposes, because a sticker is always sent with a fixed
     * emoji from the corresponding Sticker object
     */
    emojis: Array<emojis>,
  }

  export type stickerSetInfo = {
    /** Represents short information about a sticker set */
    _: 'stickerSetInfo',
    /** Identifier of the sticker set */
    id: number | string,
    /** Title of the sticker set */
    title: string,
    /** Name of the sticker set */
    name: string,
    /**
     * Sticker set thumbnail in WEBP, TGS, or WEBM format with width and height 100;
     * may be null
     */
    thumbnail?: thumbnail,
    /**
     * Sticker set thumbnail's outline represented as a list of closed vector paths;
     * may be empty. The coordinate system origin is in the upper-left corner
     */
    thumbnail_outline: Array<closedVectorPath>,
    /** True, if the sticker set has been installed by the current user */
    is_installed: boolean,
    /**
     * True, if the sticker set has been archived. A sticker set can't be installed
     * and archived simultaneously
     */
    is_archived: boolean,
    /** True, if the sticker set is official */
    is_official: boolean,
    /** Format of the stickers in the set */
    sticker_format: StickerFormat,
    /** Type of the stickers in the set */
    sticker_type: StickerType,
    /** True for already viewed trending sticker sets */
    is_viewed: boolean,
    /** Total number of stickers in the set */
    size: number,
    /**
     * Up to the first 5 stickers from the set, depending on the context. If the application
     * needs more stickers the full sticker set needs to be requested
     */
    covers: Array<sticker>,
  }

  export type stickerSets = {
    /** Represents a list of sticker sets */
    _: 'stickerSets',
    /** Approximate total number of sticker sets found */
    total_count: number,
    /** List of sticker sets */
    sets: Array<stickerSetInfo>,
  }

  export type trendingStickerSets = {
    /** Represents a list of trending sticker sets */
    _: 'trendingStickerSets',
    /** Approximate total number of trending sticker sets */
    total_count: number,
    /** List of trending sticker sets */
    sets: Array<stickerSetInfo>,
    /** True, if the list contains sticker sets with premium stickers */
    is_premium: boolean,
  }

  export type emojiCategory = {
    /** Contains a list of similar emoji to search for in getStickers and searchStickers */
    _: 'emojiCategory',
    /** Name of the category */
    name: string,
    /** Custom emoji sticker, which represents icon of the category */
    icon: sticker,
    /** List of emojis in the category */
    emojis: Array<string>,
  }

  export type emojiCategories = {
    /** Represents a list of emoji categories */
    _: 'emojiCategories',
    /** List of categories */
    categories: Array<emojiCategory>,
  }

  export type emojiCategoryTypeDefault$Input = {
    /** The category must be used by default */
    readonly _: 'emojiCategoryTypeDefault',
  }

  export type emojiCategoryTypeEmojiStatus$Input = {
    /** The category must be used for emoji status selection */
    readonly _: 'emojiCategoryTypeEmojiStatus',
  }

  export type emojiCategoryTypeChatPhoto$Input = {
    /** The category must be used for chat photo emoji selection */
    readonly _: 'emojiCategoryTypeChatPhoto',
  }

  export type storyViewer = {
    /** Represents a viewer of a story */
    _: 'storyViewer',
    /** User identifier of the viewer */
    user_id: number,
    /** Approximate point in time (Unix timestamp) when the story was viewed */
    view_date: number,
    /** Block list to which the user is added; may be null if none */
    block_list?: BlockList,
    /** Type of the reaction that was chosen by the user; may be null if none */
    chosen_reaction_type?: ReactionType,
  }

  export type storyViewers = {
    /** Represents a list of story viewers */
    _: 'storyViewers',
    /** Approximate total number of story viewers found */
    total_count: number,
    /** Approximate total number of reactions set by found story viewers */
    total_reaction_count: number,
    /** List of story viewers */
    viewers: Array<storyViewer>,
    /** The offset for the next request. If empty, there are no more results */
    next_offset: string,
  }

  export type storyAreaPosition = {
    /** Describes position of a clickable rectangle area on a story media */
    _: 'storyAreaPosition',
    /** The abscissa of the rectangle's center, as a percentage of the media width */
    x_percentage: number,
    /** The ordinate of the rectangle's center, as a percentage of the media height */
    y_percentage: number,
    /** The width of the rectangle, as a percentage of the media width */
    width_percentage: number,
    /** The ordinate of the rectangle's center, as a percentage of the media height */
    height_percentage: number,
    /** Clockwise rotation angle of the rectangle, in degrees; 0-360 */
    rotation_angle: number,
  }

  export type storyAreaPosition$Input = {
    /** Describes position of a clickable rectangle area on a story media */
    readonly _: 'storyAreaPosition',
    /** The abscissa of the rectangle's center, as a percentage of the media width */
    readonly x_percentage?: number,
    /** The ordinate of the rectangle's center, as a percentage of the media height */
    readonly y_percentage?: number,
    /** The width of the rectangle, as a percentage of the media width */
    readonly width_percentage?: number,
    /** The ordinate of the rectangle's center, as a percentage of the media height */
    readonly height_percentage?: number,
    /** Clockwise rotation angle of the rectangle, in degrees; 0-360 */
    readonly rotation_angle?: number,
  }

  export type storyAreaTypeLocation = {
    /** An area pointing to a location */
    _: 'storyAreaTypeLocation',
    /** The location */
    location: location,
  }

  export type storyAreaTypeVenue = {
    /** An area pointing to a venue */
    _: 'storyAreaTypeVenue',
    /** Information about the venue */
    venue: venue,
  }

  export type storyAreaTypeSuggestedReaction = {
    /**
     * An area pointing to a suggested reaction. App needs to show a clickable reaction
     * on the area and call setStoryReaction when the are is clicked
     */
    _: 'storyAreaTypeSuggestedReaction',
    /** Type of the reaction */
    reaction_type: ReactionType,
    /** Number of times the reaction was added */
    total_count: number,
    /** True, if reaction has a dark background */
    is_dark: boolean,
    /** True, if reaction corner is flipped */
    is_flipped: boolean,
  }

  export type storyArea = {
    /** Describes a clickable rectangle area on a story media */
    _: 'storyArea',
    /** Position of the area */
    position: storyAreaPosition,
    /** Type of the area */
    type: StoryAreaType,
  }

  export type inputStoryAreaTypeLocation$Input = {
    /** An area pointing to a location */
    readonly _: 'inputStoryAreaTypeLocation',
    /** The location */
    readonly location?: location$Input,
  }

  export type inputStoryAreaTypeFoundVenue$Input = {
    /** An area pointing to a venue found by the bot getOption("venue_search_bot_username") */
    readonly _: 'inputStoryAreaTypeFoundVenue',
    /** Identifier of the inline query, used to found the venue */
    readonly query_id?: number | string,
    /** Identifier of the inline query result */
    readonly result_id?: string,
  }

  export type inputStoryAreaTypePreviousVenue$Input = {
    /** An area pointing to a venue already added to the story */
    readonly _: 'inputStoryAreaTypePreviousVenue',
    /** Provider of the venue */
    readonly venue_provider?: string,
    /** Identifier of the venue in the provider database */
    readonly venue_id?: string,
  }

  export type inputStoryAreaTypeSuggestedReaction$Input = {
    /** An area pointing to a suggested reaction */
    readonly _: 'inputStoryAreaTypeSuggestedReaction',
    /** Type of the reaction */
    readonly reaction_type?: ReactionType$Input,
    /** True, if reaction has a dark background */
    readonly is_dark?: boolean,
    /** True, if reaction corner is flipped */
    readonly is_flipped?: boolean,
  }

  export type inputStoryArea$Input = {
    /** Describes a clickable rectangle area on a story media to be added */
    readonly _: 'inputStoryArea',
    /** Position of the area */
    readonly position?: storyAreaPosition$Input,
    /** Type of the area */
    readonly type?: InputStoryAreaType$Input,
  }

  export type inputStoryAreas$Input = {
    /** Contains a list of story areas to be added */
    readonly _: 'inputStoryAreas',
    /** List of 0-10 input story areas */
    readonly areas?: ReadonlyArray<inputStoryArea$Input>,
  }

  export type storyVideo = {
    /** Describes a video file sent in a story */
    _: 'storyVideo',
    /** Duration of the video, in seconds */
    duration: number,
    /** Video width */
    width: number,
    /** Video height */
    height: number,
    /**
     * True, if stickers were added to the video. The list of corresponding sticker
     * sets can be received using getAttachedStickerSets
     */
    has_stickers: boolean,
    /** True, if the video has no sound */
    is_animation: boolean,
    /** Video minithumbnail; may be null */
    minithumbnail?: minithumbnail,
    /** Video thumbnail in JPEG or MPEG4 format; may be null */
    thumbnail?: thumbnail,
    /** Size of file prefix, which is supposed to be preloaded, in bytes */
    preload_prefix_size: number,
    /** File containing the video */
    video: file,
  }

  export type storyContentPhoto = {
    /** A photo story */
    _: 'storyContentPhoto',
    /** The photo */
    photo: photo,
  }

  export type storyContentVideo = {
    /** A video story */
    _: 'storyContentVideo',
    /** The video in MPEG4 format */
    video: storyVideo,
    /**
     * Alternative version of the video in MPEG4 format, encoded by x264 codec; may
     * be null
     */
    alternative_video?: storyVideo,
  }

  export type storyContentUnsupported = {
    /** A story content that is not supported in the current TDLib version */
    _: 'storyContentUnsupported',
  }

  export type inputStoryContentPhoto$Input = {
    /** A photo story */
    readonly _: 'inputStoryContentPhoto',
    /**
     * Photo to send. The photo must be at most 10 MB in size. The photo size must
     * be 1080x1920
     */
    readonly photo?: InputFile$Input,
    /** File identifiers of the stickers added to the photo, if applicable */
    readonly added_sticker_file_ids?: ReadonlyArray<number>,
  }

  export type inputStoryContentVideo$Input = {
    /** A video story */
    readonly _: 'inputStoryContentVideo',
    /**
     * Video to be sent. The video size must be 720x1280. The video must be streamable
     * and stored in MPEG4 format, after encoding with x265 codec and key frames added
     * each second
     */
    readonly video?: InputFile$Input,
    /** File identifiers of the stickers added to the video, if applicable */
    readonly added_sticker_file_ids?: ReadonlyArray<number>,
    /** Precise duration of the video, in seconds; 0-60 */
    readonly duration?: number,
    /** True, if the video has no sound */
    readonly is_animation?: boolean,
  }

  export type storyListMain = {
    /** The list of stories, shown in the main chat list and folder chat lists */
    _: 'storyListMain',
  }

  export type storyListMain$Input = {
    /** The list of stories, shown in the main chat list and folder chat lists */
    readonly _: 'storyListMain',
  }

  export type storyListArchive = {
    /** The list of stories, shown in the Arvhive chat list */
    _: 'storyListArchive',
  }

  export type storyListArchive$Input = {
    /** The list of stories, shown in the Arvhive chat list */
    readonly _: 'storyListArchive',
  }

  export type storyInteractionInfo = {
    /** Contains information about interactions with a story */
    _: 'storyInteractionInfo',
    /** Number of times the story was viewed */
    view_count: number,
    /** Number of times the story was forwarded; 0 if none or unknown */
    forward_count: number,
    /** Number of reactions added to the story; 0 if none or unknown */
    reaction_count: number,
    /** Identifiers of at most 3 recent viewers of the story */
    recent_viewer_user_ids: Array<number>,
  }

  export type story = {
    /** Represents a story */
    _: 'story',
    /** Unique story identifier among stories of the given sender */
    id: number,
    /** Identifier of the chat that posted the story */
    sender_chat_id: number,
    /** Point in time (Unix timestamp) when the story was published */
    date: number,
    /** True, if the story is being sent by the current user */
    is_being_sent: boolean,
    /** True, if the story is being edited by the current user */
    is_being_edited: boolean,
    /** True, if the story was edited */
    is_edited: boolean,
    /**
     * True, if the story is saved in the sender's profile and will be available there
     * after expiration
     */
    is_pinned: boolean,
    /** True, if the story is visible only for the current user */
    is_visible_only_for_self: boolean,
    /** True, if the story can be deleted */
    can_be_deleted: boolean,
    /** True, if the story can be edited */
    can_be_edited: boolean,
    /**
     * True, if the story can be forwarded as a message. Otherwise, screenshots and
     * saving of the story content must be also forbidden
     */
    can_be_forwarded: boolean,
    /** True, if the story can be replied in the chat with the story sender */
    can_be_replied: boolean,
    /** True, if the story's is_pinned value can be changed */
    can_toggle_is_pinned: boolean,
    /** True, if users viewed the story can be received through getStoryViewers */
    can_get_viewers: boolean,
    /**
     * True, if users viewed the story can't be received, because the story has expired
     * more than getOption("story_viewers_expiration_delay") seconds ago
     */
    has_expired_viewers: boolean,
    /**
     * Information about interactions with the story; may be null if the story isn't
     * owned or there were no interactions
     */
    interaction_info?: storyInteractionInfo,
    /** Type of the chosen reaction; may be null if none */
    chosen_reaction_type?: ReactionType,
    /** Privacy rules affecting story visibility; may be approximate for non-owned stories */
    privacy_settings: StoryPrivacySettings,
    /** Content of the story */
    content: StoryContent,
    /** Clickable areas to be shown on the story content */
    areas: Array<storyArea>,
    /** Caption of the story */
    caption: formattedText,
  }

  export type stories = {
    /** Represents a list of stories */
    _: 'stories',
    /** Approximate total number of stories found */
    total_count: number,
    /** The list of stories */
    stories: Array<story>,
  }

  export type storyInfo = {
    /** Contains basic information about a story */
    _: 'storyInfo',
    /** Unique story identifier among stories of the given sender */
    story_id: number,
    /** Point in time (Unix timestamp) when the story was published */
    date: number,
    /** True, if the story is available only to close friends */
    is_for_close_friends: boolean,
  }

  export type chatActiveStories = {
    /** Describes active stories posted by a chat */
    _: 'chatActiveStories',
    /** Identifier of the chat that posted the stories */
    chat_id: number,
    /**
     * Identifier of the story list in which the stories are shown; may be null if
     * the stories aren't shown in a story list
     */
    list?: StoryList,
    /**
     * A parameter used to determine order of the stories in the story list; 0 if the
     * stories doesn't need to be shown in the story list. Stories must be sorted by
     * the pair (order, story_sender_chat_id) in descending order
     */
    order: number,
    /** Identifier of the last read active story */
    max_read_story_id: number,
    /**
     * Basic information about the stories; use getStory to get full information about
     * the stories. The stories are in a chronological order (i.e., in order of increasing
     * story identifiers)
     */
    stories: Array<storyInfo>,
  }

  export type chatBoostStatus = {
    /** Describes current boost status of a chat */
    _: 'chatBoostStatus',
    /** True, if the current user has already boosted the chat */
    is_boosted: boolean,
    /** Current boost level of the chat */
    level: number,
    /** The number of times the chat was boosted */
    boost_count: number,
    /** The number of boosts added to reach the current level */
    current_level_boost_count: number,
    /**
     * The number of boosts needed to reach the next level; 0 if the next level isn't
     * available
     */
    next_level_boost_count: number,
    /**
     * Approximate number of Telegram Premium subscribers joined the chat; always 0
     * if the current user isn't an administrator in the chat
     */
    premium_member_count: number,
    /**
     * A percentage of Telegram Premium subscribers joined the chat; always 0 if the
     * current user isn't an administrator in the chat
     */
    premium_member_percentage: number,
  }

  export type chatBoost = {
    /** Describes a boost of a chat */
    _: 'chatBoost',
    /** Identifier of a user that boosted the chat */
    user_id: number,
    /**
     * Point in time (Unix timestamp) when the boost will automatically expire if the
     * user will not prolongate their Telegram Premium subscription
     */
    expiration_date: number,
  }

  export type foundChatBoosts = {
    /** Contains a list of boosts applied to a chat */
    _: 'foundChatBoosts',
    /** Total number of boosts applied to the chat */
    total_count: number,
    /** List of boosts */
    boosts: Array<chatBoost>,
    /** The offset for the next request. If empty, there are no more results */
    next_offset: string,
  }

  export type callDiscardReasonEmpty = {
    /** The call wasn't discarded, or the reason is unknown */
    _: 'callDiscardReasonEmpty',
  }

  export type callDiscardReasonMissed = {
    /**
     * The call was ended before the conversation started. It was canceled by the caller
     * or missed by the other party
     */
    _: 'callDiscardReasonMissed',
  }

  export type callDiscardReasonDeclined = {
    /**
     * The call was ended before the conversation started. It was declined by the other
     * party
     */
    _: 'callDiscardReasonDeclined',
  }

  export type callDiscardReasonDisconnected = {
    /** The call was ended during the conversation because the users were disconnected */
    _: 'callDiscardReasonDisconnected',
  }

  export type callDiscardReasonHungUp = {
    /** The call was ended because one of the parties hung up */
    _: 'callDiscardReasonHungUp',
  }

  export type callProtocol = {
    /** Specifies the supported call protocols */
    _: 'callProtocol',
    /** True, if UDP peer-to-peer connections are supported */
    udp_p2p: boolean,
    /** True, if connection through UDP reflectors is supported */
    udp_reflector: boolean,
    /** The minimum supported API layer; use 65 */
    min_layer: number,
    /** The maximum supported API layer; use 92 */
    max_layer: number,
    /** List of supported tgcalls versions */
    library_versions: Array<string>,
  }

  export type callProtocol$Input = {
    /** Specifies the supported call protocols */
    readonly _: 'callProtocol',
    /** True, if UDP peer-to-peer connections are supported */
    readonly udp_p2p?: boolean,
    /** True, if connection through UDP reflectors is supported */
    readonly udp_reflector?: boolean,
    /** The minimum supported API layer; use 65 */
    readonly min_layer?: number,
    /** The maximum supported API layer; use 92 */
    readonly max_layer?: number,
    /** List of supported tgcalls versions */
    readonly library_versions?: ReadonlyArray<string>,
  }

  export type callServerTypeTelegramReflector = {
    /** A Telegram call reflector */
    _: 'callServerTypeTelegramReflector',
    /** A peer tag to be used with the reflector */
    peer_tag: string,
    /** True, if the server uses TCP instead of UDP */
    is_tcp: boolean,
  }

  export type callServerTypeWebrtc = {
    /** A WebRTC server */
    _: 'callServerTypeWebrtc',
    /** Username to be used for authentication */
    username: string,
    /** Authentication password */
    password: string,
    /** True, if the server supports TURN */
    supports_turn: boolean,
    /** True, if the server supports STUN */
    supports_stun: boolean,
  }

  export type callServer = {
    /** Describes a server for relaying call data */
    _: 'callServer',
    /** Server identifier */
    id: number | string,
    /** Server IPv4 address */
    ip_address: string,
    /** Server IPv6 address */
    ipv6_address: string,
    /** Server port number */
    port: number,
    /** Server type */
    type: CallServerType,
  }

  export type callId = {
    /** Contains the call identifier */
    _: 'callId',
    /** Call identifier */
    id: number,
  }

  export type groupCallId = {
    /** Contains the group call identifier */
    _: 'groupCallId',
    /** Group call identifier */
    id: number,
  }

  export type callStatePending = {
    /** The call is pending, waiting to be accepted by a user */
    _: 'callStatePending',
    /** True, if the call has already been created by the server */
    is_created: boolean,
    /** True, if the call has already been received by the other party */
    is_received: boolean,
  }

  export type callStateExchangingKeys = {
    /** The call has been answered and encryption keys are being exchanged */
    _: 'callStateExchangingKeys',
  }

  export type callStateReady = {
    /** The call is ready to use */
    _: 'callStateReady',
    /** Call protocols supported by the peer */
    protocol: callProtocol,
    /** List of available call servers */
    servers: Array<callServer>,
    /** A JSON-encoded call config */
    config: string,
    /** Call encryption key */
    encryption_key: string,
    /** Encryption key emojis fingerprint */
    emojis: Array<string>,
    /** True, if peer-to-peer connection is allowed by users privacy settings */
    allow_p2p: boolean,
  }

  export type callStateHangingUp = {
    /** The call is hanging up after discardCall has been called */
    _: 'callStateHangingUp',
  }

  export type callStateDiscarded = {
    /** The call has ended successfully */
    _: 'callStateDiscarded',
    /** The reason, why the call has ended */
    reason: CallDiscardReason,
    /** True, if the call rating must be sent to the server */
    need_rating: boolean,
    /** True, if the call debug information must be sent to the server */
    need_debug_information: boolean,
    /** True, if the call log must be sent to the server */
    need_log: boolean,
  }

  export type callStateError = {
    /** The call has ended with an error */
    _: 'callStateError',
    /**
     * Error. An error with the code 4005000 will be returned if an outgoing call is
     * missed because of an expired timeout
     */
    error: error,
  }

  export type groupCallVideoQualityThumbnail$Input = {
    /** The worst available video quality */
    readonly _: 'groupCallVideoQualityThumbnail',
  }

  export type groupCallVideoQualityMedium$Input = {
    /** The medium video quality */
    readonly _: 'groupCallVideoQualityMedium',
  }

  export type groupCallVideoQualityFull$Input = {
    /** The best available video quality */
    readonly _: 'groupCallVideoQualityFull',
  }

  export type groupCallStream = {
    /** Describes an available stream in a group call */
    _: 'groupCallStream',
    /** Identifier of an audio/video channel */
    channel_id: number,
    /** Scale of segment durations in the stream. The duration is 1000/(2**scale) milliseconds */
    scale: number,
    /** Point in time when the stream currently ends; Unix timestamp in milliseconds */
    time_offset: number,
  }

  export type groupCallStreams = {
    /** Represents a list of group call streams */
    _: 'groupCallStreams',
    /** A list of group call streams */
    streams: Array<groupCallStream>,
  }

  export type rtmpUrl = {
    /** Represents an RTMP URL */
    _: 'rtmpUrl',
    /** The URL */
    url: string,
    /** Stream key */
    stream_key: string,
  }

  export type groupCallRecentSpeaker = {
    /** Describes a recently speaking participant in a group call */
    _: 'groupCallRecentSpeaker',
    /** Group call participant identifier */
    participant_id: MessageSender,
    /** True, is the user has spoken recently */
    is_speaking: boolean,
  }

  export type groupCall = {
    /** Describes a group call */
    _: 'groupCall',
    /** Group call identifier */
    id: number,
    /** Group call title */
    title: string,
    /**
     * Point in time (Unix timestamp) when the group call is supposed to be started
     * by an administrator; 0 if it is already active or was ended
     */
    scheduled_start_date: number,
    /**
     * True, if the group call is scheduled and the current user will receive a notification
     * when the group call will start
     */
    enabled_start_notification: boolean,
    /** True, if the call is active */
    is_active: boolean,
    /** True, if the chat is an RTMP stream instead of an ordinary video chat */
    is_rtmp_stream: boolean,
    /** True, if the call is joined */
    is_joined: boolean,
    /**
     * True, if user was kicked from the call because of network loss and the call
     * needs to be rejoined
     */
    need_rejoin: boolean,
    /** True, if the current user can manage the group call */
    can_be_managed: boolean,
    /** Number of participants in the group call */
    participant_count: number,
    /**
     * True, if group call participants, which are muted, aren't returned in participant
     * list
     */
    has_hidden_listeners: boolean,
    /** True, if all group call participants are loaded */
    loaded_all_participants: boolean,
    /** At most 3 recently speaking users in the group call */
    recent_speakers: Array<groupCallRecentSpeaker>,
    /** True, if the current user's video is enabled */
    is_my_video_enabled: boolean,
    /** True, if the current user's video is paused */
    is_my_video_paused: boolean,
    /** True, if the current user can broadcast video or share screen */
    can_enable_video: boolean,
    /** True, if only group call administrators can unmute new participants */
    mute_new_participants: boolean,
    /** True, if the current user can enable or disable mute_new_participants setting */
    can_toggle_mute_new_participants: boolean,
    /**
     * Duration of the ongoing group call recording, in seconds; 0 if none. An updateGroupCall
     * update is not triggered when value of this field changes, but the same recording
     * goes on
     */
    record_duration: number,
    /** True, if a video file is being recorded for the call */
    is_video_recorded: boolean,
    /** Call duration, in seconds; for ended calls only */
    duration: number,
  }

  export type groupCallVideoSourceGroup = {
    /** Describes a group of video synchronization source identifiers */
    _: 'groupCallVideoSourceGroup',
    /** The semantics of sources, one of "SIM" or "FID" */
    semantics: string,
    /** The list of synchronization source identifiers */
    source_ids: Array<number>,
  }

  export type groupCallParticipantVideoInfo = {
    /** Contains information about a group call participant's video channel */
    _: 'groupCallParticipantVideoInfo',
    /** List of synchronization source groups of the video */
    source_groups: Array<groupCallVideoSourceGroup>,
    /** Video channel endpoint identifier */
    endpoint_id: string,
    /**
     * True, if the video is paused. This flag needs to be ignored, if new video frames
     * are received
     */
    is_paused: boolean,
  }

  export type groupCallParticipant = {
    /** Represents a group call participant */
    _: 'groupCallParticipant',
    /** Identifier of the group call participant */
    participant_id: MessageSender,
    /** User's audio channel synchronization source identifier */
    audio_source_id: number,
    /** User's screen sharing audio channel synchronization source identifier */
    screen_sharing_audio_source_id: number,
    /** Information about user's video channel; may be null if there is no active video */
    video_info?: groupCallParticipantVideoInfo,
    /**
     * Information about user's screen sharing video channel; may be null if there
     * is no active screen sharing video
     */
    screen_sharing_video_info?: groupCallParticipantVideoInfo,
    /** The participant user's bio or the participant chat's description */
    bio: string,
    /** True, if the participant is the current user */
    is_current_user: boolean,
    /** True, if the participant is speaking as set by setGroupCallParticipantIsSpeaking */
    is_speaking: boolean,
    /** True, if the participant hand is raised */
    is_hand_raised: boolean,
    /**
     * True, if the current user can mute the participant for all other group call
     * participants
     */
    can_be_muted_for_all_users: boolean,
    /**
     * True, if the current user can allow the participant to unmute themselves or
     * unmute the participant (if the participant is the current user)
     */
    can_be_unmuted_for_all_users: boolean,
    /** True, if the current user can mute the participant only for self */
    can_be_muted_for_current_user: boolean,
    /** True, if the current user can unmute the participant for self */
    can_be_unmuted_for_current_user: boolean,
    /** True, if the participant is muted for all users */
    is_muted_for_all_users: boolean,
    /** True, if the participant is muted for the current user */
    is_muted_for_current_user: boolean,
    /** True, if the participant is muted for all users, but can unmute themselves */
    can_unmute_self: boolean,
    /** Participant's volume level; 1-20000 in hundreds of percents */
    volume_level: number,
    /**
     * User's order in the group call participant list. Orders must be compared lexicographically.
     * The bigger is order, the higher is user in the list. If order is empty, the
     * user must be removed from the participant list
     */
    order: string,
  }

  export type callProblemEcho$Input = {
    /** The user heard their own voice */
    readonly _: 'callProblemEcho',
  }

  export type callProblemNoise$Input = {
    /** The user heard background noise */
    readonly _: 'callProblemNoise',
  }

  export type callProblemInterruptions$Input = {
    /** The other side kept disappearing */
    readonly _: 'callProblemInterruptions',
  }

  export type callProblemDistortedSpeech$Input = {
    /** The speech was distorted */
    readonly _: 'callProblemDistortedSpeech',
  }

  export type callProblemSilentLocal$Input = {
    /** The user couldn't hear the other side */
    readonly _: 'callProblemSilentLocal',
  }

  export type callProblemSilentRemote$Input = {
    /** The other side couldn't hear the user */
    readonly _: 'callProblemSilentRemote',
  }

  export type callProblemDropped$Input = {
    /** The call ended unexpectedly */
    readonly _: 'callProblemDropped',
  }

  export type callProblemDistortedVideo$Input = {
    /** The video was distorted */
    readonly _: 'callProblemDistortedVideo',
  }

  export type callProblemPixelatedVideo$Input = {
    /** The video was pixelated */
    readonly _: 'callProblemPixelatedVideo',
  }

  export type call = {
    /** Describes a call */
    _: 'call',
    /** Call identifier, not persistent */
    id: number,
    /** Peer user identifier */
    user_id: number,
    /** True, if the call is outgoing */
    is_outgoing: boolean,
    /** True, if the call is a video call */
    is_video: boolean,
    /** Call state */
    state: CallState,
  }

  export type firebaseAuthenticationSettingsAndroid$Input = {
    /** Settings for Firebase Authentication in the official Android application */
    readonly _: 'firebaseAuthenticationSettingsAndroid',
  }

  export type firebaseAuthenticationSettingsIos$Input = {
    /** Settings for Firebase Authentication in the official iOS application */
    readonly _: 'firebaseAuthenticationSettingsIos',
    /** Device token from Apple Push Notification service */
    readonly device_token?: string,
    /** True, if App Sandbox is enabled */
    readonly is_app_sandbox?: boolean,
  }

  export type phoneNumberAuthenticationSettings$Input = {
    /** Contains settings for the authentication of the user's phone number */
    readonly _: 'phoneNumberAuthenticationSettings',
    /**
     * Pass true if the authentication code may be sent via a flash call to the specified
     * phone number
     */
    readonly allow_flash_call?: boolean,
    /**
     * Pass true if the authentication code may be sent via a missed call to the specified
     * phone number
     */
    readonly allow_missed_call?: boolean,
    /** Pass true if the authenticated phone number is used on the current device */
    readonly is_current_phone_number?: boolean,
    /**
     * For official applications only. True, if the application can use Android SMS
     * Retriever API (requires Google Play Services >= 10.2) to automatically receive
     * the authentication code from the SMS. See https://developers.google.com/identity/sms-retriever/
     * for more details
     */
    readonly allow_sms_retriever_api?: boolean,
    /**
     * For official Android and iOS applications only; pass null otherwise. Settings
     * for Firebase Authentication
     */
    readonly firebase_authentication_settings?: FirebaseAuthenticationSettings$Input,
    /**
     * List of up to 20 authentication tokens, recently received in updateOption("authentication_token")
     * in previously logged out sessions
     */
    readonly authentication_tokens?: ReadonlyArray<string>,
  }

  export type addedReaction = {
    /** Represents a reaction applied to a message */
    _: 'addedReaction',
    /** Type of the reaction */
    type: ReactionType,
    /** Identifier of the chat member, applied the reaction */
    sender_id: MessageSender,
    /** Point in time (Unix timestamp) when the reaction was added */
    date: number,
  }

  export type addedReactions = {
    /** Represents a list of reactions added to a message */
    _: 'addedReactions',
    /** The total number of found reactions */
    total_count: number,
    /** The list of added reactions */
    reactions: Array<addedReaction>,
    /** The offset for the next request. If empty, there are no more results */
    next_offset: string,
  }

  export type availableReaction = {
    /** Represents an available reaction */
    _: 'availableReaction',
    /** Type of the reaction */
    type: ReactionType,
    /** True, if Telegram Premium is needed to send the reaction */
    needs_premium: boolean,
  }

  export type availableReactions = {
    /** Represents a list of reactions that can be added to a message */
    _: 'availableReactions',
    /** List of reactions to be shown at the top */
    top_reactions: Array<availableReaction>,
    /** List of recently used reactions */
    recent_reactions: Array<availableReaction>,
    /** List of popular reactions */
    popular_reactions: Array<availableReaction>,
    /** True, if custom emoji reactions could be added by Telegram Premium subscribers */
    allow_custom_emoji: boolean,
  }

  export type emojiReaction = {
    /** Contains information about a emoji reaction */
    _: 'emojiReaction',
    /** Text representation of the reaction */
    emoji: string,
    /** Reaction title */
    title: string,
    /** True, if the reaction can be added to new messages and enabled in chats */
    is_active: boolean,
    /** Static icon for the reaction */
    static_icon: sticker,
    /** Appear animation for the reaction */
    appear_animation: sticker,
    /** Select animation for the reaction */
    select_animation: sticker,
    /** Activate animation for the reaction */
    activate_animation: sticker,
    /** Effect animation for the reaction */
    effect_animation: sticker,
    /** Around animation for the reaction; may be null */
    around_animation?: sticker,
    /** Center animation for the reaction; may be null */
    center_animation?: sticker,
  }

  export type animations = {
    /** Represents a list of animations */
    _: 'animations',
    /** List of animations */
    animations: Array<animation>,
  }

  export type diceStickersRegular = {
    /** A regular animated sticker */
    _: 'diceStickersRegular',
    /** The animated sticker with the dice animation */
    sticker: sticker,
  }

  export type diceStickersSlotMachine = {
    /** Animated stickers to be combined into a slot machine */
    _: 'diceStickersSlotMachine',
    /**
     * The animated sticker with the slot machine background. The background animation
     * must start playing after all reel animations finish
     */
    background: sticker,
    /**
     * The animated sticker with the lever animation. The lever animation must play
     * once in the initial dice state
     */
    lever: sticker,
    /** The animated sticker with the left reel */
    left_reel: sticker,
    /** The animated sticker with the center reel */
    center_reel: sticker,
    /** The animated sticker with the right reel */
    right_reel: sticker,
  }

  export type importedContacts = {
    /** Represents the result of an importContacts request */
    _: 'importedContacts',
    /**
     * User identifiers of the imported contacts in the same order as they were specified
     * in the request; 0 if the contact is not yet a registered user
     */
    user_ids: Array<number>,
    /**
     * The number of users that imported the corresponding contact; 0 for already registered
     * users or if unavailable
     */
    importer_count: Array<number>,
  }

  export type speechRecognitionResultPending = {
    /** The speech recognition is ongoing */
    _: 'speechRecognitionResultPending',
    /** Partially recognized text */
    partial_text: string,
  }

  export type speechRecognitionResultText = {
    /** The speech recognition successfully finished */
    _: 'speechRecognitionResultText',
    /** Recognized text */
    text: string,
  }

  export type speechRecognitionResultError = {
    /** The speech recognition failed */
    _: 'speechRecognitionResultError',
    /** Recognition error */
    error: error,
  }

  export type attachmentMenuBotColor = {
    /** Describes a color to highlight a bot added to attachment menu */
    _: 'attachmentMenuBotColor',
    /** Color in the RGB24 format for light themes */
    light_color: number,
    /** Color in the RGB24 format for dark themes */
    dark_color: number,
  }

  export type attachmentMenuBot = {
    /** Represents a bot, which can be added to attachment or side menu */
    _: 'attachmentMenuBot',
    /** User identifier of the bot */
    bot_user_id: number,
    /**
     * True, if the bot supports opening from attachment menu in the chat with the
     * bot
     */
    supports_self_chat: boolean,
    /**
     * True, if the bot supports opening from attachment menu in private chats with
     * ordinary users
     */
    supports_user_chats: boolean,
    /**
     * True, if the bot supports opening from attachment menu in private chats with
     * other bots
     */
    supports_bot_chats: boolean,
    /**
     * True, if the bot supports opening from attachment menu in basic group and supergroup
     * chats
     */
    supports_group_chats: boolean,
    /** True, if the bot supports opening from attachment menu in channel chats */
    supports_channel_chats: boolean,
    /** True, if the bot supports "settings_button_pressed" event */
    supports_settings: boolean,
    /** True, if the user must be asked for the permission to send messages to the bot */
    request_write_access: boolean,
    /**
     * True, if the bot was explicitly added by the user. If the bot isn't added, then
     * on the first bot launch toggleBotIsAddedToAttachmentMenu must be called and
     * the bot must be added or removed
     */
    is_added: boolean,
    /** True, if the bot must be shown in the attachment menu */
    show_in_attachment_menu: boolean,
    /** True, if the bot must be shown in the side menu */
    show_in_side_menu: boolean,
    /** True, if a disclaimer, why the bot is shown in the side menu, is needed */
    show_disclaimer_in_side_menu: boolean,
    /** Name for the bot in attachment menu */
    name: string,
    /** Color to highlight selected name of the bot if appropriate; may be null */
    name_color?: attachmentMenuBotColor,
    /** Default icon for the bot in SVG format; may be null */
    default_icon?: file,
    /** Icon for the bot in SVG format for the official iOS app; may be null */
    ios_static_icon?: file,
    /** Icon for the bot in TGS format for the official iOS app; may be null */
    ios_animated_icon?: file,
    /** Icon for the bot in PNG format for the official iOS app side menu; may be null */
    ios_side_menu_icon?: file,
    /** Icon for the bot in TGS format for the official Android app; may be null */
    android_icon?: file,
    /**
     * Icon for the bot in SVG format for the official Android app side menu; may be
     * null
     */
    android_side_menu_icon?: file,
    /** Icon for the bot in TGS format for the official native macOS app; may be null */
    macos_icon?: file,
    /**
     * Icon for the bot in PNG format for the official macOS app side menu; may be
     * null
     */
    macos_side_menu_icon?: file,
    /** Color to highlight selected icon of the bot if appropriate; may be null */
    icon_color?: attachmentMenuBotColor,
    /** Default placeholder for opened Web Apps in SVG format; may be null */
    web_app_placeholder?: file,
  }

  export type sentWebAppMessage = {
    /** Information about the message sent by answerWebAppQuery */
    _: 'sentWebAppMessage',
    /** Identifier of the sent inline message, if known */
    inline_message_id: string,
  }

  export type httpUrl = {
    /** Contains an HTTP URL */
    _: 'httpUrl',
    /** The URL */
    url: string,
  }

  export type userLink = {
    /** Contains an HTTPS URL, which can be used to get information about a user */
    _: 'userLink',
    /** The URL */
    url: string,
    /**
     * Left time for which the link is valid, in seconds; 0 if the link is a public
     * username link
     */
    expires_in: number,
  }

  export type inputInlineQueryResultAnimation$Input = {
    /**
     * Represents a link to an animated GIF or an animated (i.e., without sound) H.264/MPEG-4
     * AVC video
     */
    readonly _: 'inputInlineQueryResultAnimation',
    /** Unique identifier of the query result */
    readonly id?: string,
    /** Title of the query result */
    readonly title?: string,
    /** URL of the result thumbnail (JPEG, GIF, or MPEG4), if it exists */
    readonly thumbnail_url?: string,
    /**
     * MIME type of the video thumbnail. If non-empty, must be one of "image/jpeg",
     * "image/gif" and "video/mp4"
     */
    readonly thumbnail_mime_type?: string,
    /** The URL of the video file (file size must not exceed 1MB) */
    readonly video_url?: string,
    /** MIME type of the video file. Must be one of "image/gif" and "video/mp4" */
    readonly video_mime_type?: string,
    /** Duration of the video, in seconds */
    readonly video_duration?: number,
    /** Width of the video */
    readonly video_width?: number,
    /** Height of the video */
    readonly video_height?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageAnimation, inputMessageInvoice, inputMessageLocation, inputMessageVenue
     * or inputMessageContact
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type inputInlineQueryResultArticle$Input = {
    /** Represents a link to an article or web page */
    readonly _: 'inputInlineQueryResultArticle',
    /** Unique identifier of the query result */
    readonly id?: string,
    /** URL of the result, if it exists */
    readonly url?: string,
    /** True, if the URL must be not shown */
    readonly hide_url?: boolean,
    /** Title of the result */
    readonly title?: string,
    /** A short description of the result */
    readonly description?: string,
    /** URL of the result thumbnail, if it exists */
    readonly thumbnail_url?: string,
    /** Thumbnail width, if known */
    readonly thumbnail_width?: number,
    /** Thumbnail height, if known */
    readonly thumbnail_height?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type inputInlineQueryResultAudio$Input = {
    /** Represents a link to an MP3 audio file */
    readonly _: 'inputInlineQueryResultAudio',
    /** Unique identifier of the query result */
    readonly id?: string,
    /** Title of the audio file */
    readonly title?: string,
    /** Performer of the audio file */
    readonly performer?: string,
    /** The URL of the audio file */
    readonly audio_url?: string,
    /** Audio file duration, in seconds */
    readonly audio_duration?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageAudio, inputMessageInvoice, inputMessageLocation, inputMessageVenue
     * or inputMessageContact
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type inputInlineQueryResultContact$Input = {
    /** Represents a user contact */
    readonly _: 'inputInlineQueryResultContact',
    /** Unique identifier of the query result */
    readonly id?: string,
    /** User contact */
    readonly contact?: contact$Input,
    /** URL of the result thumbnail, if it exists */
    readonly thumbnail_url?: string,
    /** Thumbnail width, if known */
    readonly thumbnail_width?: number,
    /** Thumbnail height, if known */
    readonly thumbnail_height?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type inputInlineQueryResultDocument$Input = {
    /** Represents a link to a file */
    readonly _: 'inputInlineQueryResultDocument',
    /** Unique identifier of the query result */
    readonly id?: string,
    /** Title of the resulting file */
    readonly title?: string,
    /** Short description of the result, if known */
    readonly description?: string,
    /** URL of the file */
    readonly document_url?: string,
    /**
     * MIME type of the file content; only "application/pdf" and "application/zip"
     * are currently allowed
     */
    readonly mime_type?: string,
    /** The URL of the file thumbnail, if it exists */
    readonly thumbnail_url?: string,
    /** Width of the thumbnail */
    readonly thumbnail_width?: number,
    /** Height of the thumbnail */
    readonly thumbnail_height?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageDocument, inputMessageInvoice, inputMessageLocation, inputMessageVenue
     * or inputMessageContact
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type inputInlineQueryResultGame$Input = {
    /** Represents a game */
    readonly _: 'inputInlineQueryResultGame',
    /** Unique identifier of the query result */
    readonly id?: string,
    /** Short name of the game */
    readonly game_short_name?: string,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    readonly reply_markup?: ReplyMarkup$Input,
  }

  export type inputInlineQueryResultLocation$Input = {
    /** Represents a point on the map */
    readonly _: 'inputInlineQueryResultLocation',
    /** Unique identifier of the query result */
    readonly id?: string,
    /** Location result */
    readonly location?: location$Input,
    /**
     * Amount of time relative to the message sent time until the location can be updated,
     * in seconds
     */
    readonly live_period?: number,
    /** Title of the result */
    readonly title?: string,
    /** URL of the result thumbnail, if it exists */
    readonly thumbnail_url?: string,
    /** Thumbnail width, if known */
    readonly thumbnail_width?: number,
    /** Thumbnail height, if known */
    readonly thumbnail_height?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type inputInlineQueryResultPhoto$Input = {
    /** Represents link to a JPEG image */
    readonly _: 'inputInlineQueryResultPhoto',
    /** Unique identifier of the query result */
    readonly id?: string,
    /** Title of the result, if known */
    readonly title?: string,
    /** A short description of the result, if known */
    readonly description?: string,
    /** URL of the photo thumbnail, if it exists */
    readonly thumbnail_url?: string,
    /** The URL of the JPEG photo (photo size must not exceed 5MB) */
    readonly photo_url?: string,
    /** Width of the photo */
    readonly photo_width?: number,
    /** Height of the photo */
    readonly photo_height?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessagePhoto, inputMessageInvoice, inputMessageLocation, inputMessageVenue
     * or inputMessageContact
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type inputInlineQueryResultSticker$Input = {
    /** Represents a link to a WEBP, TGS, or WEBM sticker */
    readonly _: 'inputInlineQueryResultSticker',
    /** Unique identifier of the query result */
    readonly id?: string,
    /** URL of the sticker thumbnail, if it exists */
    readonly thumbnail_url?: string,
    /**
     * The URL of the WEBP, TGS, or WEBM sticker (sticker file size must not exceed
     * 5MB)
     */
    readonly sticker_url?: string,
    /** Width of the sticker */
    readonly sticker_width?: number,
    /** Height of the sticker */
    readonly sticker_height?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageSticker, inputMessageInvoice, inputMessageLocation, inputMessageVenue
     * or inputMessageContact
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type inputInlineQueryResultVenue$Input = {
    /** Represents information about a venue */
    readonly _: 'inputInlineQueryResultVenue',
    /** Unique identifier of the query result */
    readonly id?: string,
    /** Venue result */
    readonly venue?: venue$Input,
    /** URL of the result thumbnail, if it exists */
    readonly thumbnail_url?: string,
    /** Thumbnail width, if known */
    readonly thumbnail_width?: number,
    /** Thumbnail height, if known */
    readonly thumbnail_height?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type inputInlineQueryResultVideo$Input = {
    /** Represents a link to a page containing an embedded video player or a video file */
    readonly _: 'inputInlineQueryResultVideo',
    /** Unique identifier of the query result */
    readonly id?: string,
    /** Title of the result */
    readonly title?: string,
    /** A short description of the result, if known */
    readonly description?: string,
    /** The URL of the video thumbnail (JPEG), if it exists */
    readonly thumbnail_url?: string,
    /** URL of the embedded video player or video file */
    readonly video_url?: string,
    /**
     * MIME type of the content of the video URL, only "text/html" or "video/mp4" are
     * currently supported
     */
    readonly mime_type?: string,
    /** Width of the video */
    readonly video_width?: number,
    /** Height of the video */
    readonly video_height?: number,
    /** Video duration, in seconds */
    readonly video_duration?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageVideo, inputMessageInvoice, inputMessageLocation, inputMessageVenue
     * or inputMessageContact
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type inputInlineQueryResultVoiceNote$Input = {
    /**
     * Represents a link to an opus-encoded audio file within an OGG container, single
     * channel audio
     */
    readonly _: 'inputInlineQueryResultVoiceNote',
    /** Unique identifier of the query result */
    readonly id?: string,
    /** Title of the voice note */
    readonly title?: string,
    /** The URL of the voice note file */
    readonly voice_note_url?: string,
    /** Duration of the voice note, in seconds */
    readonly voice_note_duration?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageVoiceNote, inputMessageInvoice, inputMessageLocation, inputMessageVenue
     * or inputMessageContact
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type inlineQueryResultArticle = {
    /** Represents a link to an article or web page */
    _: 'inlineQueryResultArticle',
    /** Unique identifier of the query result */
    id: string,
    /** URL of the result, if it exists */
    url: string,
    /** True, if the URL must be not shown */
    hide_url: boolean,
    /** Title of the result */
    title: string,
    /** A short description of the result */
    description: string,
    /** Result thumbnail in JPEG format; may be null */
    thumbnail?: thumbnail,
  }

  export type inlineQueryResultContact = {
    /** Represents a user contact */
    _: 'inlineQueryResultContact',
    /** Unique identifier of the query result */
    id: string,
    /** A user contact */
    contact: contact,
    /** Result thumbnail in JPEG format; may be null */
    thumbnail?: thumbnail,
  }

  export type inlineQueryResultLocation = {
    /** Represents a point on the map */
    _: 'inlineQueryResultLocation',
    /** Unique identifier of the query result */
    id: string,
    /** Location result */
    location: location,
    /** Title of the result */
    title: string,
    /** Result thumbnail in JPEG format; may be null */
    thumbnail?: thumbnail,
  }

  export type inlineQueryResultVenue = {
    /** Represents information about a venue */
    _: 'inlineQueryResultVenue',
    /** Unique identifier of the query result */
    id: string,
    /** Venue result */
    venue: venue,
    /** Result thumbnail in JPEG format; may be null */
    thumbnail?: thumbnail,
  }

  export type inlineQueryResultGame = {
    /** Represents information about a game */
    _: 'inlineQueryResultGame',
    /** Unique identifier of the query result */
    id: string,
    /** Game result */
    game: game,
  }

  export type inlineQueryResultAnimation = {
    /** Represents an animation file */
    _: 'inlineQueryResultAnimation',
    /** Unique identifier of the query result */
    id: string,
    /** Animation file */
    animation: animation,
    /** Animation title */
    title: string,
  }

  export type inlineQueryResultAudio = {
    /** Represents an audio file */
    _: 'inlineQueryResultAudio',
    /** Unique identifier of the query result */
    id: string,
    /** Audio file */
    audio: audio,
  }

  export type inlineQueryResultDocument = {
    /** Represents a document */
    _: 'inlineQueryResultDocument',
    /** Unique identifier of the query result */
    id: string,
    /** Document */
    document: document,
    /** Document title */
    title: string,
    /** Document description */
    description: string,
  }

  export type inlineQueryResultPhoto = {
    /** Represents a photo */
    _: 'inlineQueryResultPhoto',
    /** Unique identifier of the query result */
    id: string,
    /** Photo */
    photo: photo,
    /** Title of the result, if known */
    title: string,
    /** A short description of the result, if known */
    description: string,
  }

  export type inlineQueryResultSticker = {
    /** Represents a sticker */
    _: 'inlineQueryResultSticker',
    /** Unique identifier of the query result */
    id: string,
    /** Sticker */
    sticker: sticker,
  }

  export type inlineQueryResultVideo = {
    /** Represents a video */
    _: 'inlineQueryResultVideo',
    /** Unique identifier of the query result */
    id: string,
    /** Video */
    video: video,
    /** Title of the video */
    title: string,
    /** Description of the video */
    description: string,
  }

  export type inlineQueryResultVoiceNote = {
    /** Represents a voice note */
    _: 'inlineQueryResultVoiceNote',
    /** Unique identifier of the query result */
    id: string,
    /** Voice note */
    voice_note: voiceNote,
    /** Title of the voice note */
    title: string,
  }

  export type inlineQueryResultsButtonTypeStartBot = {
    /**
     * Describes the button that opens a private chat with the bot and sends a start
     * message to the bot with the given parameter
     */
    _: 'inlineQueryResultsButtonTypeStartBot',
    /** The parameter for the bot start message */
    parameter: string,
  }

  export type inlineQueryResultsButtonTypeStartBot$Input = {
    /**
     * Describes the button that opens a private chat with the bot and sends a start
     * message to the bot with the given parameter
     */
    readonly _: 'inlineQueryResultsButtonTypeStartBot',
    /** The parameter for the bot start message */
    readonly parameter?: string,
  }

  export type inlineQueryResultsButtonTypeWebApp = {
    /** Describes the button that opens a Web App by calling getWebAppUrl */
    _: 'inlineQueryResultsButtonTypeWebApp',
    /** An HTTP URL to pass to getWebAppUrl */
    url: string,
  }

  export type inlineQueryResultsButtonTypeWebApp$Input = {
    /** Describes the button that opens a Web App by calling getWebAppUrl */
    readonly _: 'inlineQueryResultsButtonTypeWebApp',
    /** An HTTP URL to pass to getWebAppUrl */
    readonly url?: string,
  }

  export type inlineQueryResultsButton = {
    /** Represents a button to be shown above inline query results */
    _: 'inlineQueryResultsButton',
    /** The text of the button */
    text: string,
    /** Type of the button */
    type: InlineQueryResultsButtonType,
  }

  export type inlineQueryResultsButton$Input = {
    /** Represents a button to be shown above inline query results */
    readonly _: 'inlineQueryResultsButton',
    /** The text of the button */
    readonly text?: string,
    /** Type of the button */
    readonly type?: InlineQueryResultsButtonType$Input,
  }

  export type inlineQueryResults = {
    /**
     * Represents the results of the inline query. Use sendInlineQueryResultMessage
     * to send the result of the query
     */
    _: 'inlineQueryResults',
    /** Unique identifier of the inline query */
    inline_query_id: number | string,
    /** Button to be shown above inline query results; may be null */
    button?: inlineQueryResultsButton,
    /** Results of the query */
    results: Array<InlineQueryResult>,
    /** The offset for the next request. If empty, there are no more results */
    next_offset: string,
  }

  export type callbackQueryPayloadData = {
    /** The payload for a general callback button */
    _: 'callbackQueryPayloadData',
    /** Data that was attached to the callback button */
    data: string,
  }

  export type callbackQueryPayloadData$Input = {
    /** The payload for a general callback button */
    readonly _: 'callbackQueryPayloadData',
    /** Data that was attached to the callback button */
    readonly data?: string,
  }

  export type callbackQueryPayloadDataWithPassword = {
    /** The payload for a callback button requiring password */
    _: 'callbackQueryPayloadDataWithPassword',
    /** The 2-step verification password for the current user */
    password: string,
    /** Data that was attached to the callback button */
    data: string,
  }

  export type callbackQueryPayloadDataWithPassword$Input = {
    /** The payload for a callback button requiring password */
    readonly _: 'callbackQueryPayloadDataWithPassword',
    /** The 2-step verification password for the current user */
    readonly password?: string,
    /** Data that was attached to the callback button */
    readonly data?: string,
  }

  export type callbackQueryPayloadGame = {
    /** The payload for a game callback button */
    _: 'callbackQueryPayloadGame',
    /** A short name of the game that was attached to the callback button */
    game_short_name: string,
  }

  export type callbackQueryPayloadGame$Input = {
    /** The payload for a game callback button */
    readonly _: 'callbackQueryPayloadGame',
    /** A short name of the game that was attached to the callback button */
    readonly game_short_name?: string,
  }

  export type callbackQueryAnswer = {
    /** Contains a bot's answer to a callback query */
    _: 'callbackQueryAnswer',
    /** Text of the answer */
    text: string,
    /** True, if an alert must be shown to the user instead of a toast notification */
    show_alert: boolean,
    /** URL to be opened */
    url: string,
  }

  export type customRequestResult = {
    /** Contains the result of a custom request */
    _: 'customRequestResult',
    /** A JSON-serialized result */
    result: string,
  }

  export type gameHighScore = {
    /** Contains one row of the game high score table */
    _: 'gameHighScore',
    /** Position in the high score table */
    position: number,
    /** User identifier */
    user_id: number,
    /** User score */
    score: number,
  }

  export type gameHighScores = {
    /** Contains a list of game high scores */
    _: 'gameHighScores',
    /** A list of game high scores */
    scores: Array<gameHighScore>,
  }

  export type chatEventMessageEdited = {
    /** A message was edited */
    _: 'chatEventMessageEdited',
    /** The original message before the edit */
    old_message: message,
    /** The message after it was edited */
    new_message: message,
  }

  export type chatEventMessageDeleted = {
    /** A message was deleted */
    _: 'chatEventMessageDeleted',
    /** Deleted message */
    message: message,
    /** True, if the message deletion can be reported via reportSupergroupAntiSpamFalsePositive */
    can_report_anti_spam_false_positive: boolean,
  }

  export type chatEventMessagePinned = {
    /** A message was pinned */
    _: 'chatEventMessagePinned',
    /** Pinned message */
    message: message,
  }

  export type chatEventMessageUnpinned = {
    /** A message was unpinned */
    _: 'chatEventMessageUnpinned',
    /** Unpinned message */
    message: message,
  }

  export type chatEventPollStopped = {
    /** A poll in a message was stopped */
    _: 'chatEventPollStopped',
    /** The message with the poll */
    message: message,
  }

  export type chatEventMemberJoined = {
    /** A new member joined the chat */
    _: 'chatEventMemberJoined',
  }

  export type chatEventMemberJoinedByInviteLink = {
    /** A new member joined the chat via an invite link */
    _: 'chatEventMemberJoinedByInviteLink',
    /** Invite link used to join the chat */
    invite_link: chatInviteLink,
    /** True, if the user has joined the chat using an invite link for a chat folder */
    via_chat_folder_invite_link: boolean,
  }

  export type chatEventMemberJoinedByRequest = {
    /** A new member was accepted to the chat by an administrator */
    _: 'chatEventMemberJoinedByRequest',
    /** User identifier of the chat administrator, approved user join request */
    approver_user_id: number,
    /** Invite link used to join the chat; may be null */
    invite_link?: chatInviteLink,
  }

  export type chatEventMemberInvited = {
    /** A new chat member was invited */
    _: 'chatEventMemberInvited',
    /** New member user identifier */
    user_id: number,
    /** New member status */
    status: ChatMemberStatus,
  }

  export type chatEventMemberLeft = {
    /** A member left the chat */
    _: 'chatEventMemberLeft',
  }

  export type chatEventMemberPromoted = {
    /**
     * A chat member has gained/lost administrator status, or the list of their administrator
     * privileges has changed
     */
    _: 'chatEventMemberPromoted',
    /** Affected chat member user identifier */
    user_id: number,
    /** Previous status of the chat member */
    old_status: ChatMemberStatus,
    /** New status of the chat member */
    new_status: ChatMemberStatus,
  }

  export type chatEventMemberRestricted = {
    /**
     * A chat member was restricted/unrestricted or banned/unbanned, or the list of
     * their restrictions has changed
     */
    _: 'chatEventMemberRestricted',
    /** Affected chat member identifier */
    member_id: MessageSender,
    /** Previous status of the chat member */
    old_status: ChatMemberStatus,
    /** New status of the chat member */
    new_status: ChatMemberStatus,
  }

  export type chatEventAvailableReactionsChanged = {
    /** The chat available reactions were changed */
    _: 'chatEventAvailableReactionsChanged',
    /** Previous chat available reactions */
    old_available_reactions: ChatAvailableReactions,
    /** New chat available reactions */
    new_available_reactions: ChatAvailableReactions,
  }

  export type chatEventDescriptionChanged = {
    /** The chat description was changed */
    _: 'chatEventDescriptionChanged',
    /** Previous chat description */
    old_description: string,
    /** New chat description */
    new_description: string,
  }

  export type chatEventLinkedChatChanged = {
    /** The linked chat of a supergroup was changed */
    _: 'chatEventLinkedChatChanged',
    /** Previous supergroup linked chat identifier */
    old_linked_chat_id: number,
    /** New supergroup linked chat identifier */
    new_linked_chat_id: number,
  }

  export type chatEventLocationChanged = {
    /** The supergroup location was changed */
    _: 'chatEventLocationChanged',
    /** Previous location; may be null */
    old_location?: chatLocation,
    /** New location; may be null */
    new_location?: chatLocation,
  }

  export type chatEventMessageAutoDeleteTimeChanged = {
    /** The message auto-delete timer was changed */
    _: 'chatEventMessageAutoDeleteTimeChanged',
    /** Previous value of message_auto_delete_time */
    old_message_auto_delete_time: number,
    /** New value of message_auto_delete_time */
    new_message_auto_delete_time: number,
  }

  export type chatEventPermissionsChanged = {
    /** The chat permissions was changed */
    _: 'chatEventPermissionsChanged',
    /** Previous chat permissions */
    old_permissions: chatPermissions,
    /** New chat permissions */
    new_permissions: chatPermissions,
  }

  export type chatEventPhotoChanged = {
    /** The chat photo was changed */
    _: 'chatEventPhotoChanged',
    /** Previous chat photo value; may be null */
    old_photo?: chatPhoto,
    /** New chat photo value; may be null */
    new_photo?: chatPhoto,
  }

  export type chatEventSlowModeDelayChanged = {
    /** The slow_mode_delay setting of a supergroup was changed */
    _: 'chatEventSlowModeDelayChanged',
    /** Previous value of slow_mode_delay, in seconds */
    old_slow_mode_delay: number,
    /** New value of slow_mode_delay, in seconds */
    new_slow_mode_delay: number,
  }

  export type chatEventStickerSetChanged = {
    /** The supergroup sticker set was changed */
    _: 'chatEventStickerSetChanged',
    /** Previous identifier of the chat sticker set; 0 if none */
    old_sticker_set_id: number | string,
    /** New identifier of the chat sticker set; 0 if none */
    new_sticker_set_id: number | string,
  }

  export type chatEventTitleChanged = {
    /** The chat title was changed */
    _: 'chatEventTitleChanged',
    /** Previous chat title */
    old_title: string,
    /** New chat title */
    new_title: string,
  }

  export type chatEventUsernameChanged = {
    /** The chat editable username was changed */
    _: 'chatEventUsernameChanged',
    /** Previous chat username */
    old_username: string,
    /** New chat username */
    new_username: string,
  }

  export type chatEventActiveUsernamesChanged = {
    /** The chat active usernames were changed */
    _: 'chatEventActiveUsernamesChanged',
    /** Previous list of active usernames */
    old_usernames: Array<string>,
    /** New list of active usernames */
    new_usernames: Array<string>,
  }

  export type chatEventHasProtectedContentToggled = {
    /** The has_protected_content setting of a channel was toggled */
    _: 'chatEventHasProtectedContentToggled',
    /** New value of has_protected_content */
    has_protected_content: boolean,
  }

  export type chatEventInvitesToggled = {
    /** The can_invite_users permission of a supergroup chat was toggled */
    _: 'chatEventInvitesToggled',
    /** New value of can_invite_users permission */
    can_invite_users: boolean,
  }

  export type chatEventIsAllHistoryAvailableToggled = {
    /** The is_all_history_available setting of a supergroup was toggled */
    _: 'chatEventIsAllHistoryAvailableToggled',
    /** New value of is_all_history_available */
    is_all_history_available: boolean,
  }

  export type chatEventHasAggressiveAntiSpamEnabledToggled = {
    /** The has_aggressive_anti_spam_enabled setting of a supergroup was toggled */
    _: 'chatEventHasAggressiveAntiSpamEnabledToggled',
    /** New value of has_aggressive_anti_spam_enabled */
    has_aggressive_anti_spam_enabled: boolean,
  }

  export type chatEventSignMessagesToggled = {
    /** The sign_messages setting of a channel was toggled */
    _: 'chatEventSignMessagesToggled',
    /** New value of sign_messages */
    sign_messages: boolean,
  }

  export type chatEventInviteLinkEdited = {
    /** A chat invite link was edited */
    _: 'chatEventInviteLinkEdited',
    /** Previous information about the invite link */
    old_invite_link: chatInviteLink,
    /** New information about the invite link */
    new_invite_link: chatInviteLink,
  }

  export type chatEventInviteLinkRevoked = {
    /** A chat invite link was revoked */
    _: 'chatEventInviteLinkRevoked',
    /** The invite link */
    invite_link: chatInviteLink,
  }

  export type chatEventInviteLinkDeleted = {
    /** A revoked chat invite link was deleted */
    _: 'chatEventInviteLinkDeleted',
    /** The invite link */
    invite_link: chatInviteLink,
  }

  export type chatEventVideoChatCreated = {
    /** A video chat was created */
    _: 'chatEventVideoChatCreated',
    /**
     * Identifier of the video chat. The video chat can be received through the method
     * getGroupCall
     */
    group_call_id: number,
  }

  export type chatEventVideoChatEnded = {
    /** A video chat was ended */
    _: 'chatEventVideoChatEnded',
    /**
     * Identifier of the video chat. The video chat can be received through the method
     * getGroupCall
     */
    group_call_id: number,
  }

  export type chatEventVideoChatMuteNewParticipantsToggled = {
    /** The mute_new_participants setting of a video chat was toggled */
    _: 'chatEventVideoChatMuteNewParticipantsToggled',
    /** New value of the mute_new_participants setting */
    mute_new_participants: boolean,
  }

  export type chatEventVideoChatParticipantIsMutedToggled = {
    /** A video chat participant was muted or unmuted */
    _: 'chatEventVideoChatParticipantIsMutedToggled',
    /** Identifier of the affected group call participant */
    participant_id: MessageSender,
    /** New value of is_muted */
    is_muted: boolean,
  }

  export type chatEventVideoChatParticipantVolumeLevelChanged = {
    /** A video chat participant volume level was changed */
    _: 'chatEventVideoChatParticipantVolumeLevelChanged',
    /** Identifier of the affected group call participant */
    participant_id: MessageSender,
    /** New value of volume_level; 1-20000 in hundreds of percents */
    volume_level: number,
  }

  export type chatEventIsForumToggled = {
    /** The is_forum setting of a channel was toggled */
    _: 'chatEventIsForumToggled',
    /** New value of is_forum */
    is_forum: boolean,
  }

  export type chatEventForumTopicCreated = {
    /** A new forum topic was created */
    _: 'chatEventForumTopicCreated',
    /** Information about the topic */
    topic_info: forumTopicInfo,
  }

  export type chatEventForumTopicEdited = {
    /** A forum topic was edited */
    _: 'chatEventForumTopicEdited',
    /** Old information about the topic */
    old_topic_info: forumTopicInfo,
    /** New information about the topic */
    new_topic_info: forumTopicInfo,
  }

  export type chatEventForumTopicToggleIsClosed = {
    /** A forum topic was closed or reopened */
    _: 'chatEventForumTopicToggleIsClosed',
    /** New information about the topic */
    topic_info: forumTopicInfo,
  }

  export type chatEventForumTopicToggleIsHidden = {
    /** The General forum topic was hidden or unhidden */
    _: 'chatEventForumTopicToggleIsHidden',
    /** New information about the topic */
    topic_info: forumTopicInfo,
  }

  export type chatEventForumTopicDeleted = {
    /** A forum topic was deleted */
    _: 'chatEventForumTopicDeleted',
    /** Information about the topic */
    topic_info: forumTopicInfo,
  }

  export type chatEventForumTopicPinned = {
    /** A pinned forum topic was changed */
    _: 'chatEventForumTopicPinned',
    /** Information about the old pinned topic; may be null */
    old_topic_info?: forumTopicInfo,
    /** Information about the new pinned topic; may be null */
    new_topic_info?: forumTopicInfo,
  }

  export type chatEvent = {
    /** Represents a chat event */
    _: 'chatEvent',
    /** Chat event identifier */
    id: number | string,
    /** Point in time (Unix timestamp) when the event happened */
    date: number,
    /** Identifier of the user or chat who performed the action */
    member_id: MessageSender,
    /** The action */
    action: ChatEventAction,
  }

  export type chatEvents = {
    /** Contains a list of chat events */
    _: 'chatEvents',
    /** List of events */
    events: Array<chatEvent>,
  }

  export type chatEventLogFilters$Input = {
    /** Represents a set of filters used to obtain a chat event log */
    readonly _: 'chatEventLogFilters',
    /** True, if message edits need to be returned */
    readonly message_edits?: boolean,
    /** True, if message deletions need to be returned */
    readonly message_deletions?: boolean,
    /** True, if pin/unpin events need to be returned */
    readonly message_pins?: boolean,
    /** True, if members joining events need to be returned */
    readonly member_joins?: boolean,
    /** True, if members leaving events need to be returned */
    readonly member_leaves?: boolean,
    /** True, if invited member events need to be returned */
    readonly member_invites?: boolean,
    /** True, if member promotion/demotion events need to be returned */
    readonly member_promotions?: boolean,
    /** True, if member restricted/unrestricted/banned/unbanned events need to be returned */
    readonly member_restrictions?: boolean,
    /** True, if changes in chat information need to be returned */
    readonly info_changes?: boolean,
    /** True, if changes in chat settings need to be returned */
    readonly setting_changes?: boolean,
    /** True, if changes to invite links need to be returned */
    readonly invite_link_changes?: boolean,
    /** True, if video chat actions need to be returned */
    readonly video_chat_changes?: boolean,
    /** True, if forum-related actions need to be returned */
    readonly forum_changes?: boolean,
  }

  export type languagePackStringValueOrdinary = {
    /** An ordinary language pack string */
    _: 'languagePackStringValueOrdinary',
    /** String value */
    value: string,
  }

  export type languagePackStringValueOrdinary$Input = {
    /** An ordinary language pack string */
    readonly _: 'languagePackStringValueOrdinary',
    /** String value */
    readonly value?: string,
  }

  export type languagePackStringValuePluralized = {
    /**
     * A language pack string which has different forms based on the number of some
     * object it mentions. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html
     * for more information
     */
    _: 'languagePackStringValuePluralized',
    /** Value for zero objects */
    zero_value: string,
    /** Value for one object */
    one_value: string,
    /** Value for two objects */
    two_value: string,
    /** Value for few objects */
    few_value: string,
    /** Value for many objects */
    many_value: string,
    /** Default value */
    other_value: string,
  }

  export type languagePackStringValuePluralized$Input = {
    /**
     * A language pack string which has different forms based on the number of some
     * object it mentions. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html
     * for more information
     */
    readonly _: 'languagePackStringValuePluralized',
    /** Value for zero objects */
    readonly zero_value?: string,
    /** Value for one object */
    readonly one_value?: string,
    /** Value for two objects */
    readonly two_value?: string,
    /** Value for few objects */
    readonly few_value?: string,
    /** Value for many objects */
    readonly many_value?: string,
    /** Default value */
    readonly other_value?: string,
  }

  export type languagePackStringValueDeleted = {
    /**
     * A deleted language pack string, the value must be taken from the built-in English
     * language pack
     */
    _: 'languagePackStringValueDeleted',
  }

  export type languagePackStringValueDeleted$Input = {
    /**
     * A deleted language pack string, the value must be taken from the built-in English
     * language pack
     */
    readonly _: 'languagePackStringValueDeleted',
  }

  export type languagePackString = {
    /** Represents one language pack string */
    _: 'languagePackString',
    /** String key */
    key: string,
    /**
     * String value; pass null if the string needs to be taken from the built-in English
     * language pack
     */
    value: LanguagePackStringValue,
  }

  export type languagePackString$Input = {
    /** Represents one language pack string */
    readonly _: 'languagePackString',
    /** String key */
    readonly key?: string,
    /**
     * String value; pass null if the string needs to be taken from the built-in English
     * language pack
     */
    readonly value?: LanguagePackStringValue$Input,
  }

  export type languagePackStrings = {
    /** Contains a list of language pack strings */
    _: 'languagePackStrings',
    /** A list of language pack strings */
    strings: Array<languagePackString>,
  }

  export type languagePackInfo = {
    /** Contains information about a language pack */
    _: 'languagePackInfo',
    /** Unique language pack identifier */
    id: string,
    /**
     * Identifier of a base language pack; may be empty. If a string is missed in the
     * language pack, then it must be fetched from base language pack. Unsupported
     * in custom language packs
     */
    base_language_pack_id: string,
    /** Language name */
    name: string,
    /** Name of the language in that language */
    native_name: string,
    /**
     * A language code to be used to apply plural forms. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html
     * for more information
     */
    plural_code: string,
    /** True, if the language pack is official */
    is_official: boolean,
    /** True, if the language pack strings are RTL */
    is_rtl: boolean,
    /** True, if the language pack is a beta language pack */
    is_beta: boolean,
    /** True, if the language pack is installed by the current user */
    is_installed: boolean,
    /** Total number of non-deleted strings from the language pack */
    total_string_count: number,
    /** Total number of translated strings from the language pack */
    translated_string_count: number,
    /** Total number of non-deleted strings from the language pack available locally */
    local_string_count: number,
    /** Link to language translation interface; empty for custom local language packs */
    translation_url: string,
  }

  export type languagePackInfo$Input = {
    /** Contains information about a language pack */
    readonly _: 'languagePackInfo',
    /** Unique language pack identifier */
    readonly id?: string,
    /**
     * Identifier of a base language pack; may be empty. If a string is missed in the
     * language pack, then it must be fetched from base language pack. Unsupported
     * in custom language packs
     */
    readonly base_language_pack_id?: string,
    /** Language name */
    readonly name?: string,
    /** Name of the language in that language */
    readonly native_name?: string,
    /**
     * A language code to be used to apply plural forms. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html
     * for more information
     */
    readonly plural_code?: string,
    /** True, if the language pack is official */
    readonly is_official?: boolean,
    /** True, if the language pack strings are RTL */
    readonly is_rtl?: boolean,
    /** True, if the language pack is a beta language pack */
    readonly is_beta?: boolean,
    /** True, if the language pack is installed by the current user */
    readonly is_installed?: boolean,
    /** Total number of non-deleted strings from the language pack */
    readonly total_string_count?: number,
    /** Total number of translated strings from the language pack */
    readonly translated_string_count?: number,
    /** Total number of non-deleted strings from the language pack available locally */
    readonly local_string_count?: number,
    /** Link to language translation interface; empty for custom local language packs */
    readonly translation_url?: string,
  }

  export type localizationTargetInfo = {
    /** Contains information about the current localization target */
    _: 'localizationTargetInfo',
    /** List of available language packs for this application */
    language_packs: Array<languagePackInfo>,
  }

  export type premiumLimitTypeSupergroupCount = {
    /** The maximum number of joined supergroups and channels */
    _: 'premiumLimitTypeSupergroupCount',
  }

  export type premiumLimitTypeSupergroupCount$Input = {
    /** The maximum number of joined supergroups and channels */
    readonly _: 'premiumLimitTypeSupergroupCount',
  }

  export type premiumLimitTypePinnedChatCount = {
    /** The maximum number of pinned chats in the main chat list */
    _: 'premiumLimitTypePinnedChatCount',
  }

  export type premiumLimitTypePinnedChatCount$Input = {
    /** The maximum number of pinned chats in the main chat list */
    readonly _: 'premiumLimitTypePinnedChatCount',
  }

  export type premiumLimitTypeCreatedPublicChatCount = {
    /** The maximum number of created public chats */
    _: 'premiumLimitTypeCreatedPublicChatCount',
  }

  export type premiumLimitTypeCreatedPublicChatCount$Input = {
    /** The maximum number of created public chats */
    readonly _: 'premiumLimitTypeCreatedPublicChatCount',
  }

  export type premiumLimitTypeSavedAnimationCount = {
    /** The maximum number of saved animations */
    _: 'premiumLimitTypeSavedAnimationCount',
  }

  export type premiumLimitTypeSavedAnimationCount$Input = {
    /** The maximum number of saved animations */
    readonly _: 'premiumLimitTypeSavedAnimationCount',
  }

  export type premiumLimitTypeFavoriteStickerCount = {
    /** The maximum number of favorite stickers */
    _: 'premiumLimitTypeFavoriteStickerCount',
  }

  export type premiumLimitTypeFavoriteStickerCount$Input = {
    /** The maximum number of favorite stickers */
    readonly _: 'premiumLimitTypeFavoriteStickerCount',
  }

  export type premiumLimitTypeChatFolderCount = {
    /** The maximum number of chat folders */
    _: 'premiumLimitTypeChatFolderCount',
  }

  export type premiumLimitTypeChatFolderCount$Input = {
    /** The maximum number of chat folders */
    readonly _: 'premiumLimitTypeChatFolderCount',
  }

  export type premiumLimitTypeChatFolderChosenChatCount = {
    /**
     * The maximum number of pinned and always included, or always excluded chats in
     * a chat folder
     */
    _: 'premiumLimitTypeChatFolderChosenChatCount',
  }

  export type premiumLimitTypeChatFolderChosenChatCount$Input = {
    /**
     * The maximum number of pinned and always included, or always excluded chats in
     * a chat folder
     */
    readonly _: 'premiumLimitTypeChatFolderChosenChatCount',
  }

  export type premiumLimitTypePinnedArchivedChatCount = {
    /** The maximum number of pinned chats in the archive chat list */
    _: 'premiumLimitTypePinnedArchivedChatCount',
  }

  export type premiumLimitTypePinnedArchivedChatCount$Input = {
    /** The maximum number of pinned chats in the archive chat list */
    readonly _: 'premiumLimitTypePinnedArchivedChatCount',
  }

  export type premiumLimitTypeCaptionLength = {
    /** The maximum length of sent media caption */
    _: 'premiumLimitTypeCaptionLength',
  }

  export type premiumLimitTypeCaptionLength$Input = {
    /** The maximum length of sent media caption */
    readonly _: 'premiumLimitTypeCaptionLength',
  }

  export type premiumLimitTypeBioLength = {
    /** The maximum length of the user's bio */
    _: 'premiumLimitTypeBioLength',
  }

  export type premiumLimitTypeBioLength$Input = {
    /** The maximum length of the user's bio */
    readonly _: 'premiumLimitTypeBioLength',
  }

  export type premiumLimitTypeChatFolderInviteLinkCount = {
    /** The maximum number of invite links for a chat folder */
    _: 'premiumLimitTypeChatFolderInviteLinkCount',
  }

  export type premiumLimitTypeChatFolderInviteLinkCount$Input = {
    /** The maximum number of invite links for a chat folder */
    readonly _: 'premiumLimitTypeChatFolderInviteLinkCount',
  }

  export type premiumLimitTypeShareableChatFolderCount = {
    /** The maximum number of added shareable chat folders */
    _: 'premiumLimitTypeShareableChatFolderCount',
  }

  export type premiumLimitTypeShareableChatFolderCount$Input = {
    /** The maximum number of added shareable chat folders */
    readonly _: 'premiumLimitTypeShareableChatFolderCount',
  }

  export type premiumLimitTypeActiveStoryCount = {
    /** The maximum number of active stories */
    _: 'premiumLimitTypeActiveStoryCount',
  }

  export type premiumLimitTypeActiveStoryCount$Input = {
    /** The maximum number of active stories */
    readonly _: 'premiumLimitTypeActiveStoryCount',
  }

  export type premiumLimitTypeWeeklySentStoryCount = {
    /** The maximum number of stories sent per week */
    _: 'premiumLimitTypeWeeklySentStoryCount',
  }

  export type premiumLimitTypeWeeklySentStoryCount$Input = {
    /** The maximum number of stories sent per week */
    readonly _: 'premiumLimitTypeWeeklySentStoryCount',
  }

  export type premiumLimitTypeMonthlySentStoryCount = {
    /** The maximum number of stories sent per month */
    _: 'premiumLimitTypeMonthlySentStoryCount',
  }

  export type premiumLimitTypeMonthlySentStoryCount$Input = {
    /** The maximum number of stories sent per month */
    readonly _: 'premiumLimitTypeMonthlySentStoryCount',
  }

  export type premiumLimitTypeStoryCaptionLength = {
    /** The maximum length of captions of sent stories */
    _: 'premiumLimitTypeStoryCaptionLength',
  }

  export type premiumLimitTypeStoryCaptionLength$Input = {
    /** The maximum length of captions of sent stories */
    readonly _: 'premiumLimitTypeStoryCaptionLength',
  }

  export type premiumLimitTypeStorySuggestedReactionAreaCount = {
    /** The maximum number of suggested reaction areas on a story */
    _: 'premiumLimitTypeStorySuggestedReactionAreaCount',
  }

  export type premiumLimitTypeStorySuggestedReactionAreaCount$Input = {
    /** The maximum number of suggested reaction areas on a story */
    readonly _: 'premiumLimitTypeStorySuggestedReactionAreaCount',
  }

  export type premiumFeatureIncreasedLimits = {
    /** Increased limits */
    _: 'premiumFeatureIncreasedLimits',
  }

  export type premiumFeatureIncreasedLimits$Input = {
    /** Increased limits */
    readonly _: 'premiumFeatureIncreasedLimits',
  }

  export type premiumFeatureIncreasedUploadFileSize = {
    /** Increased maximum upload file size */
    _: 'premiumFeatureIncreasedUploadFileSize',
  }

  export type premiumFeatureIncreasedUploadFileSize$Input = {
    /** Increased maximum upload file size */
    readonly _: 'premiumFeatureIncreasedUploadFileSize',
  }

  export type premiumFeatureImprovedDownloadSpeed = {
    /** Improved download speed */
    _: 'premiumFeatureImprovedDownloadSpeed',
  }

  export type premiumFeatureImprovedDownloadSpeed$Input = {
    /** Improved download speed */
    readonly _: 'premiumFeatureImprovedDownloadSpeed',
  }

  export type premiumFeatureVoiceRecognition = {
    /** The ability to convert voice notes to text */
    _: 'premiumFeatureVoiceRecognition',
  }

  export type premiumFeatureVoiceRecognition$Input = {
    /** The ability to convert voice notes to text */
    readonly _: 'premiumFeatureVoiceRecognition',
  }

  export type premiumFeatureDisabledAds = {
    /** Disabled ads */
    _: 'premiumFeatureDisabledAds',
  }

  export type premiumFeatureDisabledAds$Input = {
    /** Disabled ads */
    readonly _: 'premiumFeatureDisabledAds',
  }

  export type premiumFeatureUniqueReactions = {
    /** Allowed to use more reactions */
    _: 'premiumFeatureUniqueReactions',
  }

  export type premiumFeatureUniqueReactions$Input = {
    /** Allowed to use more reactions */
    readonly _: 'premiumFeatureUniqueReactions',
  }

  export type premiumFeatureUniqueStickers = {
    /** Allowed to use premium stickers with unique effects */
    _: 'premiumFeatureUniqueStickers',
  }

  export type premiumFeatureUniqueStickers$Input = {
    /** Allowed to use premium stickers with unique effects */
    readonly _: 'premiumFeatureUniqueStickers',
  }

  export type premiumFeatureCustomEmoji = {
    /** Allowed to use custom emoji stickers in message texts and captions */
    _: 'premiumFeatureCustomEmoji',
  }

  export type premiumFeatureCustomEmoji$Input = {
    /** Allowed to use custom emoji stickers in message texts and captions */
    readonly _: 'premiumFeatureCustomEmoji',
  }

  export type premiumFeatureAdvancedChatManagement = {
    /**
     * Ability to change position of the main chat list, archive and mute all new chats
     * from non-contacts, and completely disable notifications about the user's contacts
     * joined Telegram
     */
    _: 'premiumFeatureAdvancedChatManagement',
  }

  export type premiumFeatureAdvancedChatManagement$Input = {
    /**
     * Ability to change position of the main chat list, archive and mute all new chats
     * from non-contacts, and completely disable notifications about the user's contacts
     * joined Telegram
     */
    readonly _: 'premiumFeatureAdvancedChatManagement',
  }

  export type premiumFeatureProfileBadge = {
    /** A badge in the user's profile */
    _: 'premiumFeatureProfileBadge',
  }

  export type premiumFeatureProfileBadge$Input = {
    /** A badge in the user's profile */
    readonly _: 'premiumFeatureProfileBadge',
  }

  export type premiumFeatureEmojiStatus = {
    /** An emoji status shown along with the user's name */
    _: 'premiumFeatureEmojiStatus',
  }

  export type premiumFeatureEmojiStatus$Input = {
    /** An emoji status shown along with the user's name */
    readonly _: 'premiumFeatureEmojiStatus',
  }

  export type premiumFeatureAnimatedProfilePhoto = {
    /** Profile photo animation on message and chat screens */
    _: 'premiumFeatureAnimatedProfilePhoto',
  }

  export type premiumFeatureAnimatedProfilePhoto$Input = {
    /** Profile photo animation on message and chat screens */
    readonly _: 'premiumFeatureAnimatedProfilePhoto',
  }

  export type premiumFeatureForumTopicIcon = {
    /** The ability to set a custom emoji as a forum topic icon */
    _: 'premiumFeatureForumTopicIcon',
  }

  export type premiumFeatureForumTopicIcon$Input = {
    /** The ability to set a custom emoji as a forum topic icon */
    readonly _: 'premiumFeatureForumTopicIcon',
  }

  export type premiumFeatureAppIcons = {
    /** Allowed to set a premium application icons */
    _: 'premiumFeatureAppIcons',
  }

  export type premiumFeatureAppIcons$Input = {
    /** Allowed to set a premium application icons */
    readonly _: 'premiumFeatureAppIcons',
  }

  export type premiumFeatureRealTimeChatTranslation = {
    /** Allowed to translate chat messages real-time */
    _: 'premiumFeatureRealTimeChatTranslation',
  }

  export type premiumFeatureRealTimeChatTranslation$Input = {
    /** Allowed to translate chat messages real-time */
    readonly _: 'premiumFeatureRealTimeChatTranslation',
  }

  export type premiumFeatureUpgradedStories = {
    /** Allowed to use many additional features for stories */
    _: 'premiumFeatureUpgradedStories',
  }

  export type premiumFeatureUpgradedStories$Input = {
    /** Allowed to use many additional features for stories */
    readonly _: 'premiumFeatureUpgradedStories',
  }

  export type premiumFeatureChatBoost = {
    /** The ability to boost chats */
    _: 'premiumFeatureChatBoost',
  }

  export type premiumFeatureChatBoost$Input = {
    /** The ability to boost chats */
    readonly _: 'premiumFeatureChatBoost',
  }

  export type premiumStoryFeaturePriorityOrder$Input = {
    /** User stories are displayed before stories of non-premium contacts and channels */
    readonly _: 'premiumStoryFeaturePriorityOrder',
  }

  export type premiumStoryFeatureStealthMode$Input = {
    /** The ability to hide the fact that the user viewed other's stories */
    readonly _: 'premiumStoryFeatureStealthMode',
  }

  export type premiumStoryFeaturePermanentViewsHistory$Input = {
    /** The ability to check who opened the current user's stories after they expire */
    readonly _: 'premiumStoryFeaturePermanentViewsHistory',
  }

  export type premiumStoryFeatureCustomExpirationDuration$Input = {
    /** The ability to set custom expiration duration for stories */
    readonly _: 'premiumStoryFeatureCustomExpirationDuration',
  }

  export type premiumStoryFeatureSaveStories$Input = {
    /** The ability to save other's unprotected stories */
    readonly _: 'premiumStoryFeatureSaveStories',
  }

  export type premiumStoryFeatureLinksAndFormatting$Input = {
    /** The ability to use links and formatting in story caption */
    readonly _: 'premiumStoryFeatureLinksAndFormatting',
  }

  export type premiumLimit = {
    /** Contains information about a limit, increased for Premium users */
    _: 'premiumLimit',
    /** The type of the limit */
    type: PremiumLimitType,
    /** Default value of the limit */
    default_value: number,
    /** Value of the limit for Premium users */
    premium_value: number,
  }

  export type premiumFeatures = {
    /** Contains information about features, available to Premium users */
    _: 'premiumFeatures',
    /** The list of available features */
    features: Array<PremiumFeature>,
    /** The list of limits, increased for Premium users */
    limits: Array<premiumLimit>,
    /**
     * An internal link to be opened to pay for Telegram Premium if store payment isn't
     * possible; may be null if direct payment isn't available
     */
    payment_link?: InternalLinkType,
  }

  export type premiumSourceLimitExceeded$Input = {
    /** A limit was exceeded */
    readonly _: 'premiumSourceLimitExceeded',
    /** Type of the exceeded limit */
    readonly limit_type?: PremiumLimitType$Input,
  }

  export type premiumSourceFeature$Input = {
    /** A user tried to use a Premium feature */
    readonly _: 'premiumSourceFeature',
    /** The used feature */
    readonly feature?: PremiumFeature$Input,
  }

  export type premiumSourceStoryFeature$Input = {
    /** A user tried to use a Premium story feature */
    readonly _: 'premiumSourceStoryFeature',
    /** The used feature */
    readonly feature?: PremiumStoryFeature$Input,
  }

  export type premiumSourceLink$Input = {
    /** A user opened an internal link of the type internalLinkTypePremiumFeatures */
    readonly _: 'premiumSourceLink',
    /** The referrer from the link */
    readonly referrer?: string,
  }

  export type premiumSourceSettings$Input = {
    /** A user opened the Premium features screen from settings */
    readonly _: 'premiumSourceSettings',
  }

  export type premiumFeaturePromotionAnimation = {
    /** Describes a promotion animation for a Premium feature */
    _: 'premiumFeaturePromotionAnimation',
    /** Premium feature */
    feature: PremiumFeature,
    /** Promotion animation for the feature */
    animation: animation,
  }

  export type premiumState = {
    /**
     * Contains state of Telegram Premium subscription and promotion videos for Premium
     * features
     */
    _: 'premiumState',
    /**
     * Text description of the state of the current Premium subscription; may be empty
     * if the current user has no Telegram Premium subscription
     */
    state: formattedText,
    /** The list of available options for buying Telegram Premium */
    payment_options: Array<premiumStatePaymentOption>,
    /** The list of available promotion animations for Premium features */
    animations: Array<premiumFeaturePromotionAnimation>,
  }

  export type storePaymentPurposePremiumSubscription$Input = {
    /** The user subscribed to Telegram Premium */
    readonly _: 'storePaymentPurposePremiumSubscription',
    /**
     * Pass true if this is a restore of a Telegram Premium purchase; only for App
     * Store
     */
    readonly is_restore?: boolean,
    /**
     * Pass true if this is an upgrade from a monthly subscription to early subscription;
     * only for App Store
     */
    readonly is_upgrade?: boolean,
  }

  export type storePaymentPurposeGiftedPremium$Input = {
    /** The user gifted Telegram Premium to another user */
    readonly _: 'storePaymentPurposeGiftedPremium',
    /** Identifier of the user for which Premium was gifted */
    readonly user_id?: number,
    /** ISO 4217 currency code of the payment currency */
    readonly currency?: string,
    /** Paid amount, in the smallest units of the currency */
    readonly amount?: number,
  }

  export type deviceTokenFirebaseCloudMessaging$Input = {
    /** A token for Firebase Cloud Messaging */
    readonly _: 'deviceTokenFirebaseCloudMessaging',
    /** Device registration token; may be empty to deregister a device */
    readonly token?: string,
    /** True, if push notifications must be additionally encrypted */
    readonly encrypt?: boolean,
  }

  export type deviceTokenApplePush$Input = {
    /** A token for Apple Push Notification service */
    readonly _: 'deviceTokenApplePush',
    /** Device token; may be empty to deregister a device */
    readonly device_token?: string,
    /** True, if App Sandbox is enabled */
    readonly is_app_sandbox?: boolean,
  }

  export type deviceTokenApplePushVoIP$Input = {
    /** A token for Apple Push Notification service VoIP notifications */
    readonly _: 'deviceTokenApplePushVoIP',
    /** Device token; may be empty to deregister a device */
    readonly device_token?: string,
    /** True, if App Sandbox is enabled */
    readonly is_app_sandbox?: boolean,
    /** True, if push notifications must be additionally encrypted */
    readonly encrypt?: boolean,
  }

  export type deviceTokenWindowsPush$Input = {
    /** A token for Windows Push Notification Services */
    readonly _: 'deviceTokenWindowsPush',
    /**
     * The access token that will be used to send notifications; may be empty to deregister
     * a device
     */
    readonly access_token?: string,
  }

  export type deviceTokenMicrosoftPush$Input = {
    /** A token for Microsoft Push Notification Service */
    readonly _: 'deviceTokenMicrosoftPush',
    /** Push notification channel URI; may be empty to deregister a device */
    readonly channel_uri?: string,
  }

  export type deviceTokenMicrosoftPushVoIP$Input = {
    /** A token for Microsoft Push Notification Service VoIP channel */
    readonly _: 'deviceTokenMicrosoftPushVoIP',
    /** Push notification channel URI; may be empty to deregister a device */
    readonly channel_uri?: string,
  }

  export type deviceTokenWebPush$Input = {
    /** A token for web Push API */
    readonly _: 'deviceTokenWebPush',
    /**
     * Absolute URL exposed by the push service where the application server can send
     * push messages; may be empty to deregister a device
     */
    readonly endpoint?: string,
    /** Base64url-encoded P-256 elliptic curve Diffie-Hellman public key */
    readonly p256dh_base64url?: string,
    /** Base64url-encoded authentication secret */
    readonly auth_base64url?: string,
  }

  export type deviceTokenSimplePush$Input = {
    /** A token for Simple Push API for Firefox OS */
    readonly _: 'deviceTokenSimplePush',
    /**
     * Absolute URL exposed by the push service where the application server can send
     * push messages; may be empty to deregister a device
     */
    readonly endpoint?: string,
  }

  export type deviceTokenUbuntuPush$Input = {
    /** A token for Ubuntu Push Client service */
    readonly _: 'deviceTokenUbuntuPush',
    /** Token; may be empty to deregister a device */
    readonly token?: string,
  }

  export type deviceTokenBlackBerryPush$Input = {
    /** A token for BlackBerry Push Service */
    readonly _: 'deviceTokenBlackBerryPush',
    /** Token; may be empty to deregister a device */
    readonly token?: string,
  }

  export type deviceTokenTizenPush$Input = {
    /** A token for Tizen Push Service */
    readonly _: 'deviceTokenTizenPush',
    /** Push service registration identifier; may be empty to deregister a device */
    readonly reg_id?: string,
  }

  export type deviceTokenHuaweiPush$Input = {
    /** A token for HUAWEI Push Service */
    readonly _: 'deviceTokenHuaweiPush',
    /** Device registration token; may be empty to deregister a device */
    readonly token?: string,
    /** True, if push notifications must be additionally encrypted */
    readonly encrypt?: boolean,
  }

  export type pushReceiverId = {
    /**
     * Contains a globally unique push receiver identifier, which can be used to identify
     * which account has received a push notification
     */
    _: 'pushReceiverId',
    /** The globally unique identifier of push notification subscription */
    id: number | string,
  }

  export type backgroundFillSolid = {
    /** Describes a solid fill of a background */
    _: 'backgroundFillSolid',
    /** A color of the background in the RGB24 format */
    color: number,
  }

  export type backgroundFillSolid$Input = {
    /** Describes a solid fill of a background */
    readonly _: 'backgroundFillSolid',
    /** A color of the background in the RGB24 format */
    readonly color?: number,
  }

  export type backgroundFillGradient = {
    /** Describes a gradient fill of a background */
    _: 'backgroundFillGradient',
    /** A top color of the background in the RGB24 format */
    top_color: number,
    /** A bottom color of the background in the RGB24 format */
    bottom_color: number,
    /**
     * Clockwise rotation angle of the gradient, in degrees; 0-359. Must always be
     * divisible by 45
     */
    rotation_angle: number,
  }

  export type backgroundFillGradient$Input = {
    /** Describes a gradient fill of a background */
    readonly _: 'backgroundFillGradient',
    /** A top color of the background in the RGB24 format */
    readonly top_color?: number,
    /** A bottom color of the background in the RGB24 format */
    readonly bottom_color?: number,
    /**
     * Clockwise rotation angle of the gradient, in degrees; 0-359. Must always be
     * divisible by 45
     */
    readonly rotation_angle?: number,
  }

  export type backgroundFillFreeformGradient = {
    /** Describes a freeform gradient fill of a background */
    _: 'backgroundFillFreeformGradient',
    /** A list of 3 or 4 colors of the freeform gradients in the RGB24 format */
    colors: Array<number>,
  }

  export type backgroundFillFreeformGradient$Input = {
    /** Describes a freeform gradient fill of a background */
    readonly _: 'backgroundFillFreeformGradient',
    /** A list of 3 or 4 colors of the freeform gradients in the RGB24 format */
    readonly colors?: ReadonlyArray<number>,
  }

  export type backgroundTypeWallpaper = {
    /** A wallpaper in JPEG format */
    _: 'backgroundTypeWallpaper',
    /**
     * True, if the wallpaper must be downscaled to fit in 450x450 square and then
     * box-blurred with radius 12
     */
    is_blurred: boolean,
    /** True, if the background needs to be slightly moved when device is tilted */
    is_moving: boolean,
  }

  export type backgroundTypeWallpaper$Input = {
    /** A wallpaper in JPEG format */
    readonly _: 'backgroundTypeWallpaper',
    /**
     * True, if the wallpaper must be downscaled to fit in 450x450 square and then
     * box-blurred with radius 12
     */
    readonly is_blurred?: boolean,
    /** True, if the background needs to be slightly moved when device is tilted */
    readonly is_moving?: boolean,
  }

  export type backgroundTypePattern = {
    /**
     * A PNG or TGV (gzipped subset of SVG with MIME type "application/x-tgwallpattern")
     * pattern to be combined with the background fill chosen by the user
     */
    _: 'backgroundTypePattern',
    /** Fill of the background */
    fill: BackgroundFill,
    /** Intensity of the pattern when it is shown above the filled background; 0-100. */
    intensity: number,
    /**
     * True, if the background fill must be applied only to the pattern itself. All
     * other pixels are black in this case. For dark themes only
     */
    is_inverted: boolean,
    /** True, if the background needs to be slightly moved when device is tilted */
    is_moving: boolean,
  }

  export type backgroundTypePattern$Input = {
    /**
     * A PNG or TGV (gzipped subset of SVG with MIME type "application/x-tgwallpattern")
     * pattern to be combined with the background fill chosen by the user
     */
    readonly _: 'backgroundTypePattern',
    /** Fill of the background */
    readonly fill?: BackgroundFill$Input,
    /** Intensity of the pattern when it is shown above the filled background; 0-100. */
    readonly intensity?: number,
    /**
     * True, if the background fill must be applied only to the pattern itself. All
     * other pixels are black in this case. For dark themes only
     */
    readonly is_inverted?: boolean,
    /** True, if the background needs to be slightly moved when device is tilted */
    readonly is_moving?: boolean,
  }

  export type backgroundTypeFill = {
    /** A filled background */
    _: 'backgroundTypeFill',
    /** The background fill */
    fill: BackgroundFill,
  }

  export type backgroundTypeFill$Input = {
    /** A filled background */
    readonly _: 'backgroundTypeFill',
    /** The background fill */
    readonly fill?: BackgroundFill$Input,
  }

  export type inputBackgroundLocal$Input = {
    /** A background from a local file */
    readonly _: 'inputBackgroundLocal',
    /**
     * Background file to use. Only inputFileLocal and inputFileGenerated are supported.
     * The file must be in JPEG format for wallpapers and in PNG format for patterns
     */
    readonly background?: InputFile$Input,
  }

  export type inputBackgroundRemote$Input = {
    /** A background from the server */
    readonly _: 'inputBackgroundRemote',
    /** The background identifier */
    readonly background_id?: number | string,
  }

  export type inputBackgroundPrevious$Input = {
    /** A background previously set in the chat; for chat backgrounds only */
    readonly _: 'inputBackgroundPrevious',
    /** Identifier of the message with the background */
    readonly message_id?: number,
  }

  export type themeSettings = {
    /** Describes theme settings */
    _: 'themeSettings',
    /** Theme accent color in ARGB format */
    accent_color: number,
    /** The background to be used in chats; may be null */
    background?: background,
    /** The fill to be used as a background for outgoing messages */
    outgoing_message_fill: BackgroundFill,
    /** If true, the freeform gradient fill needs to be animated on every sent message */
    animate_outgoing_message_fill: boolean,
    /** Accent color of outgoing messages in ARGB format */
    outgoing_message_accent_color: number,
  }

  export type chatTheme = {
    /** Describes a chat theme */
    _: 'chatTheme',
    /** Theme name */
    name: string,
    /** Theme settings for a light chat theme */
    light_settings: themeSettings,
    /** Theme settings for a dark chat theme */
    dark_settings: themeSettings,
  }

  export type hashtags = {
    /** Contains a list of hashtags */
    _: 'hashtags',
    /** A list of hashtags */
    hashtags: Array<string>,
  }

  export type canSendStoryResultOk = {
    /** A story can be sent */
    _: 'canSendStoryResultOk',
  }

  export type canSendStoryResultPremiumNeeded = {
    /** The user must subscribe to Telegram Premium to be able to post stories */
    _: 'canSendStoryResultPremiumNeeded',
  }

  export type canSendStoryResultBoostNeeded = {
    /**
     * The channel chat must be boosted first by Telegram Premium subscribers to post
     * more stories. Call getChatBoostStatus to get current boost status of the chat
     */
    _: 'canSendStoryResultBoostNeeded',
  }

  export type canSendStoryResultActiveStoryLimitExceeded = {
    /**
     * The limit for the number of active stories exceeded. The user can buy Telegram
     * Premium, delete an active story, or wait for the oldest story to expire
     */
    _: 'canSendStoryResultActiveStoryLimitExceeded',
  }

  export type canSendStoryResultWeeklyLimitExceeded = {
    /**
     * The weekly limit for the number of posted stories exceeded. The user needs to
     * buy Telegram Premium or wait specified time
     */
    _: 'canSendStoryResultWeeklyLimitExceeded',
    /** Time left before the user can send the next story */
    retry_after: number,
  }

  export type canSendStoryResultMonthlyLimitExceeded = {
    /**
     * The monthly limit for the number of posted stories exceeded. The user needs
     * to buy Telegram Premium or wait specified time
     */
    _: 'canSendStoryResultMonthlyLimitExceeded',
    /** Time left before the user can send the next story */
    retry_after: number,
  }

  export type canBoostChatResultOk = {
    /** The chat can be boosted */
    _: 'canBoostChatResultOk',
    /**
     * Identifier of the currently boosted chat from which boost will be removed; 0
     * if none
     */
    currently_boosted_chat_id: number,
  }

  export type canBoostChatResultInvalidChat = {
    /** The chat can't be boosted */
    _: 'canBoostChatResultInvalidChat',
  }

  export type canBoostChatResultAlreadyBoosted = {
    /** The chat is already boosted by the user */
    _: 'canBoostChatResultAlreadyBoosted',
  }

  export type canBoostChatResultPremiumNeeded = {
    /** The user must subscribe to Telegram Premium to be able to boost chats */
    _: 'canBoostChatResultPremiumNeeded',
  }

  export type canBoostChatResultPremiumSubscriptionNeeded = {
    /**
     * The user must have Telegram Premium subscription instead of a gifted Telegram
     * Premium
     */
    _: 'canBoostChatResultPremiumSubscriptionNeeded',
  }

  export type canBoostChatResultWaitNeeded = {
    /**
     * The user must wait the specified time before the boost can be moved to another
     * chat
     */
    _: 'canBoostChatResultWaitNeeded',
    /** Time left before the user can boost another chat */
    retry_after: number,
  }

  export type canTransferOwnershipResultOk = {
    /** The session can be used */
    _: 'canTransferOwnershipResultOk',
  }

  export type canTransferOwnershipResultPasswordNeeded = {
    /** The 2-step verification needs to be enabled first */
    _: 'canTransferOwnershipResultPasswordNeeded',
  }

  export type canTransferOwnershipResultPasswordTooFresh = {
    /** The 2-step verification was enabled recently, user needs to wait */
    _: 'canTransferOwnershipResultPasswordTooFresh',
    /**
     * Time left before the session can be used to transfer ownership of a chat, in
     * seconds
     */
    retry_after: number,
  }

  export type canTransferOwnershipResultSessionTooFresh = {
    /** The session was created recently, user needs to wait */
    _: 'canTransferOwnershipResultSessionTooFresh',
    /**
     * Time left before the session can be used to transfer ownership of a chat, in
     * seconds
     */
    retry_after: number,
  }

  export type checkChatUsernameResultOk = {
    /** The username can be set */
    _: 'checkChatUsernameResultOk',
  }

  export type checkChatUsernameResultUsernameInvalid = {
    /** The username is invalid */
    _: 'checkChatUsernameResultUsernameInvalid',
  }

  export type checkChatUsernameResultUsernameOccupied = {
    /** The username is occupied */
    _: 'checkChatUsernameResultUsernameOccupied',
  }

  export type checkChatUsernameResultUsernamePurchasable = {
    /** The username can be purchased at fragment.com */
    _: 'checkChatUsernameResultUsernamePurchasable',
  }

  export type checkChatUsernameResultPublicChatsTooMany = {
    /**
     * The user has too many chats with username, one of them must be made private
     * first
     */
    _: 'checkChatUsernameResultPublicChatsTooMany',
  }

  export type checkChatUsernameResultPublicGroupsUnavailable = {
    /** The user can't be a member of a public supergroup */
    _: 'checkChatUsernameResultPublicGroupsUnavailable',
  }

  export type checkStickerSetNameResultOk = {
    /** The name can be set */
    _: 'checkStickerSetNameResultOk',
  }

  export type checkStickerSetNameResultNameInvalid = {
    /** The name is invalid */
    _: 'checkStickerSetNameResultNameInvalid',
  }

  export type checkStickerSetNameResultNameOccupied = {
    /** The name is occupied */
    _: 'checkStickerSetNameResultNameOccupied',
  }

  export type resetPasswordResultOk = {
    /** The password was reset */
    _: 'resetPasswordResultOk',
  }

  export type resetPasswordResultPending = {
    /** The password reset request is pending */
    _: 'resetPasswordResultPending',
    /**
     * Point in time (Unix timestamp) after which the password can be reset immediately
     * using resetPassword
     */
    pending_reset_date: number,
  }

  export type resetPasswordResultDeclined = {
    /** The password reset request was declined */
    _: 'resetPasswordResultDeclined',
    /** Point in time (Unix timestamp) when the password reset can be retried */
    retry_date: number,
  }

  export type messageFileTypePrivate = {
    /** The messages was exported from a private chat */
    _: 'messageFileTypePrivate',
    /** Name of the other party; may be empty if unrecognized */
    name: string,
  }

  export type messageFileTypeGroup = {
    /** The messages was exported from a group chat */
    _: 'messageFileTypeGroup',
    /** Title of the group chat; may be empty if unrecognized */
    title: string,
  }

  export type messageFileTypeUnknown = {
    /** The messages was exported from a chat of unknown type */
    _: 'messageFileTypeUnknown',
  }

  export type pushMessageContentHidden = {
    /** A general message with hidden content */
    _: 'pushMessageContentHidden',
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentAnimation = {
    /** An animation message (GIF-style). */
    _: 'pushMessageContentAnimation',
    /** Message content; may be null */
    animation?: animation,
    /** Animation caption */
    caption: string,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentAudio = {
    /** An audio message */
    _: 'pushMessageContentAudio',
    /** Message content; may be null */
    audio?: audio,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentContact = {
    /** A message with a user contact */
    _: 'pushMessageContentContact',
    /** Contact's name */
    name: string,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentContactRegistered = {
    /** A contact has registered with Telegram */
    _: 'pushMessageContentContactRegistered',
  }

  export type pushMessageContentDocument = {
    /** A document message (a general file) */
    _: 'pushMessageContentDocument',
    /** Message content; may be null */
    document?: document,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentGame = {
    /** A message with a game */
    _: 'pushMessageContentGame',
    /** Game title, empty for pinned game message */
    title: string,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentGameScore = {
    /** A new high score was achieved in a game */
    _: 'pushMessageContentGameScore',
    /** Game title, empty for pinned message */
    title: string,
    /** New score, 0 for pinned message */
    score: number,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentInvoice = {
    /** A message with an invoice from a bot */
    _: 'pushMessageContentInvoice',
    /** Product price */
    price: string,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentLocation = {
    /** A message with a location */
    _: 'pushMessageContentLocation',
    /** True, if the location is live */
    is_live: boolean,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentPhoto = {
    /** A photo message */
    _: 'pushMessageContentPhoto',
    /** Message content; may be null */
    photo?: photo,
    /** Photo caption */
    caption: string,
    /** True, if the photo is secret */
    is_secret: boolean,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentPoll = {
    /** A message with a poll */
    _: 'pushMessageContentPoll',
    /** Poll question */
    question: string,
    /** True, if the poll is regular and not in quiz mode */
    is_regular: boolean,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentScreenshotTaken = {
    /** A screenshot of a message in the chat has been taken */
    _: 'pushMessageContentScreenshotTaken',
  }

  export type pushMessageContentSticker = {
    /** A message with a sticker */
    _: 'pushMessageContentSticker',
    /** Message content; may be null */
    sticker?: sticker,
    /** Emoji corresponding to the sticker; may be empty */
    emoji: string,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentStory = {
    /** A message with a story */
    _: 'pushMessageContentStory',
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentText = {
    /** A text message */
    _: 'pushMessageContentText',
    /** Message text */
    text: string,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentVideo = {
    /** A video message */
    _: 'pushMessageContentVideo',
    /** Message content; may be null */
    video?: video,
    /** Video caption */
    caption: string,
    /** True, if the video is secret */
    is_secret: boolean,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentVideoNote = {
    /** A video note message */
    _: 'pushMessageContentVideoNote',
    /** Message content; may be null */
    video_note?: videoNote,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentVoiceNote = {
    /** A voice note message */
    _: 'pushMessageContentVoiceNote',
    /** Message content; may be null */
    voice_note?: voiceNote,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentBasicGroupChatCreate = {
    /** A newly created basic group */
    _: 'pushMessageContentBasicGroupChatCreate',
  }

  export type pushMessageContentChatAddMembers = {
    /** New chat members were invited to a group */
    _: 'pushMessageContentChatAddMembers',
    /** Name of the added member */
    member_name: string,
    /** True, if the current user was added to the group */
    is_current_user: boolean,
    /** True, if the user has returned to the group themselves */
    is_returned: boolean,
  }

  export type pushMessageContentChatChangePhoto = {
    /** A chat photo was edited */
    _: 'pushMessageContentChatChangePhoto',
  }

  export type pushMessageContentChatChangeTitle = {
    /** A chat title was edited */
    _: 'pushMessageContentChatChangeTitle',
    /** New chat title */
    title: string,
  }

  export type pushMessageContentChatSetBackground = {
    /** A chat background was edited */
    _: 'pushMessageContentChatSetBackground',
    /** True, if the set background is the same as the background of the current user */
    is_same: boolean,
  }

  export type pushMessageContentChatSetTheme = {
    /** A chat theme was edited */
    _: 'pushMessageContentChatSetTheme',
    /**
     * If non-empty, name of a new theme, set for the chat. Otherwise, the chat theme
     * was reset to the default one
     */
    theme_name: string,
  }

  export type pushMessageContentChatDeleteMember = {
    /** A chat member was deleted */
    _: 'pushMessageContentChatDeleteMember',
    /** Name of the deleted member */
    member_name: string,
    /** True, if the current user was deleted from the group */
    is_current_user: boolean,
    /** True, if the user has left the group themselves */
    is_left: boolean,
  }

  export type pushMessageContentChatJoinByLink = {
    /** A new member joined the chat via an invite link */
    _: 'pushMessageContentChatJoinByLink',
  }

  export type pushMessageContentChatJoinByRequest = {
    /** A new member was accepted to the chat by an administrator */
    _: 'pushMessageContentChatJoinByRequest',
  }

  export type pushMessageContentRecurringPayment = {
    /** A new recurring payment was made by the current user */
    _: 'pushMessageContentRecurringPayment',
    /** The paid amount */
    amount: string,
  }

  export type pushMessageContentSuggestProfilePhoto = {
    /** A profile photo was suggested to the user */
    _: 'pushMessageContentSuggestProfilePhoto',
  }

  export type pushMessageContentMessageForwards = {
    /** A forwarded messages */
    _: 'pushMessageContentMessageForwards',
    /** Number of forwarded messages */
    total_count: number,
  }

  export type pushMessageContentMediaAlbum = {
    /** A media album */
    _: 'pushMessageContentMediaAlbum',
    /** Number of messages in the album */
    total_count: number,
    /** True, if the album has at least one photo */
    has_photos: boolean,
    /** True, if the album has at least one video file */
    has_videos: boolean,
    /** True, if the album has at least one audio file */
    has_audios: boolean,
    /** True, if the album has at least one document */
    has_documents: boolean,
  }

  export type notificationTypeNewMessage = {
    /** New message was received */
    _: 'notificationTypeNewMessage',
    /** The message */
    message: message,
    /** True, if message content must be displayed in notifications */
    show_preview: boolean,
  }

  export type notificationTypeNewSecretChat = {
    /** New secret chat was created */
    _: 'notificationTypeNewSecretChat',
  }

  export type notificationTypeNewCall = {
    /** New call was received */
    _: 'notificationTypeNewCall',
    /** Call identifier */
    call_id: number,
  }

  export type notificationTypeNewPushMessage = {
    /** New message was received through a push notification */
    _: 'notificationTypeNewPushMessage',
    /**
     * The message identifier. The message will not be available in the chat history,
     * but the identifier can be used in viewMessages, or as a message to reply
     */
    message_id: number,
    /** Identifier of the sender of the message. Corresponding user or chat may be inaccessible */
    sender_id: MessageSender,
    /** Name of the sender */
    sender_name: string,
    /** True, if the message is outgoing */
    is_outgoing: boolean,
    /** Push message content */
    content: PushMessageContent,
  }

  export type notificationGroupTypeMessages = {
    /**
     * A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage
     * with ordinary unread messages
     */
    _: 'notificationGroupTypeMessages',
  }

  export type notificationGroupTypeMentions = {
    /**
     * A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage
     * with unread mentions of the current user, replies to their messages, or a pinned
     * message
     */
    _: 'notificationGroupTypeMentions',
  }

  export type notificationGroupTypeSecretChat = {
    /** A group containing a notification of type notificationTypeNewSecretChat */
    _: 'notificationGroupTypeSecretChat',
  }

  export type notificationGroupTypeCalls = {
    /** A group containing notifications of type notificationTypeNewCall */
    _: 'notificationGroupTypeCalls',
  }

  export type notificationSound = {
    /** Describes a notification sound in MP3 format */
    _: 'notificationSound',
    /** Unique identifier of the notification sound */
    id: number | string,
    /** Duration of the sound, in seconds */
    duration: number,
    /** Point in time (Unix timestamp) when the sound was created */
    date: number,
    /** Title of the notification sound */
    title: string,
    /** Arbitrary data, defined while the sound was uploaded */
    data: string,
    /** File containing the sound */
    sound: file,
  }

  export type notificationSounds = {
    /** Contains a list of notification sounds */
    _: 'notificationSounds',
    /** A list of notification sounds */
    notification_sounds: Array<notificationSound>,
  }

  export type notification = {
    /** Contains information about a notification */
    _: 'notification',
    /** Unique persistent identifier of this notification */
    id: number,
    /** Notification date */
    date: number,
    /** True, if the notification was explicitly sent without sound */
    is_silent: boolean,
    /** Notification type */
    type: NotificationType,
  }

  export type notificationGroup = {
    /** Describes a group of notifications */
    _: 'notificationGroup',
    /** Unique persistent auto-incremented from 1 identifier of the notification group */
    id: number,
    /** Type of the group */
    type: NotificationGroupType,
    /** Identifier of a chat to which all notifications in the group belong */
    chat_id: number,
    /** Total number of active notifications in the group */
    total_count: number,
    /** The list of active notifications */
    notifications: Array<notification>,
  }

  export type optionValueBoolean = {
    /** Represents a boolean option */
    _: 'optionValueBoolean',
    /** The value of the option */
    value: boolean,
  }

  export type optionValueBoolean$Input = {
    /** Represents a boolean option */
    readonly _: 'optionValueBoolean',
    /** The value of the option */
    readonly value?: boolean,
  }

  export type optionValueEmpty = {
    /** Represents an unknown option or an option which has a default value */
    _: 'optionValueEmpty',
  }

  export type optionValueEmpty$Input = {
    /** Represents an unknown option or an option which has a default value */
    readonly _: 'optionValueEmpty',
  }

  export type optionValueInteger = {
    /** Represents an integer option */
    _: 'optionValueInteger',
    /** The value of the option */
    value: number | string,
  }

  export type optionValueInteger$Input = {
    /** Represents an integer option */
    readonly _: 'optionValueInteger',
    /** The value of the option */
    readonly value?: number | string,
  }

  export type optionValueString = {
    /** Represents a string option */
    _: 'optionValueString',
    /** The value of the option */
    value: string,
  }

  export type optionValueString$Input = {
    /** Represents a string option */
    readonly _: 'optionValueString',
    /** The value of the option */
    readonly value?: string,
  }

  export type jsonObjectMember = {
    /** Represents one member of a JSON object */
    _: 'jsonObjectMember',
    /** Member's key */
    key: string,
    /** Member's value */
    value: JsonValue,
  }

  export type jsonObjectMember$Input = {
    /** Represents one member of a JSON object */
    readonly _: 'jsonObjectMember',
    /** Member's key */
    readonly key?: string,
    /** Member's value */
    readonly value?: JsonValue$Input,
  }

  export type jsonValueNull = {
    /** Represents a null JSON value */
    _: 'jsonValueNull',
  }

  export type jsonValueNull$Input = {
    /** Represents a null JSON value */
    readonly _: 'jsonValueNull',
  }

  export type jsonValueBoolean = {
    /** Represents a boolean JSON value */
    _: 'jsonValueBoolean',
    /** The value */
    value: boolean,
  }

  export type jsonValueBoolean$Input = {
    /** Represents a boolean JSON value */
    readonly _: 'jsonValueBoolean',
    /** The value */
    readonly value?: boolean,
  }

  export type jsonValueNumber = {
    /** Represents a numeric JSON value */
    _: 'jsonValueNumber',
    /** The value */
    value: number,
  }

  export type jsonValueNumber$Input = {
    /** Represents a numeric JSON value */
    readonly _: 'jsonValueNumber',
    /** The value */
    readonly value?: number,
  }

  export type jsonValueString = {
    /** Represents a string JSON value */
    _: 'jsonValueString',
    /** The value */
    value: string,
  }

  export type jsonValueString$Input = {
    /** Represents a string JSON value */
    readonly _: 'jsonValueString',
    /** The value */
    readonly value?: string,
  }

  export type jsonValueArray = {
    /** Represents a JSON array */
    _: 'jsonValueArray',
    /** The list of array elements */
    values: Array<JsonValue>,
  }

  export type jsonValueArray$Input = {
    /** Represents a JSON array */
    readonly _: 'jsonValueArray',
    /** The list of array elements */
    readonly values?: ReadonlyArray<JsonValue$Input>,
  }

  export type jsonValueObject = {
    /** Represents a JSON object */
    _: 'jsonValueObject',
    /** The list of object members */
    members: Array<jsonObjectMember>,
  }

  export type jsonValueObject$Input = {
    /** Represents a JSON object */
    readonly _: 'jsonValueObject',
    /** The list of object members */
    readonly members?: ReadonlyArray<jsonObjectMember$Input>,
  }

  export type storyPrivacySettingsEveryone = {
    /** The story can be viewed by everyone */
    _: 'storyPrivacySettingsEveryone',
    /**
     * Identifiers of the users that can't see the story; always unknown and empty
     * for non-owned stories
     */
    except_user_ids: Array<number>,
  }

  export type storyPrivacySettingsEveryone$Input = {
    /** The story can be viewed by everyone */
    readonly _: 'storyPrivacySettingsEveryone',
    /**
     * Identifiers of the users that can't see the story; always unknown and empty
     * for non-owned stories
     */
    readonly except_user_ids?: ReadonlyArray<number>,
  }

  export type storyPrivacySettingsContacts = {
    /** The story can be viewed by all contacts except chosen users */
    _: 'storyPrivacySettingsContacts',
    /**
     * User identifiers of the contacts that can't see the story; always unknown and
     * empty for non-owned stories
     */
    except_user_ids: Array<number>,
  }

  export type storyPrivacySettingsContacts$Input = {
    /** The story can be viewed by all contacts except chosen users */
    readonly _: 'storyPrivacySettingsContacts',
    /**
     * User identifiers of the contacts that can't see the story; always unknown and
     * empty for non-owned stories
     */
    readonly except_user_ids?: ReadonlyArray<number>,
  }

  export type storyPrivacySettingsCloseFriends = {
    /** The story can be viewed by all close friends */
    _: 'storyPrivacySettingsCloseFriends',
  }

  export type storyPrivacySettingsCloseFriends$Input = {
    /** The story can be viewed by all close friends */
    readonly _: 'storyPrivacySettingsCloseFriends',
  }

  export type storyPrivacySettingsSelectedUsers = {
    /** The story can be viewed by certain specified users */
    _: 'storyPrivacySettingsSelectedUsers',
    /** Identifiers of the users; always unknown and empty for non-owned stories */
    user_ids: Array<number>,
  }

  export type storyPrivacySettingsSelectedUsers$Input = {
    /** The story can be viewed by certain specified users */
    readonly _: 'storyPrivacySettingsSelectedUsers',
    /** Identifiers of the users; always unknown and empty for non-owned stories */
    readonly user_ids?: ReadonlyArray<number>,
  }

  export type userPrivacySettingRuleAllowAll = {
    /** A rule to allow all users to do something */
    _: 'userPrivacySettingRuleAllowAll',
  }

  export type userPrivacySettingRuleAllowAll$Input = {
    /** A rule to allow all users to do something */
    readonly _: 'userPrivacySettingRuleAllowAll',
  }

  export type userPrivacySettingRuleAllowContacts = {
    /** A rule to allow all contacts of the user to do something */
    _: 'userPrivacySettingRuleAllowContacts',
  }

  export type userPrivacySettingRuleAllowContacts$Input = {
    /** A rule to allow all contacts of the user to do something */
    readonly _: 'userPrivacySettingRuleAllowContacts',
  }

  export type userPrivacySettingRuleAllowUsers = {
    /** A rule to allow certain specified users to do something */
    _: 'userPrivacySettingRuleAllowUsers',
    /** The user identifiers, total number of users in all rules must not exceed 1000 */
    user_ids: Array<number>,
  }

  export type userPrivacySettingRuleAllowUsers$Input = {
    /** A rule to allow certain specified users to do something */
    readonly _: 'userPrivacySettingRuleAllowUsers',
    /** The user identifiers, total number of users in all rules must not exceed 1000 */
    readonly user_ids?: ReadonlyArray<number>,
  }

  export type userPrivacySettingRuleAllowChatMembers = {
    /**
     * A rule to allow all members of certain specified basic groups and supergroups
     * to doing something
     */
    _: 'userPrivacySettingRuleAllowChatMembers',
    /** The chat identifiers, total number of chats in all rules must not exceed 20 */
    chat_ids: Array<number>,
  }

  export type userPrivacySettingRuleAllowChatMembers$Input = {
    /**
     * A rule to allow all members of certain specified basic groups and supergroups
     * to doing something
     */
    readonly _: 'userPrivacySettingRuleAllowChatMembers',
    /** The chat identifiers, total number of chats in all rules must not exceed 20 */
    readonly chat_ids?: ReadonlyArray<number>,
  }

  export type userPrivacySettingRuleRestrictAll = {
    /** A rule to restrict all users from doing something */
    _: 'userPrivacySettingRuleRestrictAll',
  }

  export type userPrivacySettingRuleRestrictAll$Input = {
    /** A rule to restrict all users from doing something */
    readonly _: 'userPrivacySettingRuleRestrictAll',
  }

  export type userPrivacySettingRuleRestrictContacts = {
    /** A rule to restrict all contacts of the user from doing something */
    _: 'userPrivacySettingRuleRestrictContacts',
  }

  export type userPrivacySettingRuleRestrictContacts$Input = {
    /** A rule to restrict all contacts of the user from doing something */
    readonly _: 'userPrivacySettingRuleRestrictContacts',
  }

  export type userPrivacySettingRuleRestrictUsers = {
    /** A rule to restrict all specified users from doing something */
    _: 'userPrivacySettingRuleRestrictUsers',
    /** The user identifiers, total number of users in all rules must not exceed 1000 */
    user_ids: Array<number>,
  }

  export type userPrivacySettingRuleRestrictUsers$Input = {
    /** A rule to restrict all specified users from doing something */
    readonly _: 'userPrivacySettingRuleRestrictUsers',
    /** The user identifiers, total number of users in all rules must not exceed 1000 */
    readonly user_ids?: ReadonlyArray<number>,
  }

  export type userPrivacySettingRuleRestrictChatMembers = {
    /**
     * A rule to restrict all members of specified basic groups and supergroups from
     * doing something
     */
    _: 'userPrivacySettingRuleRestrictChatMembers',
    /** The chat identifiers, total number of chats in all rules must not exceed 20 */
    chat_ids: Array<number>,
  }

  export type userPrivacySettingRuleRestrictChatMembers$Input = {
    /**
     * A rule to restrict all members of specified basic groups and supergroups from
     * doing something
     */
    readonly _: 'userPrivacySettingRuleRestrictChatMembers',
    /** The chat identifiers, total number of chats in all rules must not exceed 20 */
    readonly chat_ids?: ReadonlyArray<number>,
  }

  export type userPrivacySettingRules = {
    /**
     * A list of privacy rules. Rules are matched in the specified order. The first
     * matched rule defines the privacy setting for a given user. If no rule matches,
     * the action is not allowed
     */
    _: 'userPrivacySettingRules',
    /** A list of rules */
    rules: Array<UserPrivacySettingRule>,
  }

  export type userPrivacySettingRules$Input = {
    /**
     * A list of privacy rules. Rules are matched in the specified order. The first
     * matched rule defines the privacy setting for a given user. If no rule matches,
     * the action is not allowed
     */
    readonly _: 'userPrivacySettingRules',
    /** A list of rules */
    readonly rules?: ReadonlyArray<UserPrivacySettingRule$Input>,
  }

  export type userPrivacySettingShowStatus = {
    /** A privacy setting for managing whether the user's online status is visible */
    _: 'userPrivacySettingShowStatus',
  }

  export type userPrivacySettingShowStatus$Input = {
    /** A privacy setting for managing whether the user's online status is visible */
    readonly _: 'userPrivacySettingShowStatus',
  }

  export type userPrivacySettingShowProfilePhoto = {
    /** A privacy setting for managing whether the user's profile photo is visible */
    _: 'userPrivacySettingShowProfilePhoto',
  }

  export type userPrivacySettingShowProfilePhoto$Input = {
    /** A privacy setting for managing whether the user's profile photo is visible */
    readonly _: 'userPrivacySettingShowProfilePhoto',
  }

  export type userPrivacySettingShowLinkInForwardedMessages = {
    /**
     * A privacy setting for managing whether a link to the user's account is included
     * in forwarded messages
     */
    _: 'userPrivacySettingShowLinkInForwardedMessages',
  }

  export type userPrivacySettingShowLinkInForwardedMessages$Input = {
    /**
     * A privacy setting for managing whether a link to the user's account is included
     * in forwarded messages
     */
    readonly _: 'userPrivacySettingShowLinkInForwardedMessages',
  }

  export type userPrivacySettingShowPhoneNumber = {
    /** A privacy setting for managing whether the user's phone number is visible */
    _: 'userPrivacySettingShowPhoneNumber',
  }

  export type userPrivacySettingShowPhoneNumber$Input = {
    /** A privacy setting for managing whether the user's phone number is visible */
    readonly _: 'userPrivacySettingShowPhoneNumber',
  }

  export type userPrivacySettingShowBio = {
    /** A privacy setting for managing whether the user's bio is visible */
    _: 'userPrivacySettingShowBio',
  }

  export type userPrivacySettingShowBio$Input = {
    /** A privacy setting for managing whether the user's bio is visible */
    readonly _: 'userPrivacySettingShowBio',
  }

  export type userPrivacySettingAllowChatInvites = {
    /** A privacy setting for managing whether the user can be invited to chats */
    _: 'userPrivacySettingAllowChatInvites',
  }

  export type userPrivacySettingAllowChatInvites$Input = {
    /** A privacy setting for managing whether the user can be invited to chats */
    readonly _: 'userPrivacySettingAllowChatInvites',
  }

  export type userPrivacySettingAllowCalls = {
    /** A privacy setting for managing whether the user can be called */
    _: 'userPrivacySettingAllowCalls',
  }

  export type userPrivacySettingAllowCalls$Input = {
    /** A privacy setting for managing whether the user can be called */
    readonly _: 'userPrivacySettingAllowCalls',
  }

  export type userPrivacySettingAllowPeerToPeerCalls = {
    /**
     * A privacy setting for managing whether peer-to-peer connections can be used
     * for calls
     */
    _: 'userPrivacySettingAllowPeerToPeerCalls',
  }

  export type userPrivacySettingAllowPeerToPeerCalls$Input = {
    /**
     * A privacy setting for managing whether peer-to-peer connections can be used
     * for calls
     */
    readonly _: 'userPrivacySettingAllowPeerToPeerCalls',
  }

  export type userPrivacySettingAllowFindingByPhoneNumber = {
    /**
     * A privacy setting for managing whether the user can be found by their phone
     * number. Checked only if the phone number is not known to the other user. Can
     * be set only to "Allow contacts" or "Allow all"
     */
    _: 'userPrivacySettingAllowFindingByPhoneNumber',
  }

  export type userPrivacySettingAllowFindingByPhoneNumber$Input = {
    /**
     * A privacy setting for managing whether the user can be found by their phone
     * number. Checked only if the phone number is not known to the other user. Can
     * be set only to "Allow contacts" or "Allow all"
     */
    readonly _: 'userPrivacySettingAllowFindingByPhoneNumber',
  }

  export type userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages = {
    /**
     * A privacy setting for managing whether the user can receive voice and video
     * messages in private chats
     */
    _: 'userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages',
  }

  export type userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages$Input = {
    /**
     * A privacy setting for managing whether the user can receive voice and video
     * messages in private chats
     */
    readonly _: 'userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages',
  }

  export type accountTtl = {
    /**
     * Contains information about the period of inactivity after which the current
     * user's account will automatically be deleted
     */
    _: 'accountTtl',
    /**
     * Number of days of inactivity before the account will be flagged for deletion;
     * 30-366 days
     */
    days: number,
  }

  export type accountTtl$Input = {
    /**
     * Contains information about the period of inactivity after which the current
     * user's account will automatically be deleted
     */
    readonly _: 'accountTtl',
    /**
     * Number of days of inactivity before the account will be flagged for deletion;
     * 30-366 days
     */
    readonly days?: number,
  }

  export type messageAutoDeleteTime = {
    /** Contains default auto-delete timer setting for new chats */
    _: 'messageAutoDeleteTime',
    /** Message auto-delete time, in seconds. If 0, then messages aren't deleted automatically */
    time: number,
  }

  export type messageAutoDeleteTime$Input = {
    /** Contains default auto-delete timer setting for new chats */
    readonly _: 'messageAutoDeleteTime',
    /** Message auto-delete time, in seconds. If 0, then messages aren't deleted automatically */
    readonly time?: number,
  }

  export type sessionTypeAndroid = {
    /** The session is running on an Android device */
    _: 'sessionTypeAndroid',
  }

  export type sessionTypeApple = {
    /** The session is running on a generic Apple device */
    _: 'sessionTypeApple',
  }

  export type sessionTypeBrave = {
    /** The session is running on the Brave browser */
    _: 'sessionTypeBrave',
  }

  export type sessionTypeChrome = {
    /** The session is running on the Chrome browser */
    _: 'sessionTypeChrome',
  }

  export type sessionTypeEdge = {
    /** The session is running on the Edge browser */
    _: 'sessionTypeEdge',
  }

  export type sessionTypeFirefox = {
    /** The session is running on the Firefox browser */
    _: 'sessionTypeFirefox',
  }

  export type sessionTypeIpad = {
    /** The session is running on an iPad device */
    _: 'sessionTypeIpad',
  }

  export type sessionTypeIphone = {
    /** The session is running on an iPhone device */
    _: 'sessionTypeIphone',
  }

  export type sessionTypeLinux = {
    /** The session is running on a Linux device */
    _: 'sessionTypeLinux',
  }

  export type sessionTypeMac = {
    /** The session is running on a Mac device */
    _: 'sessionTypeMac',
  }

  export type sessionTypeOpera = {
    /** The session is running on the Opera browser */
    _: 'sessionTypeOpera',
  }

  export type sessionTypeSafari = {
    /** The session is running on the Safari browser */
    _: 'sessionTypeSafari',
  }

  export type sessionTypeUbuntu = {
    /** The session is running on an Ubuntu device */
    _: 'sessionTypeUbuntu',
  }

  export type sessionTypeUnknown = {
    /** The session is running on an unknown type of device */
    _: 'sessionTypeUnknown',
  }

  export type sessionTypeVivaldi = {
    /** The session is running on the Vivaldi browser */
    _: 'sessionTypeVivaldi',
  }

  export type sessionTypeWindows = {
    /** The session is running on a Windows device */
    _: 'sessionTypeWindows',
  }

  export type sessionTypeXbox = {
    /** The session is running on an Xbox console */
    _: 'sessionTypeXbox',
  }

  export type session = {
    /**
     * Contains information about one session in a Telegram application used by the
     * current user. Sessions must be shown to the user in the returned order
     */
    _: 'session',
    /** Session identifier */
    id: number | string,
    /** True, if this session is the current session */
    is_current: boolean,
    /**
     * True, if a 2-step verification password is needed to complete authorization
     * of the session
     */
    is_password_pending: boolean,
    /** True, if the session wasn't confirmed from another session */
    is_unconfirmed: boolean,
    /** True, if incoming secret chats can be accepted by the session */
    can_accept_secret_chats: boolean,
    /** True, if incoming calls can be accepted by the session */
    can_accept_calls: boolean,
    /**
     * Session type based on the system and application version, which can be used
     * to display a corresponding icon
     */
    type: SessionType,
    /** Telegram API identifier, as provided by the application */
    api_id: number,
    /** Name of the application, as provided by the application */
    application_name: string,
    /** The version of the application, as provided by the application */
    application_version: string,
    /**
     * True, if the application is an official application or uses the api_id of an
     * official application
     */
    is_official_application: boolean,
    /**
     * Model of the device the application has been run or is running on, as provided
     * by the application
     */
    device_model: string,
    /**
     * Operating system the application has been run or is running on, as provided
     * by the application
     */
    platform: string,
    /**
     * Version of the operating system the application has been run or is running on,
     * as provided by the application
     */
    system_version: string,
    /** Point in time (Unix timestamp) when the user has logged in */
    log_in_date: number,
    /** Point in time (Unix timestamp) when the session was last used */
    last_active_date: number,
    /** IP address from which the session was created, in human-readable format */
    ip_address: string,
    /**
     * A human-readable description of the location from which the session was created,
     * based on the IP address
     */
    location: string,
  }

  export type sessions = {
    /** Contains a list of sessions */
    _: 'sessions',
    /** List of sessions */
    sessions: Array<session>,
    /**
     * Number of days of inactivity before sessions will automatically be terminated;
     * 1-366 days
     */
    inactive_session_ttl_days: number,
  }

  export type unconfirmedSession = {
    /** Contains information about an unconfirmed session */
    _: 'unconfirmedSession',
    /** Session identifier */
    id: number | string,
    /** Point in time (Unix timestamp) when the user has logged in */
    log_in_date: number,
    /**
     * Model of the device that was used for the session creation, as provided by the
     * application
     */
    device_model: string,
    /**
     * A human-readable description of the location from which the session was created,
     * based on the IP address
     */
    location: string,
  }

  export type connectedWebsite = {
    /** Contains information about one website the current user is logged in with Telegram */
    _: 'connectedWebsite',
    /** Website identifier */
    id: number | string,
    /** The domain name of the website */
    domain_name: string,
    /** User identifier of a bot linked with the website */
    bot_user_id: number,
    /** The version of a browser used to log in */
    browser: string,
    /** Operating system the browser is running on */
    platform: string,
    /** Point in time (Unix timestamp) when the user was logged in */
    log_in_date: number,
    /** Point in time (Unix timestamp) when obtained authorization was last used */
    last_active_date: number,
    /** IP address from which the user was logged in, in human-readable format */
    ip_address: string,
    /**
     * Human-readable description of a country and a region from which the user was
     * logged in, based on the IP address
     */
    location: string,
  }

  export type connectedWebsites = {
    /** Contains a list of websites the current user is logged in with Telegram */
    _: 'connectedWebsites',
    /** List of connected websites */
    websites: Array<connectedWebsite>,
  }

  export type reportReasonSpam$Input = {
    /** The chat contains spam messages */
    readonly _: 'reportReasonSpam',
  }

  export type reportReasonViolence$Input = {
    /** The chat promotes violence */
    readonly _: 'reportReasonViolence',
  }

  export type reportReasonPornography$Input = {
    /** The chat contains pornographic messages */
    readonly _: 'reportReasonPornography',
  }

  export type reportReasonChildAbuse$Input = {
    /** The chat has child abuse related content */
    readonly _: 'reportReasonChildAbuse',
  }

  export type reportReasonCopyright$Input = {
    /** The chat contains copyrighted content */
    readonly _: 'reportReasonCopyright',
  }

  export type reportReasonUnrelatedLocation$Input = {
    /** The location-based chat is unrelated to its stated location */
    readonly _: 'reportReasonUnrelatedLocation',
  }

  export type reportReasonFake$Input = {
    /** The chat represents a fake account */
    readonly _: 'reportReasonFake',
  }

  export type reportReasonIllegalDrugs$Input = {
    /** The chat has illegal drugs related content */
    readonly _: 'reportReasonIllegalDrugs',
  }

  export type reportReasonPersonalDetails$Input = {
    /** The chat contains messages with personal details */
    readonly _: 'reportReasonPersonalDetails',
  }

  export type reportReasonCustom$Input = {
    /** A custom reason provided by the user */
    readonly _: 'reportReasonCustom',
  }

  export type targetChatCurrent = {
    /** The currently opened chat needs to be kept */
    _: 'targetChatCurrent',
  }

  export type targetChatCurrent$Input = {
    /** The currently opened chat needs to be kept */
    readonly _: 'targetChatCurrent',
  }

  export type targetChatChosen = {
    /** The chat needs to be chosen by the user among chats of the specified types */
    _: 'targetChatChosen',
    /** True, if private chats with ordinary users are allowed */
    allow_user_chats: boolean,
    /** True, if private chats with other bots are allowed */
    allow_bot_chats: boolean,
    /** True, if basic group and supergroup chats are allowed */
    allow_group_chats: boolean,
    /** True, if channel chats are allowed */
    allow_channel_chats: boolean,
  }

  export type targetChatChosen$Input = {
    /** The chat needs to be chosen by the user among chats of the specified types */
    readonly _: 'targetChatChosen',
    /** True, if private chats with ordinary users are allowed */
    readonly allow_user_chats?: boolean,
    /** True, if private chats with other bots are allowed */
    readonly allow_bot_chats?: boolean,
    /** True, if basic group and supergroup chats are allowed */
    readonly allow_group_chats?: boolean,
    /** True, if channel chats are allowed */
    readonly allow_channel_chats?: boolean,
  }

  export type targetChatInternalLink = {
    /** The chat needs to be open with the provided internal link */
    _: 'targetChatInternalLink',
    /** An internal link pointing to the chat */
    link: InternalLinkType,
  }

  export type targetChatInternalLink$Input = {
    /** The chat needs to be open with the provided internal link */
    readonly _: 'targetChatInternalLink',
    /** An internal link pointing to the chat */
    readonly link?: InternalLinkType$Input,
  }

  export type internalLinkTypeActiveSessions = {
    /**
     * The link is a link to the active sessions section of the application. Use getActiveSessions
     * to handle the link
     */
    _: 'internalLinkTypeActiveSessions',
  }

  export type internalLinkTypeActiveSessions$Input = {
    /**
     * The link is a link to the active sessions section of the application. Use getActiveSessions
     * to handle the link
     */
    readonly _: 'internalLinkTypeActiveSessions',
  }

  export type internalLinkTypeAttachmentMenuBot = {
    /**
     * The link is a link to an attachment menu bot to be opened in the specified or
     * a chosen chat. Process given target_chat to open the chat. Then, call searchPublicChat
     * with the given bot username, check that the user is a bot and can be added to
     * attachment menu. Then, use getAttachmentMenuBot to receive information about
     * the bot. If the bot isn't added to attachment menu, then show a disclaimer about
     * Mini Apps being a third-party apps, ask the user to accept their Terms of service
     * and confirm adding the bot to side and attachment menu. If the user accept the
     * terms and confirms adding, then use toggleBotIsAddedToAttachmentMenu to add
     * the bot. If the attachment menu bot can't be used in the opened chat, show an
     * error to the user. If the bot is added to attachment menu and can be used in
     * the chat, then use openWebApp with the given URL
     */
    _: 'internalLinkTypeAttachmentMenuBot',
    /** Target chat to be opened */
    target_chat: TargetChat,
    /** Username of the bot */
    bot_username: string,
    /** URL to be passed to openWebApp */
    url: string,
  }

  export type internalLinkTypeAttachmentMenuBot$Input = {
    /**
     * The link is a link to an attachment menu bot to be opened in the specified or
     * a chosen chat. Process given target_chat to open the chat. Then, call searchPublicChat
     * with the given bot username, check that the user is a bot and can be added to
     * attachment menu. Then, use getAttachmentMenuBot to receive information about
     * the bot. If the bot isn't added to attachment menu, then show a disclaimer about
     * Mini Apps being a third-party apps, ask the user to accept their Terms of service
     * and confirm adding the bot to side and attachment menu. If the user accept the
     * terms and confirms adding, then use toggleBotIsAddedToAttachmentMenu to add
     * the bot. If the attachment menu bot can't be used in the opened chat, show an
     * error to the user. If the bot is added to attachment menu and can be used in
     * the chat, then use openWebApp with the given URL
     */
    readonly _: 'internalLinkTypeAttachmentMenuBot',
    /** Target chat to be opened */
    readonly target_chat?: TargetChat$Input,
    /** Username of the bot */
    readonly bot_username?: string,
    /** URL to be passed to openWebApp */
    readonly url?: string,
  }

  export type internalLinkTypeAuthenticationCode = {
    /**
     * The link contains an authentication code. Call checkAuthenticationCode with
     * the code if the current authorization state is authorizationStateWaitCode
     */
    _: 'internalLinkTypeAuthenticationCode',
    /** The authentication code */
    code: string,
  }

  export type internalLinkTypeAuthenticationCode$Input = {
    /**
     * The link contains an authentication code. Call checkAuthenticationCode with
     * the code if the current authorization state is authorizationStateWaitCode
     */
    readonly _: 'internalLinkTypeAuthenticationCode',
    /** The authentication code */
    readonly code?: string,
  }

  export type internalLinkTypeBackground = {
    /**
     * The link is a link to a background. Call searchBackground with the given background
     * name to process the link
     */
    _: 'internalLinkTypeBackground',
    /** Name of the background */
    background_name: string,
  }

  export type internalLinkTypeBackground$Input = {
    /**
     * The link is a link to a background. Call searchBackground with the given background
     * name to process the link
     */
    readonly _: 'internalLinkTypeBackground',
    /** Name of the background */
    readonly background_name?: string,
  }

  export type internalLinkTypeBotAddToChannel = {
    /**
     * The link is a link to a Telegram bot, which is supposed to be added to a channel
     * chat as an administrator. Call searchPublicChat with the given bot username
     * and check that the user is a bot, ask the current user to select a channel chat
     * to add the bot to as an administrator. Then, call getChatMember to receive the
     * current bot rights in the chat and if the bot already is an administrator, check
     * that the current user can edit its administrator rights and combine received
     * rights with the requested administrator rights. Then, show confirmation box
     * to the user, and call setChatMemberStatus with the chosen chat and confirmed
     * rights
     */
    _: 'internalLinkTypeBotAddToChannel',
    /** Username of the bot */
    bot_username: string,
    /** Expected administrator rights for the bot */
    administrator_rights: chatAdministratorRights,
  }

  export type internalLinkTypeBotAddToChannel$Input = {
    /**
     * The link is a link to a Telegram bot, which is supposed to be added to a channel
     * chat as an administrator. Call searchPublicChat with the given bot username
     * and check that the user is a bot, ask the current user to select a channel chat
     * to add the bot to as an administrator. Then, call getChatMember to receive the
     * current bot rights in the chat and if the bot already is an administrator, check
     * that the current user can edit its administrator rights and combine received
     * rights with the requested administrator rights. Then, show confirmation box
     * to the user, and call setChatMemberStatus with the chosen chat and confirmed
     * rights
     */
    readonly _: 'internalLinkTypeBotAddToChannel',
    /** Username of the bot */
    readonly bot_username?: string,
    /** Expected administrator rights for the bot */
    readonly administrator_rights?: chatAdministratorRights$Input,
  }

  export type internalLinkTypeBotStart = {
    /**
     * The link is a link to a chat with a Telegram bot. Call searchPublicChat with
     * the given bot username, check that the user is a bot, show START button in the
     * chat with the bot, and then call sendBotStartMessage with the given start parameter
     * after the button is pressed
     */
    _: 'internalLinkTypeBotStart',
    /** Username of the bot */
    bot_username: string,
    /** The parameter to be passed to sendBotStartMessage */
    start_parameter: string,
    /**
     * True, if sendBotStartMessage must be called automatically without showing the
     * START button
     */
    autostart: boolean,
  }

  export type internalLinkTypeBotStart$Input = {
    /**
     * The link is a link to a chat with a Telegram bot. Call searchPublicChat with
     * the given bot username, check that the user is a bot, show START button in the
     * chat with the bot, and then call sendBotStartMessage with the given start parameter
     * after the button is pressed
     */
    readonly _: 'internalLinkTypeBotStart',
    /** Username of the bot */
    readonly bot_username?: string,
    /** The parameter to be passed to sendBotStartMessage */
    readonly start_parameter?: string,
    /**
     * True, if sendBotStartMessage must be called automatically without showing the
     * START button
     */
    readonly autostart?: boolean,
  }

  export type internalLinkTypeBotStartInGroup = {
    /**
     * The link is a link to a Telegram bot, which is supposed to be added to a group
     * chat. Call searchPublicChat with the given bot username, check that the user
     * is a bot and can be added to groups, ask the current user to select a basic
     * group or a supergroup chat to add the bot to, taking into account that bots
     * can be added to a public supergroup only by administrators of the supergroup.
     * If administrator rights are provided by the link, call getChatMember to receive
     * the current bot rights in the chat and if the bot already is an administrator,
     * check that the current user can edit its administrator rights, combine received
     * rights with the requested administrator rights, show confirmation box to the
     * user, and call setChatMemberStatus with the chosen chat and confirmed administrator
     * rights. Before call to setChatMemberStatus it may be required to upgrade the
     * chosen basic group chat to a supergroup chat. Then, if start_parameter isn't
     * empty, call sendBotStartMessage with the given start parameter and the chosen
     * chat; otherwise, just send /start message with bot's username added to the chat.
     */
    _: 'internalLinkTypeBotStartInGroup',
    /** Username of the bot */
    bot_username: string,
    /** The parameter to be passed to sendBotStartMessage */
    start_parameter: string,
    /** Expected administrator rights for the bot; may be null */
    administrator_rights?: chatAdministratorRights,
  }

  export type internalLinkTypeBotStartInGroup$Input = {
    /**
     * The link is a link to a Telegram bot, which is supposed to be added to a group
     * chat. Call searchPublicChat with the given bot username, check that the user
     * is a bot and can be added to groups, ask the current user to select a basic
     * group or a supergroup chat to add the bot to, taking into account that bots
     * can be added to a public supergroup only by administrators of the supergroup.
     * If administrator rights are provided by the link, call getChatMember to receive
     * the current bot rights in the chat and if the bot already is an administrator,
     * check that the current user can edit its administrator rights, combine received
     * rights with the requested administrator rights, show confirmation box to the
     * user, and call setChatMemberStatus with the chosen chat and confirmed administrator
     * rights. Before call to setChatMemberStatus it may be required to upgrade the
     * chosen basic group chat to a supergroup chat. Then, if start_parameter isn't
     * empty, call sendBotStartMessage with the given start parameter and the chosen
     * chat; otherwise, just send /start message with bot's username added to the chat.
     */
    readonly _: 'internalLinkTypeBotStartInGroup',
    /** Username of the bot */
    readonly bot_username?: string,
    /** The parameter to be passed to sendBotStartMessage */
    readonly start_parameter?: string,
    /** Expected administrator rights for the bot; may be null */
    readonly administrator_rights?: chatAdministratorRights$Input,
  }

  export type internalLinkTypeChangePhoneNumber = {
    /** The link is a link to the change phone number section of the app */
    _: 'internalLinkTypeChangePhoneNumber',
  }

  export type internalLinkTypeChangePhoneNumber$Input = {
    /** The link is a link to the change phone number section of the app */
    readonly _: 'internalLinkTypeChangePhoneNumber',
  }

  export type internalLinkTypeChatBoost = {
    /**
     * The link is a link to boost a Telegram chat. Call getChatBoostLinkInfo with
     * the given URL to process the link. If the chat is found, then call getChatBoostStatus
     * and canBoostChat to get the current boost status and check whether the chat
     * can be boosted. If the user wants to boost the chat and the chat can be boosted,
     * then call boostChat
     */
    _: 'internalLinkTypeChatBoost',
    /** URL to be passed to getChatBoostLinkInfo */
    url: string,
  }

  export type internalLinkTypeChatBoost$Input = {
    /**
     * The link is a link to boost a Telegram chat. Call getChatBoostLinkInfo with
     * the given URL to process the link. If the chat is found, then call getChatBoostStatus
     * and canBoostChat to get the current boost status and check whether the chat
     * can be boosted. If the user wants to boost the chat and the chat can be boosted,
     * then call boostChat
     */
    readonly _: 'internalLinkTypeChatBoost',
    /** URL to be passed to getChatBoostLinkInfo */
    readonly url?: string,
  }

  export type internalLinkTypeChatFolderInvite = {
    /**
     * The link is an invite link to a chat folder. Call checkChatFolderInviteLink
     * with the given invite link to process the link
     */
    _: 'internalLinkTypeChatFolderInvite',
    /** Internal representation of the invite link */
    invite_link: string,
  }

  export type internalLinkTypeChatFolderInvite$Input = {
    /**
     * The link is an invite link to a chat folder. Call checkChatFolderInviteLink
     * with the given invite link to process the link
     */
    readonly _: 'internalLinkTypeChatFolderInvite',
    /** Internal representation of the invite link */
    readonly invite_link?: string,
  }

  export type internalLinkTypeChatFolderSettings = {
    /** The link is a link to the folder section of the app settings */
    _: 'internalLinkTypeChatFolderSettings',
  }

  export type internalLinkTypeChatFolderSettings$Input = {
    /** The link is a link to the folder section of the app settings */
    readonly _: 'internalLinkTypeChatFolderSettings',
  }

  export type internalLinkTypeChatInvite = {
    /**
     * The link is a chat invite link. Call checkChatInviteLink with the given invite
     * link to process the link
     */
    _: 'internalLinkTypeChatInvite',
    /** Internal representation of the invite link */
    invite_link: string,
  }

  export type internalLinkTypeChatInvite$Input = {
    /**
     * The link is a chat invite link. Call checkChatInviteLink with the given invite
     * link to process the link
     */
    readonly _: 'internalLinkTypeChatInvite',
    /** Internal representation of the invite link */
    readonly invite_link?: string,
  }

  export type internalLinkTypeDefaultMessageAutoDeleteTimerSettings = {
    /**
     * The link is a link to the default message auto-delete timer settings section
     * of the app settings
     */
    _: 'internalLinkTypeDefaultMessageAutoDeleteTimerSettings',
  }

  export type internalLinkTypeDefaultMessageAutoDeleteTimerSettings$Input = {
    /**
     * The link is a link to the default message auto-delete timer settings section
     * of the app settings
     */
    readonly _: 'internalLinkTypeDefaultMessageAutoDeleteTimerSettings',
  }

  export type internalLinkTypeEditProfileSettings = {
    /** The link is a link to the edit profile section of the app settings */
    _: 'internalLinkTypeEditProfileSettings',
  }

  export type internalLinkTypeEditProfileSettings$Input = {
    /** The link is a link to the edit profile section of the app settings */
    readonly _: 'internalLinkTypeEditProfileSettings',
  }

  export type internalLinkTypeGame = {
    /**
     * The link is a link to a game. Call searchPublicChat with the given bot username,
     * check that the user is a bot, ask the current user to select a chat to send
     * the game, and then call sendMessage with inputMessageGame
     */
    _: 'internalLinkTypeGame',
    /** Username of the bot that owns the game */
    bot_username: string,
    /** Short name of the game */
    game_short_name: string,
  }

  export type internalLinkTypeGame$Input = {
    /**
     * The link is a link to a game. Call searchPublicChat with the given bot username,
     * check that the user is a bot, ask the current user to select a chat to send
     * the game, and then call sendMessage with inputMessageGame
     */
    readonly _: 'internalLinkTypeGame',
    /** Username of the bot that owns the game */
    readonly bot_username?: string,
    /** Short name of the game */
    readonly game_short_name?: string,
  }

  export type internalLinkTypeInstantView = {
    /**
     * The link must be opened in an Instant View. Call getWebPageInstantView with
     * the given URL to process the link
     */
    _: 'internalLinkTypeInstantView',
    /** URL to be passed to getWebPageInstantView */
    url: string,
    /** An URL to open if getWebPageInstantView fails */
    fallback_url: string,
  }

  export type internalLinkTypeInstantView$Input = {
    /**
     * The link must be opened in an Instant View. Call getWebPageInstantView with
     * the given URL to process the link
     */
    readonly _: 'internalLinkTypeInstantView',
    /** URL to be passed to getWebPageInstantView */
    readonly url?: string,
    /** An URL to open if getWebPageInstantView fails */
    readonly fallback_url?: string,
  }

  export type internalLinkTypeInvoice = {
    /**
     * The link is a link to an invoice. Call getPaymentForm with the given invoice
     * name to process the link
     */
    _: 'internalLinkTypeInvoice',
    /** Name of the invoice */
    invoice_name: string,
  }

  export type internalLinkTypeInvoice$Input = {
    /**
     * The link is a link to an invoice. Call getPaymentForm with the given invoice
     * name to process the link
     */
    readonly _: 'internalLinkTypeInvoice',
    /** Name of the invoice */
    readonly invoice_name?: string,
  }

  export type internalLinkTypeLanguagePack = {
    /**
     * The link is a link to a language pack. Call getLanguagePackInfo with the given
     * language pack identifier to process the link
     */
    _: 'internalLinkTypeLanguagePack',
    /** Language pack identifier */
    language_pack_id: string,
  }

  export type internalLinkTypeLanguagePack$Input = {
    /**
     * The link is a link to a language pack. Call getLanguagePackInfo with the given
     * language pack identifier to process the link
     */
    readonly _: 'internalLinkTypeLanguagePack',
    /** Language pack identifier */
    readonly language_pack_id?: string,
  }

  export type internalLinkTypeLanguageSettings = {
    /** The link is a link to the language section of the app settings */
    _: 'internalLinkTypeLanguageSettings',
  }

  export type internalLinkTypeLanguageSettings$Input = {
    /** The link is a link to the language section of the app settings */
    readonly _: 'internalLinkTypeLanguageSettings',
  }

  export type internalLinkTypeMessage = {
    /**
     * The link is a link to a Telegram message or a forum topic. Call getMessageLinkInfo
     * with the given URL to process the link
     */
    _: 'internalLinkTypeMessage',
    /** URL to be passed to getMessageLinkInfo */
    url: string,
  }

  export type internalLinkTypeMessage$Input = {
    /**
     * The link is a link to a Telegram message or a forum topic. Call getMessageLinkInfo
     * with the given URL to process the link
     */
    readonly _: 'internalLinkTypeMessage',
    /** URL to be passed to getMessageLinkInfo */
    readonly url?: string,
  }

  export type internalLinkTypeMessageDraft = {
    /**
     * The link contains a message draft text. A share screen needs to be shown to
     * the user, then the chosen chat must be opened and the text is added to the input
     * field
     */
    _: 'internalLinkTypeMessageDraft',
    /** Message draft text */
    text: formattedText,
    /**
     * True, if the first line of the text contains a link. If true, the input field
     * needs to be focused and the text after the link must be selected
     */
    contains_link: boolean,
  }

  export type internalLinkTypeMessageDraft$Input = {
    /**
     * The link contains a message draft text. A share screen needs to be shown to
     * the user, then the chosen chat must be opened and the text is added to the input
     * field
     */
    readonly _: 'internalLinkTypeMessageDraft',
    /** Message draft text */
    readonly text?: formattedText$Input,
    /**
     * True, if the first line of the text contains a link. If true, the input field
     * needs to be focused and the text after the link must be selected
     */
    readonly contains_link?: boolean,
  }

  export type internalLinkTypePassportDataRequest = {
    /**
     * The link contains a request of Telegram passport data. Call getPassportAuthorizationForm
     * with the given parameters to process the link if the link was received from
     * outside of the application; otherwise, ignore it
     */
    _: 'internalLinkTypePassportDataRequest',
    /** User identifier of the service's bot */
    bot_user_id: number,
    /** Telegram Passport element types requested by the service */
    scope: string,
    /** Service's public key */
    public_key: string,
    /** Unique request identifier provided by the service */
    nonce: string,
    /**
     * An HTTP URL to open once the request is finished, canceled, or failed with the
     * parameters tg_passport=success, tg_passport=cancel, or tg_passport=error&error=...
     * respectively. If empty, then onActivityResult method must be used to return
     * response on Android, or the link tgbot{bot_user_id}://passport/success or tgbot{bot_user_id}://passport/cancel
     * must be opened otherwise
     */
    callback_url: string,
  }

  export type internalLinkTypePassportDataRequest$Input = {
    /**
     * The link contains a request of Telegram passport data. Call getPassportAuthorizationForm
     * with the given parameters to process the link if the link was received from
     * outside of the application; otherwise, ignore it
     */
    readonly _: 'internalLinkTypePassportDataRequest',
    /** User identifier of the service's bot */
    readonly bot_user_id?: number,
    /** Telegram Passport element types requested by the service */
    readonly scope?: string,
    /** Service's public key */
    readonly public_key?: string,
    /** Unique request identifier provided by the service */
    readonly nonce?: string,
    /**
     * An HTTP URL to open once the request is finished, canceled, or failed with the
     * parameters tg_passport=success, tg_passport=cancel, or tg_passport=error&error=...
     * respectively. If empty, then onActivityResult method must be used to return
     * response on Android, or the link tgbot{bot_user_id}://passport/success or tgbot{bot_user_id}://passport/cancel
     * must be opened otherwise
     */
    readonly callback_url?: string,
  }

  export type internalLinkTypePhoneNumberConfirmation = {
    /**
     * The link can be used to confirm ownership of a phone number to prevent account
     * deletion. Call sendPhoneNumberConfirmationCode with the given hash and phone
     * number to process the link
     */
    _: 'internalLinkTypePhoneNumberConfirmation',
    /** Hash value from the link */
    hash: string,
    /** Phone number value from the link */
    phone_number: string,
  }

  export type internalLinkTypePhoneNumberConfirmation$Input = {
    /**
     * The link can be used to confirm ownership of a phone number to prevent account
     * deletion. Call sendPhoneNumberConfirmationCode with the given hash and phone
     * number to process the link
     */
    readonly _: 'internalLinkTypePhoneNumberConfirmation',
    /** Hash value from the link */
    readonly hash?: string,
    /** Phone number value from the link */
    readonly phone_number?: string,
  }

  export type internalLinkTypePremiumFeatures = {
    /**
     * The link is a link to the Premium features screen of the application from which
     * the user can subscribe to Telegram Premium. Call getPremiumFeatures with the
     * given referrer to process the link
     */
    _: 'internalLinkTypePremiumFeatures',
    /** Referrer specified in the link */
    referrer: string,
  }

  export type internalLinkTypePremiumFeatures$Input = {
    /**
     * The link is a link to the Premium features screen of the application from which
     * the user can subscribe to Telegram Premium. Call getPremiumFeatures with the
     * given referrer to process the link
     */
    readonly _: 'internalLinkTypePremiumFeatures',
    /** Referrer specified in the link */
    readonly referrer?: string,
  }

  export type internalLinkTypePrivacyAndSecuritySettings = {
    /** The link is a link to the privacy and security section of the app settings */
    _: 'internalLinkTypePrivacyAndSecuritySettings',
  }

  export type internalLinkTypePrivacyAndSecuritySettings$Input = {
    /** The link is a link to the privacy and security section of the app settings */
    readonly _: 'internalLinkTypePrivacyAndSecuritySettings',
  }

  export type internalLinkTypeProxy = {
    /**
     * The link is a link to a proxy. Call addProxy with the given parameters to process
     * the link and add the proxy
     */
    _: 'internalLinkTypeProxy',
    /** Proxy server domain or IP address */
    server: string,
    /** Proxy server port */
    port: number,
    /** Type of the proxy */
    type: ProxyType,
  }

  export type internalLinkTypeProxy$Input = {
    /**
     * The link is a link to a proxy. Call addProxy with the given parameters to process
     * the link and add the proxy
     */
    readonly _: 'internalLinkTypeProxy',
    /** Proxy server domain or IP address */
    readonly server?: string,
    /** Proxy server port */
    readonly port?: number,
    /** Type of the proxy */
    readonly type?: ProxyType$Input,
  }

  export type internalLinkTypePublicChat = {
    /**
     * The link is a link to a chat by its username. Call searchPublicChat with the
     * given chat username to process the link
     */
    _: 'internalLinkTypePublicChat',
    /** Username of the chat */
    chat_username: string,
  }

  export type internalLinkTypePublicChat$Input = {
    /**
     * The link is a link to a chat by its username. Call searchPublicChat with the
     * given chat username to process the link
     */
    readonly _: 'internalLinkTypePublicChat',
    /** Username of the chat */
    readonly chat_username?: string,
  }

  export type internalLinkTypeQrCodeAuthentication = {
    /**
     * The link can be used to login the current user on another device, but it must
     * be scanned from QR-code using in-app camera. An alert similar to "This code
     * can be used to allow someone to log in to your Telegram account. To confirm
     * Telegram login, please go to Settings > Devices > Scan QR and scan the code"
     * needs to be shown
     */
    _: 'internalLinkTypeQrCodeAuthentication',
  }

  export type internalLinkTypeQrCodeAuthentication$Input = {
    /**
     * The link can be used to login the current user on another device, but it must
     * be scanned from QR-code using in-app camera. An alert similar to "This code
     * can be used to allow someone to log in to your Telegram account. To confirm
     * Telegram login, please go to Settings > Devices > Scan QR and scan the code"
     * needs to be shown
     */
    readonly _: 'internalLinkTypeQrCodeAuthentication',
  }

  export type internalLinkTypeRestorePurchases = {
    /**
     * The link forces restore of App Store purchases when opened. For official iOS
     * application only
     */
    _: 'internalLinkTypeRestorePurchases',
  }

  export type internalLinkTypeRestorePurchases$Input = {
    /**
     * The link forces restore of App Store purchases when opened. For official iOS
     * application only
     */
    readonly _: 'internalLinkTypeRestorePurchases',
  }

  export type internalLinkTypeSettings = {
    /** The link is a link to application settings */
    _: 'internalLinkTypeSettings',
  }

  export type internalLinkTypeSettings$Input = {
    /** The link is a link to application settings */
    readonly _: 'internalLinkTypeSettings',
  }

  export type internalLinkTypeSideMenuBot = {
    /**
     * The link is a link to a bot, which can be installed to the side menu. Call searchPublicChat
     * with the given bot username, check that the user is a bot and can be added to
     * attachment menu. Then, use getAttachmentMenuBot to receive information about
     * the bot. If the bot isn't added to side menu, then show a disclaimer about Mini
     * Apps being a third-party apps, ask the user to accept their Terms of service
     * and confirm adding the bot to side and attachment menu. If the user accept the
     * terms and confirms adding, then use toggleBotIsAddedToAttachmentMenu to add
     * the bot. If the bot is added to side menu, then use getWebAppUrl with the given
     * URL
     */
    _: 'internalLinkTypeSideMenuBot',
    /** Username of the bot */
    bot_username: string,
    /** URL to be passed to getWebAppUrl */
    url: string,
  }

  export type internalLinkTypeSideMenuBot$Input = {
    /**
     * The link is a link to a bot, which can be installed to the side menu. Call searchPublicChat
     * with the given bot username, check that the user is a bot and can be added to
     * attachment menu. Then, use getAttachmentMenuBot to receive information about
     * the bot. If the bot isn't added to side menu, then show a disclaimer about Mini
     * Apps being a third-party apps, ask the user to accept their Terms of service
     * and confirm adding the bot to side and attachment menu. If the user accept the
     * terms and confirms adding, then use toggleBotIsAddedToAttachmentMenu to add
     * the bot. If the bot is added to side menu, then use getWebAppUrl with the given
     * URL
     */
    readonly _: 'internalLinkTypeSideMenuBot',
    /** Username of the bot */
    readonly bot_username?: string,
    /** URL to be passed to getWebAppUrl */
    readonly url?: string,
  }

  export type internalLinkTypeStickerSet = {
    /**
     * The link is a link to a sticker set. Call searchStickerSet with the given sticker
     * set name to process the link and show the sticker set
     */
    _: 'internalLinkTypeStickerSet',
    /** Name of the sticker set */
    sticker_set_name: string,
    /** True, if the sticker set is expected to contain custom emoji */
    expect_custom_emoji: boolean,
  }

  export type internalLinkTypeStickerSet$Input = {
    /**
     * The link is a link to a sticker set. Call searchStickerSet with the given sticker
     * set name to process the link and show the sticker set
     */
    readonly _: 'internalLinkTypeStickerSet',
    /** Name of the sticker set */
    readonly sticker_set_name?: string,
    /** True, if the sticker set is expected to contain custom emoji */
    readonly expect_custom_emoji?: boolean,
  }

  export type internalLinkTypeStory = {
    /**
     * The link is a link to a story. Call searchPublicChat with the given sender username,
     * then call getStory with the received chat identifier and the given story identifier
     */
    _: 'internalLinkTypeStory',
    /** Username of the sender of the story */
    story_sender_username: string,
    /** Story identifier */
    story_id: number,
  }

  export type internalLinkTypeStory$Input = {
    /**
     * The link is a link to a story. Call searchPublicChat with the given sender username,
     * then call getStory with the received chat identifier and the given story identifier
     */
    readonly _: 'internalLinkTypeStory',
    /** Username of the sender of the story */
    readonly story_sender_username?: string,
    /** Story identifier */
    readonly story_id?: number,
  }

  export type internalLinkTypeTheme = {
    /** The link is a link to a theme. TDLib has no theme support yet */
    _: 'internalLinkTypeTheme',
    /** Name of the theme */
    theme_name: string,
  }

  export type internalLinkTypeTheme$Input = {
    /** The link is a link to a theme. TDLib has no theme support yet */
    readonly _: 'internalLinkTypeTheme',
    /** Name of the theme */
    readonly theme_name?: string,
  }

  export type internalLinkTypeThemeSettings = {
    /** The link is a link to the theme section of the app settings */
    _: 'internalLinkTypeThemeSettings',
  }

  export type internalLinkTypeThemeSettings$Input = {
    /** The link is a link to the theme section of the app settings */
    readonly _: 'internalLinkTypeThemeSettings',
  }

  export type internalLinkTypeUnknownDeepLink = {
    /** The link is an unknown tg: link. Call getDeepLinkInfo to process the link */
    _: 'internalLinkTypeUnknownDeepLink',
    /** Link to be passed to getDeepLinkInfo */
    link: string,
  }

  export type internalLinkTypeUnknownDeepLink$Input = {
    /** The link is an unknown tg: link. Call getDeepLinkInfo to process the link */
    readonly _: 'internalLinkTypeUnknownDeepLink',
    /** Link to be passed to getDeepLinkInfo */
    readonly link?: string,
  }

  export type internalLinkTypeUnsupportedProxy = {
    /** The link is a link to an unsupported proxy. An alert can be shown to the user */
    _: 'internalLinkTypeUnsupportedProxy',
  }

  export type internalLinkTypeUnsupportedProxy$Input = {
    /** The link is a link to an unsupported proxy. An alert can be shown to the user */
    readonly _: 'internalLinkTypeUnsupportedProxy',
  }

  export type internalLinkTypeUserPhoneNumber = {
    /**
     * The link is a link to a user by its phone number. Call searchUserByPhoneNumber
     * with the given phone number to process the link
     */
    _: 'internalLinkTypeUserPhoneNumber',
    /** Phone number of the user */
    phone_number: string,
  }

  export type internalLinkTypeUserPhoneNumber$Input = {
    /**
     * The link is a link to a user by its phone number. Call searchUserByPhoneNumber
     * with the given phone number to process the link
     */
    readonly _: 'internalLinkTypeUserPhoneNumber',
    /** Phone number of the user */
    readonly phone_number?: string,
  }

  export type internalLinkTypeUserToken = {
    /**
     * The link is a link to a user by a temporary token. Call searchUserByToken with
     * the given token to process the link
     */
    _: 'internalLinkTypeUserToken',
    /** The token */
    token: string,
  }

  export type internalLinkTypeUserToken$Input = {
    /**
     * The link is a link to a user by a temporary token. Call searchUserByToken with
     * the given token to process the link
     */
    readonly _: 'internalLinkTypeUserToken',
    /** The token */
    readonly token?: string,
  }

  export type internalLinkTypeVideoChat = {
    /**
     * The link is a link to a video chat. Call searchPublicChat with the given chat
     * username, and then joinGroupCall with the given invite hash to process the link
     */
    _: 'internalLinkTypeVideoChat',
    /** Username of the chat with the video chat */
    chat_username: string,
    /**
     * If non-empty, invite hash to be used to join the video chat without being muted
     * by administrators
     */
    invite_hash: string,
    /**
     * True, if the video chat is expected to be a live stream in a channel or a broadcast
     * group
     */
    is_live_stream: boolean,
  }

  export type internalLinkTypeVideoChat$Input = {
    /**
     * The link is a link to a video chat. Call searchPublicChat with the given chat
     * username, and then joinGroupCall with the given invite hash to process the link
     */
    readonly _: 'internalLinkTypeVideoChat',
    /** Username of the chat with the video chat */
    readonly chat_username?: string,
    /**
     * If non-empty, invite hash to be used to join the video chat without being muted
     * by administrators
     */
    readonly invite_hash?: string,
    /**
     * True, if the video chat is expected to be a live stream in a channel or a broadcast
     * group
     */
    readonly is_live_stream?: boolean,
  }

  export type internalLinkTypeWebApp = {
    /**
     * The link is a link to a Web App. Call searchPublicChat with the given bot username,
     * check that the user is a bot, then call searchWebApp with the received bot and
     * the given web_app_short_name. Process received foundWebApp by showing a confirmation
     * dialog if needed. If the bot can be added to attachment or side menu, but isn't
     * added yet, then show a disclaimer about Mini Apps being a third-party apps instead
     * of the dialog and ask the user to accept their Terms of service. If the user
     * accept the terms and confirms adding, then use toggleBotIsAddedToAttachmentMenu
     * to add the bot. Then, call getWebAppLinkUrl and open the returned URL as a Web
     * App
     */
    _: 'internalLinkTypeWebApp',
    /** Username of the bot that owns the Web App */
    bot_username: string,
    /** Short name of the Web App */
    web_app_short_name: string,
    /** Start parameter to be passed to getWebAppLinkUrl */
    start_parameter: string,
  }

  export type internalLinkTypeWebApp$Input = {
    /**
     * The link is a link to a Web App. Call searchPublicChat with the given bot username,
     * check that the user is a bot, then call searchWebApp with the received bot and
     * the given web_app_short_name. Process received foundWebApp by showing a confirmation
     * dialog if needed. If the bot can be added to attachment or side menu, but isn't
     * added yet, then show a disclaimer about Mini Apps being a third-party apps instead
     * of the dialog and ask the user to accept their Terms of service. If the user
     * accept the terms and confirms adding, then use toggleBotIsAddedToAttachmentMenu
     * to add the bot. Then, call getWebAppLinkUrl and open the returned URL as a Web
     * App
     */
    readonly _: 'internalLinkTypeWebApp',
    /** Username of the bot that owns the Web App */
    readonly bot_username?: string,
    /** Short name of the Web App */
    readonly web_app_short_name?: string,
    /** Start parameter to be passed to getWebAppLinkUrl */
    readonly start_parameter?: string,
  }

  export type messageLink = {
    /** Contains an HTTPS link to a message in a supergroup or channel, or a forum topic */
    _: 'messageLink',
    /** The link */
    link: string,
    /** True, if the link will work for non-members of the chat */
    is_public: boolean,
  }

  export type messageLinkInfo = {
    /** Contains information about a link to a message or a forum topic in a chat */
    _: 'messageLinkInfo',
    /** True, if the link is a public link for a message or a forum topic in a chat */
    is_public: boolean,
    /** If found, identifier of the chat to which the link points, 0 otherwise */
    chat_id: number,
    /**
     * If found, identifier of the message thread in which to open the message, or
     * a forum topic to open if the message is missing
     */
    message_thread_id: number,
    /** If found, the linked message; may be null */
    message?: message,
    /**
     * Timestamp from which the video/audio/video note/voice note playing must start,
     * in seconds; 0 if not specified. The media can be in the message content or in
     * its web page preview
     */
    media_timestamp: number,
    /** True, if the whole media album to which the message belongs is linked */
    for_album: boolean,
  }

  export type chatBoostLink = {
    /** Contains an HTTPS link to boost a chat */
    _: 'chatBoostLink',
    /** The link */
    link: string,
    /** True, if the link will work for non-members of the chat */
    is_public: boolean,
  }

  export type chatBoostLinkInfo = {
    /** Contains information about a link to boost a a chat */
    _: 'chatBoostLinkInfo',
    /** True, if the link will work for non-members of the chat */
    is_public: boolean,
    /** Identifier of the chat to which the link points; 0 if the chat isn't found */
    chat_id: number,
  }

  export type blockListMain = {
    /**
     * The main block list that disallows writing messages to the current user, receiving
     * their status and photo, viewing of stories, and some other actions
     */
    _: 'blockListMain',
  }

  export type blockListMain$Input = {
    /**
     * The main block list that disallows writing messages to the current user, receiving
     * their status and photo, viewing of stories, and some other actions
     */
    readonly _: 'blockListMain',
  }

  export type blockListStories = {
    /** The block list that disallows viewing of stories of the current user */
    _: 'blockListStories',
  }

  export type blockListStories$Input = {
    /** The block list that disallows viewing of stories of the current user */
    readonly _: 'blockListStories',
  }

  export type filePart = {
    /** Contains a part of a file */
    _: 'filePart',
    /** File bytes */
    data: string,
  }

  export type fileTypeNone = {
    /** The data is not a file */
    _: 'fileTypeNone',
  }

  export type fileTypeNone$Input = {
    /** The data is not a file */
    readonly _: 'fileTypeNone',
  }

  export type fileTypeAnimation = {
    /** The file is an animation */
    _: 'fileTypeAnimation',
  }

  export type fileTypeAnimation$Input = {
    /** The file is an animation */
    readonly _: 'fileTypeAnimation',
  }

  export type fileTypeAudio = {
    /** The file is an audio file */
    _: 'fileTypeAudio',
  }

  export type fileTypeAudio$Input = {
    /** The file is an audio file */
    readonly _: 'fileTypeAudio',
  }

  export type fileTypeDocument = {
    /** The file is a document */
    _: 'fileTypeDocument',
  }

  export type fileTypeDocument$Input = {
    /** The file is a document */
    readonly _: 'fileTypeDocument',
  }

  export type fileTypeNotificationSound = {
    /** The file is a notification sound */
    _: 'fileTypeNotificationSound',
  }

  export type fileTypeNotificationSound$Input = {
    /** The file is a notification sound */
    readonly _: 'fileTypeNotificationSound',
  }

  export type fileTypePhoto = {
    /** The file is a photo */
    _: 'fileTypePhoto',
  }

  export type fileTypePhoto$Input = {
    /** The file is a photo */
    readonly _: 'fileTypePhoto',
  }

  export type fileTypePhotoStory = {
    /** The file is a photo published as a story */
    _: 'fileTypePhotoStory',
  }

  export type fileTypePhotoStory$Input = {
    /** The file is a photo published as a story */
    readonly _: 'fileTypePhotoStory',
  }

  export type fileTypeProfilePhoto = {
    /** The file is a profile photo */
    _: 'fileTypeProfilePhoto',
  }

  export type fileTypeProfilePhoto$Input = {
    /** The file is a profile photo */
    readonly _: 'fileTypeProfilePhoto',
  }

  export type fileTypeSecret = {
    /** The file was sent to a secret chat (the file type is not known to the server) */
    _: 'fileTypeSecret',
  }

  export type fileTypeSecret$Input = {
    /** The file was sent to a secret chat (the file type is not known to the server) */
    readonly _: 'fileTypeSecret',
  }

  export type fileTypeSecretThumbnail = {
    /** The file is a thumbnail of a file from a secret chat */
    _: 'fileTypeSecretThumbnail',
  }

  export type fileTypeSecretThumbnail$Input = {
    /** The file is a thumbnail of a file from a secret chat */
    readonly _: 'fileTypeSecretThumbnail',
  }

  export type fileTypeSecure = {
    /** The file is a file from Secure storage used for storing Telegram Passport files */
    _: 'fileTypeSecure',
  }

  export type fileTypeSecure$Input = {
    /** The file is a file from Secure storage used for storing Telegram Passport files */
    readonly _: 'fileTypeSecure',
  }

  export type fileTypeSticker = {
    /** The file is a sticker */
    _: 'fileTypeSticker',
  }

  export type fileTypeSticker$Input = {
    /** The file is a sticker */
    readonly _: 'fileTypeSticker',
  }

  export type fileTypeThumbnail = {
    /** The file is a thumbnail of another file */
    _: 'fileTypeThumbnail',
  }

  export type fileTypeThumbnail$Input = {
    /** The file is a thumbnail of another file */
    readonly _: 'fileTypeThumbnail',
  }

  export type fileTypeUnknown = {
    /** The file type is not yet known */
    _: 'fileTypeUnknown',
  }

  export type fileTypeUnknown$Input = {
    /** The file type is not yet known */
    readonly _: 'fileTypeUnknown',
  }

  export type fileTypeVideo = {
    /** The file is a video */
    _: 'fileTypeVideo',
  }

  export type fileTypeVideo$Input = {
    /** The file is a video */
    readonly _: 'fileTypeVideo',
  }

  export type fileTypeVideoNote = {
    /** The file is a video note */
    _: 'fileTypeVideoNote',
  }

  export type fileTypeVideoNote$Input = {
    /** The file is a video note */
    readonly _: 'fileTypeVideoNote',
  }

  export type fileTypeVideoStory = {
    /** The file is a video published as a story */
    _: 'fileTypeVideoStory',
  }

  export type fileTypeVideoStory$Input = {
    /** The file is a video published as a story */
    readonly _: 'fileTypeVideoStory',
  }

  export type fileTypeVoiceNote = {
    /** The file is a voice note */
    _: 'fileTypeVoiceNote',
  }

  export type fileTypeVoiceNote$Input = {
    /** The file is a voice note */
    readonly _: 'fileTypeVoiceNote',
  }

  export type fileTypeWallpaper = {
    /** The file is a wallpaper or a background pattern */
    _: 'fileTypeWallpaper',
  }

  export type fileTypeWallpaper$Input = {
    /** The file is a wallpaper or a background pattern */
    readonly _: 'fileTypeWallpaper',
  }

  export type storageStatisticsByFileType = {
    /** Contains the storage usage statistics for a specific file type */
    _: 'storageStatisticsByFileType',
    /** File type */
    file_type: FileType,
    /** Total size of the files, in bytes */
    size: number,
    /** Total number of files */
    count: number,
  }

  export type storageStatisticsByChat = {
    /** Contains the storage usage statistics for a specific chat */
    _: 'storageStatisticsByChat',
    /** Chat identifier; 0 if none */
    chat_id: number,
    /** Total size of the files in the chat, in bytes */
    size: number,
    /** Total number of files in the chat */
    count: number,
    /** Statistics split by file types */
    by_file_type: Array<storageStatisticsByFileType>,
  }

  export type storageStatistics = {
    /** Contains the exact storage usage statistics split by chats and file type */
    _: 'storageStatistics',
    /** Total size of files, in bytes */
    size: number,
    /** Total number of files */
    count: number,
    /** Statistics split by chats */
    by_chat: Array<storageStatisticsByChat>,
  }

  export type storageStatisticsFast = {
    /**
     * Contains approximate storage usage statistics, excluding files of unknown file
     * type
     */
    _: 'storageStatisticsFast',
    /** Approximate total size of files, in bytes */
    files_size: number,
    /** Approximate number of files */
    file_count: number,
    /** Size of the database */
    database_size: number,
    /** Size of the language pack database */
    language_pack_database_size: number,
    /** Size of the TDLib internal log */
    log_size: number,
  }

  export type databaseStatistics = {
    /** Contains database statistics */
    _: 'databaseStatistics',
    /** Database statistics in an unspecified human-readable format */
    statistics: string,
  }

  export type networkTypeNone = {
    /** The network is not available */
    _: 'networkTypeNone',
  }

  export type networkTypeNone$Input = {
    /** The network is not available */
    readonly _: 'networkTypeNone',
  }

  export type networkTypeMobile = {
    /** A mobile network */
    _: 'networkTypeMobile',
  }

  export type networkTypeMobile$Input = {
    /** A mobile network */
    readonly _: 'networkTypeMobile',
  }

  export type networkTypeMobileRoaming = {
    /** A mobile roaming network */
    _: 'networkTypeMobileRoaming',
  }

  export type networkTypeMobileRoaming$Input = {
    /** A mobile roaming network */
    readonly _: 'networkTypeMobileRoaming',
  }

  export type networkTypeWiFi = {
    /** A Wi-Fi network */
    _: 'networkTypeWiFi',
  }

  export type networkTypeWiFi$Input = {
    /** A Wi-Fi network */
    readonly _: 'networkTypeWiFi',
  }

  export type networkTypeOther = {
    /** A different network type (e.g., Ethernet network) */
    _: 'networkTypeOther',
  }

  export type networkTypeOther$Input = {
    /** A different network type (e.g., Ethernet network) */
    readonly _: 'networkTypeOther',
  }

  export type networkStatisticsEntryFile = {
    /**
     * Contains information about the total amount of data that was used to send and
     * receive files
     */
    _: 'networkStatisticsEntryFile',
    /**
     * Type of the file the data is part of; pass null if the data isn't related to
     * files
     */
    file_type: FileType,
    /**
     * Type of the network the data was sent through. Call setNetworkType to maintain
     * the actual network type
     */
    network_type: NetworkType,
    /** Total number of bytes sent */
    sent_bytes: number,
    /** Total number of bytes received */
    received_bytes: number,
  }

  export type networkStatisticsEntryFile$Input = {
    /**
     * Contains information about the total amount of data that was used to send and
     * receive files
     */
    readonly _: 'networkStatisticsEntryFile',
    /**
     * Type of the file the data is part of; pass null if the data isn't related to
     * files
     */
    readonly file_type?: FileType$Input,
    /**
     * Type of the network the data was sent through. Call setNetworkType to maintain
     * the actual network type
     */
    readonly network_type?: NetworkType$Input,
    /** Total number of bytes sent */
    readonly sent_bytes?: number,
    /** Total number of bytes received */
    readonly received_bytes?: number,
  }

  export type networkStatisticsEntryCall = {
    /** Contains information about the total amount of data that was used for calls */
    _: 'networkStatisticsEntryCall',
    /**
     * Type of the network the data was sent through. Call setNetworkType to maintain
     * the actual network type
     */
    network_type: NetworkType,
    /** Total number of bytes sent */
    sent_bytes: number,
    /** Total number of bytes received */
    received_bytes: number,
    /** Total call duration, in seconds */
    duration: number,
  }

  export type networkStatisticsEntryCall$Input = {
    /** Contains information about the total amount of data that was used for calls */
    readonly _: 'networkStatisticsEntryCall',
    /**
     * Type of the network the data was sent through. Call setNetworkType to maintain
     * the actual network type
     */
    readonly network_type?: NetworkType$Input,
    /** Total number of bytes sent */
    readonly sent_bytes?: number,
    /** Total number of bytes received */
    readonly received_bytes?: number,
    /** Total call duration, in seconds */
    readonly duration?: number,
  }

  export type networkStatistics = {
    /** A full list of available network statistic entries */
    _: 'networkStatistics',
    /** Point in time (Unix timestamp) from which the statistics are collected */
    since_date: number,
    /** Network statistics entries */
    entries: Array<NetworkStatisticsEntry>,
  }

  export type autoDownloadSettings = {
    /** Contains auto-download settings */
    _: 'autoDownloadSettings',
    /** True, if the auto-download is enabled */
    is_auto_download_enabled: boolean,
    /** The maximum size of a photo file to be auto-downloaded, in bytes */
    max_photo_file_size: number,
    /** The maximum size of a video file to be auto-downloaded, in bytes */
    max_video_file_size: number,
    /** The maximum size of other file types to be auto-downloaded, in bytes */
    max_other_file_size: number,
    /** The maximum suggested bitrate for uploaded videos, in kbit/s */
    video_upload_bitrate: number,
    /** True, if the beginning of video files needs to be preloaded for instant playback */
    preload_large_videos: boolean,
    /**
     * True, if the next audio track needs to be preloaded while the user is listening
     * to an audio file
     */
    preload_next_audio: boolean,
    /** True, if stories needs to be preloaded */
    preload_stories: boolean,
    /** True, if "use less data for calls" option needs to be enabled */
    use_less_data_for_calls: boolean,
  }

  export type autoDownloadSettings$Input = {
    /** Contains auto-download settings */
    readonly _: 'autoDownloadSettings',
    /** True, if the auto-download is enabled */
    readonly is_auto_download_enabled?: boolean,
    /** The maximum size of a photo file to be auto-downloaded, in bytes */
    readonly max_photo_file_size?: number,
    /** The maximum size of a video file to be auto-downloaded, in bytes */
    readonly max_video_file_size?: number,
    /** The maximum size of other file types to be auto-downloaded, in bytes */
    readonly max_other_file_size?: number,
    /** The maximum suggested bitrate for uploaded videos, in kbit/s */
    readonly video_upload_bitrate?: number,
    /** True, if the beginning of video files needs to be preloaded for instant playback */
    readonly preload_large_videos?: boolean,
    /**
     * True, if the next audio track needs to be preloaded while the user is listening
     * to an audio file
     */
    readonly preload_next_audio?: boolean,
    /** True, if stories needs to be preloaded */
    readonly preload_stories?: boolean,
    /** True, if "use less data for calls" option needs to be enabled */
    readonly use_less_data_for_calls?: boolean,
  }

  export type autoDownloadSettingsPresets = {
    /** Contains auto-download settings presets for the current user */
    _: 'autoDownloadSettingsPresets',
    /** Preset with lowest settings; supposed to be used by default when roaming */
    low: autoDownloadSettings,
    /**
     * Preset with medium settings; supposed to be used by default when using mobile
     * data
     */
    medium: autoDownloadSettings,
    /**
     * Preset with highest settings; supposed to be used by default when connected
     * on Wi-Fi
     */
    high: autoDownloadSettings,
  }

  export type autosaveSettingsScopePrivateChats = {
    /** Autosave settings applied to all private chats without chat-specific settings */
    _: 'autosaveSettingsScopePrivateChats',
  }

  export type autosaveSettingsScopePrivateChats$Input = {
    /** Autosave settings applied to all private chats without chat-specific settings */
    readonly _: 'autosaveSettingsScopePrivateChats',
  }

  export type autosaveSettingsScopeGroupChats = {
    /**
     * Autosave settings applied to all basic group and supergroup chats without chat-specific
     * settings
     */
    _: 'autosaveSettingsScopeGroupChats',
  }

  export type autosaveSettingsScopeGroupChats$Input = {
    /**
     * Autosave settings applied to all basic group and supergroup chats without chat-specific
     * settings
     */
    readonly _: 'autosaveSettingsScopeGroupChats',
  }

  export type autosaveSettingsScopeChannelChats = {
    /** Autosave settings applied to all channel chats without chat-specific settings */
    _: 'autosaveSettingsScopeChannelChats',
  }

  export type autosaveSettingsScopeChannelChats$Input = {
    /** Autosave settings applied to all channel chats without chat-specific settings */
    readonly _: 'autosaveSettingsScopeChannelChats',
  }

  export type autosaveSettingsScopeChat = {
    /** Autosave settings applied to a chat */
    _: 'autosaveSettingsScopeChat',
    /** Chat identifier */
    chat_id: number,
  }

  export type autosaveSettingsScopeChat$Input = {
    /** Autosave settings applied to a chat */
    readonly _: 'autosaveSettingsScopeChat',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type scopeAutosaveSettings = {
    /** Contains autosave settings for an autosave settings scope */
    _: 'scopeAutosaveSettings',
    /** True, if photo autosave is enabled */
    autosave_photos: boolean,
    /** True, if video autosave is enabled */
    autosave_videos: boolean,
    /** The maximum size of a video file to be autosaved, in bytes; 512 KB - 4000 MB */
    max_video_file_size: number,
  }

  export type scopeAutosaveSettings$Input = {
    /** Contains autosave settings for an autosave settings scope */
    readonly _: 'scopeAutosaveSettings',
    /** True, if photo autosave is enabled */
    readonly autosave_photos?: boolean,
    /** True, if video autosave is enabled */
    readonly autosave_videos?: boolean,
    /** The maximum size of a video file to be autosaved, in bytes; 512 KB - 4000 MB */
    readonly max_video_file_size?: number,
  }

  export type autosaveSettingsException = {
    /**
     * Contains autosave settings for a chat, which overrides default settings for
     * the corresponding scope
     */
    _: 'autosaveSettingsException',
    /** Chat identifier */
    chat_id: number,
    /** Autosave settings for the chat */
    settings: scopeAutosaveSettings,
  }

  export type autosaveSettings = {
    /** Describes autosave settings */
    _: 'autosaveSettings',
    /** Default autosave settings for private chats */
    private_chat_settings: scopeAutosaveSettings,
    /** Default autosave settings for basic group and supergroup chats */
    group_settings: scopeAutosaveSettings,
    /** Default autosave settings for channel chats */
    channel_settings: scopeAutosaveSettings,
    /** Autosave settings for specific chats */
    exceptions: Array<autosaveSettingsException>,
  }

  export type connectionStateWaitingForNetwork = {
    /**
     * Currently waiting for the network to become available. Use setNetworkType to
     * change the available network type
     */
    _: 'connectionStateWaitingForNetwork',
  }

  export type connectionStateConnectingToProxy = {
    /** Currently establishing a connection with a proxy server */
    _: 'connectionStateConnectingToProxy',
  }

  export type connectionStateConnecting = {
    /** Currently establishing a connection to the Telegram servers */
    _: 'connectionStateConnecting',
  }

  export type connectionStateUpdating = {
    /** Downloading data received while the application was offline */
    _: 'connectionStateUpdating',
  }

  export type connectionStateReady = {
    /** There is a working connection to the Telegram servers */
    _: 'connectionStateReady',
  }

  export type topChatCategoryUsers$Input = {
    /** A category containing frequently used private chats with non-bot users */
    readonly _: 'topChatCategoryUsers',
  }

  export type topChatCategoryBots$Input = {
    /** A category containing frequently used private chats with bot users */
    readonly _: 'topChatCategoryBots',
  }

  export type topChatCategoryGroups$Input = {
    /** A category containing frequently used basic groups and supergroups */
    readonly _: 'topChatCategoryGroups',
  }

  export type topChatCategoryChannels$Input = {
    /** A category containing frequently used channels */
    readonly _: 'topChatCategoryChannels',
  }

  export type topChatCategoryInlineBots$Input = {
    /**
     * A category containing frequently used chats with inline bots sorted by their
     * usage in inline mode
     */
    readonly _: 'topChatCategoryInlineBots',
  }

  export type topChatCategoryCalls$Input = {
    /** A category containing frequently used chats used for calls */
    readonly _: 'topChatCategoryCalls',
  }

  export type topChatCategoryForwardChats$Input = {
    /** A category containing frequently used chats used to forward messages */
    readonly _: 'topChatCategoryForwardChats',
  }

  export type foundPositions = {
    /** Contains 0-based positions of matched objects */
    _: 'foundPositions',
    /** Total number of matched objects */
    total_count: number,
    /** The positions of the matched objects */
    positions: Array<number>,
  }

  export type tMeUrlTypeUser = {
    /** A URL linking to a user */
    _: 'tMeUrlTypeUser',
    /** Identifier of the user */
    user_id: number,
  }

  export type tMeUrlTypeSupergroup = {
    /** A URL linking to a public supergroup or channel */
    _: 'tMeUrlTypeSupergroup',
    /** Identifier of the supergroup or channel */
    supergroup_id: number,
  }

  export type tMeUrlTypeChatInvite = {
    /** A chat invite link */
    _: 'tMeUrlTypeChatInvite',
    /** Information about the chat invite link */
    info: chatInviteLinkInfo,
  }

  export type tMeUrlTypeStickerSet = {
    /** A URL linking to a sticker set */
    _: 'tMeUrlTypeStickerSet',
    /** Identifier of the sticker set */
    sticker_set_id: number | string,
  }

  export type tMeUrl = {
    /** Represents a URL linking to an internal Telegram entity */
    _: 'tMeUrl',
    /** URL */
    url: string,
    /** Type of the URL */
    type: TMeUrlType,
  }

  export type tMeUrls = {
    /** Contains a list of t.me URLs */
    _: 'tMeUrls',
    /** List of URLs */
    urls: Array<tMeUrl>,
  }

  export type suggestedActionEnableArchiveAndMuteNewChats = {
    /**
     * Suggests the user to enable archive_and_mute_new_chats_from_unknown_users setting
     * in archiveChatListSettings
     */
    _: 'suggestedActionEnableArchiveAndMuteNewChats',
  }

  export type suggestedActionEnableArchiveAndMuteNewChats$Input = {
    /**
     * Suggests the user to enable archive_and_mute_new_chats_from_unknown_users setting
     * in archiveChatListSettings
     */
    readonly _: 'suggestedActionEnableArchiveAndMuteNewChats',
  }

  export type suggestedActionCheckPassword = {
    /**
     * Suggests the user to check whether they still remember their 2-step verification
     * password
     */
    _: 'suggestedActionCheckPassword',
  }

  export type suggestedActionCheckPassword$Input = {
    /**
     * Suggests the user to check whether they still remember their 2-step verification
     * password
     */
    readonly _: 'suggestedActionCheckPassword',
  }

  export type suggestedActionCheckPhoneNumber = {
    /**
     * Suggests the user to check whether authorization phone number is correct and
     * change the phone number if it is inaccessible
     */
    _: 'suggestedActionCheckPhoneNumber',
  }

  export type suggestedActionCheckPhoneNumber$Input = {
    /**
     * Suggests the user to check whether authorization phone number is correct and
     * change the phone number if it is inaccessible
     */
    readonly _: 'suggestedActionCheckPhoneNumber',
  }

  export type suggestedActionViewChecksHint = {
    /**
     * Suggests the user to view a hint about the meaning of one and two check marks
     * on sent messages
     */
    _: 'suggestedActionViewChecksHint',
  }

  export type suggestedActionViewChecksHint$Input = {
    /**
     * Suggests the user to view a hint about the meaning of one and two check marks
     * on sent messages
     */
    readonly _: 'suggestedActionViewChecksHint',
  }

  export type suggestedActionConvertToBroadcastGroup = {
    /** Suggests the user to convert specified supergroup to a broadcast group */
    _: 'suggestedActionConvertToBroadcastGroup',
    /** Supergroup identifier */
    supergroup_id: number,
  }

  export type suggestedActionConvertToBroadcastGroup$Input = {
    /** Suggests the user to convert specified supergroup to a broadcast group */
    readonly _: 'suggestedActionConvertToBroadcastGroup',
    /** Supergroup identifier */
    readonly supergroup_id?: number,
  }

  export type suggestedActionSetPassword = {
    /**
     * Suggests the user to set a 2-step verification password to be able to log in
     * again
     */
    _: 'suggestedActionSetPassword',
    /**
     * The number of days to pass between consecutive authorizations if the user declines
     * to set password; if 0, then the user is advised to set the password for security
     * reasons
     */
    authorization_delay: number,
  }

  export type suggestedActionSetPassword$Input = {
    /**
     * Suggests the user to set a 2-step verification password to be able to log in
     * again
     */
    readonly _: 'suggestedActionSetPassword',
    /**
     * The number of days to pass between consecutive authorizations if the user declines
     * to set password; if 0, then the user is advised to set the password for security
     * reasons
     */
    readonly authorization_delay?: number,
  }

  export type suggestedActionUpgradePremium = {
    /**
     * Suggests the user to upgrade the Premium subscription from monthly payments
     * to annual payments
     */
    _: 'suggestedActionUpgradePremium',
  }

  export type suggestedActionUpgradePremium$Input = {
    /**
     * Suggests the user to upgrade the Premium subscription from monthly payments
     * to annual payments
     */
    readonly _: 'suggestedActionUpgradePremium',
  }

  export type suggestedActionRestorePremium = {
    /** Suggests the user to restore a recently expired Premium subscription */
    _: 'suggestedActionRestorePremium',
  }

  export type suggestedActionRestorePremium$Input = {
    /** Suggests the user to restore a recently expired Premium subscription */
    readonly _: 'suggestedActionRestorePremium',
  }

  export type suggestedActionSubscribeToAnnualPremium = {
    /** Suggests the user to subscribe to the Premium subscription with annual payments */
    _: 'suggestedActionSubscribeToAnnualPremium',
  }

  export type suggestedActionSubscribeToAnnualPremium$Input = {
    /** Suggests the user to subscribe to the Premium subscription with annual payments */
    readonly _: 'suggestedActionSubscribeToAnnualPremium',
  }

  export type count = {
    /** Contains a counter */
    _: 'count',
    /** Count */
    count: number,
  }

  export type text = {
    /** Contains some text */
    _: 'text',
    /** Text */
    text: string,
  }

  export type seconds = {
    /** Contains a value representing a number of seconds */
    _: 'seconds',
    /** Number of seconds */
    seconds: number,
  }

  export type fileDownloadedPrefixSize = {
    /** Contains size of downloaded prefix of a file */
    _: 'fileDownloadedPrefixSize',
    /** The prefix size, in bytes */
    size: number,
  }

  export type deepLinkInfo = {
    /** Contains information about a tg: deep link */
    _: 'deepLinkInfo',
    /** Text to be shown to the user */
    text: formattedText,
    /** True, if the user must be asked to update the application */
    need_update_application: boolean,
  }

  export type textParseModeMarkdown$Input = {
    /** The text uses Markdown-style formatting */
    readonly _: 'textParseModeMarkdown',
    /**
     * Version of the parser: 0 or 1 - Telegram Bot API "Markdown" parse mode, 2 -
     * Telegram Bot API "MarkdownV2" parse mode
     */
    readonly version?: number,
  }

  export type textParseModeHTML$Input = {
    /**
     * The text uses HTML-style formatting. The same as Telegram Bot API "HTML" parse
     * mode
     */
    readonly _: 'textParseModeHTML',
  }

  export type proxyTypeSocks5 = {
    /** A SOCKS5 proxy server */
    _: 'proxyTypeSocks5',
    /** Username for logging in; may be empty */
    username: string,
    /** Password for logging in; may be empty */
    password: string,
  }

  export type proxyTypeSocks5$Input = {
    /** A SOCKS5 proxy server */
    readonly _: 'proxyTypeSocks5',
    /** Username for logging in; may be empty */
    readonly username?: string,
    /** Password for logging in; may be empty */
    readonly password?: string,
  }

  export type proxyTypeHttp = {
    /** A HTTP transparent proxy server */
    _: 'proxyTypeHttp',
    /** Username for logging in; may be empty */
    username: string,
    /** Password for logging in; may be empty */
    password: string,
    /**
     * Pass true if the proxy supports only HTTP requests and doesn't support transparent
     * TCP connections via HTTP CONNECT method
     */
    http_only: boolean,
  }

  export type proxyTypeHttp$Input = {
    /** A HTTP transparent proxy server */
    readonly _: 'proxyTypeHttp',
    /** Username for logging in; may be empty */
    readonly username?: string,
    /** Password for logging in; may be empty */
    readonly password?: string,
    /**
     * Pass true if the proxy supports only HTTP requests and doesn't support transparent
     * TCP connections via HTTP CONNECT method
     */
    readonly http_only?: boolean,
  }

  export type proxyTypeMtproto = {
    /** An MTProto proxy server */
    _: 'proxyTypeMtproto',
    /** The proxy's secret in hexadecimal encoding */
    secret: string,
  }

  export type proxyTypeMtproto$Input = {
    /** An MTProto proxy server */
    readonly _: 'proxyTypeMtproto',
    /** The proxy's secret in hexadecimal encoding */
    readonly secret?: string,
  }

  export type proxy = {
    /** Contains information about a proxy server */
    _: 'proxy',
    /** Unique identifier of the proxy */
    id: number,
    /** Proxy server domain or IP address */
    server: string,
    /** Proxy server port */
    port: number,
    /** Point in time (Unix timestamp) when the proxy was last used; 0 if never */
    last_used_date: number,
    /** True, if the proxy is enabled now */
    is_enabled: boolean,
    /** Type of the proxy */
    type: ProxyType,
  }

  export type proxies = {
    /** Represents a list of proxy servers */
    _: 'proxies',
    /** List of proxy servers */
    proxies: Array<proxy>,
  }

  export type inputSticker$Input = {
    /** A sticker to be added to a sticker set */
    readonly _: 'inputSticker',
    /**
     * File with the sticker; must fit in a 512x512 square. For WEBP stickers the file
     * must be in WEBP or PNG format, which will be converted to WEBP server-side.
     * See https://core.telegram.org/animated_stickers#technical-requirements for technical
     * requirements
     */
    readonly sticker?: InputFile$Input,
    /** String with 1-20 emoji corresponding to the sticker */
    readonly emojis?: string,
    /** Position where the mask is placed; pass null if not specified */
    readonly mask_position?: maskPosition$Input,
    /**
     * List of up to 20 keywords with total length up to 64 characters, which can be
     * used to find the sticker
     */
    readonly keywords?: ReadonlyArray<string>,
  }

  export type dateRange = {
    /** Represents a date range */
    _: 'dateRange',
    /** Point in time (Unix timestamp) at which the date range begins */
    start_date: number,
    /** Point in time (Unix timestamp) at which the date range ends */
    end_date: number,
  }

  export type statisticalValue = {
    /** A value with information about its recent changes */
    _: 'statisticalValue',
    /** The current value */
    value: number,
    /** The value for the previous day */
    previous_value: number,
    /** The growth rate of the value, as a percentage */
    growth_rate_percentage: number,
  }

  export type statisticalGraphData = {
    /** A graph data */
    _: 'statisticalGraphData',
    /** Graph data in JSON format */
    json_data: string,
    /** If non-empty, a token which can be used to receive a zoomed in graph */
    zoom_token: string,
  }

  export type statisticalGraphAsync = {
    /** The graph data to be asynchronously loaded through getStatisticalGraph */
    _: 'statisticalGraphAsync',
    /** The token to use for data loading */
    token: string,
  }

  export type statisticalGraphError = {
    /** An error message to be shown to the user instead of the graph */
    _: 'statisticalGraphError',
    /** The error message */
    error_message: string,
  }

  export type chatStatisticsMessageInteractionInfo = {
    /** Contains statistics about interactions with a message */
    _: 'chatStatisticsMessageInteractionInfo',
    /** Message identifier */
    message_id: number,
    /** Number of times the message was viewed */
    view_count: number,
    /** Number of times the message was forwarded */
    forward_count: number,
  }

  export type chatStatisticsMessageSenderInfo = {
    /** Contains statistics about messages sent by a user */
    _: 'chatStatisticsMessageSenderInfo',
    /** User identifier */
    user_id: number,
    /** Number of sent messages */
    sent_message_count: number,
    /** Average number of characters in sent messages; 0 if unknown */
    average_character_count: number,
  }

  export type chatStatisticsAdministratorActionsInfo = {
    /** Contains statistics about administrator actions done by a user */
    _: 'chatStatisticsAdministratorActionsInfo',
    /** Administrator user identifier */
    user_id: number,
    /** Number of messages deleted by the administrator */
    deleted_message_count: number,
    /** Number of users banned by the administrator */
    banned_user_count: number,
    /** Number of users restricted by the administrator */
    restricted_user_count: number,
  }

  export type chatStatisticsInviterInfo = {
    /** Contains statistics about number of new members invited by a user */
    _: 'chatStatisticsInviterInfo',
    /** User identifier */
    user_id: number,
    /** Number of new members invited by the user */
    added_member_count: number,
  }

  export type chatStatisticsSupergroup = {
    /** A detailed statistics about a supergroup chat */
    _: 'chatStatisticsSupergroup',
    /** A period to which the statistics applies */
    period: dateRange,
    /** Number of members in the chat */
    member_count: statisticalValue,
    /** Number of messages sent to the chat */
    message_count: statisticalValue,
    /** Number of users who viewed messages in the chat */
    viewer_count: statisticalValue,
    /** Number of users who sent messages to the chat */
    sender_count: statisticalValue,
    /** A graph containing number of members in the chat */
    member_count_graph: StatisticalGraph,
    /** A graph containing number of members joined and left the chat */
    join_graph: StatisticalGraph,
    /** A graph containing number of new member joins per source */
    join_by_source_graph: StatisticalGraph,
    /** A graph containing distribution of active users per language */
    language_graph: StatisticalGraph,
    /** A graph containing distribution of sent messages by content type */
    message_content_graph: StatisticalGraph,
    /** A graph containing number of different actions in the chat */
    action_graph: StatisticalGraph,
    /** A graph containing distribution of message views per hour */
    day_graph: StatisticalGraph,
    /** A graph containing distribution of message views per day of week */
    week_graph: StatisticalGraph,
    /** List of users sent most messages in the last week */
    top_senders: Array<chatStatisticsMessageSenderInfo>,
    /** List of most active administrators in the last week */
    top_administrators: Array<chatStatisticsAdministratorActionsInfo>,
    /** List of most active inviters of new members in the last week */
    top_inviters: Array<chatStatisticsInviterInfo>,
  }

  export type chatStatisticsChannel = {
    /** A detailed statistics about a channel chat */
    _: 'chatStatisticsChannel',
    /** A period to which the statistics applies */
    period: dateRange,
    /** Number of members in the chat */
    member_count: statisticalValue,
    /** Mean number of times the recently sent messages was viewed */
    mean_view_count: statisticalValue,
    /** Mean number of times the recently sent messages was shared */
    mean_share_count: statisticalValue,
    /** A percentage of users with enabled notifications for the chat */
    enabled_notifications_percentage: number,
    /** A graph containing number of members in the chat */
    member_count_graph: StatisticalGraph,
    /** A graph containing number of members joined and left the chat */
    join_graph: StatisticalGraph,
    /** A graph containing number of members muted and unmuted the chat */
    mute_graph: StatisticalGraph,
    /** A graph containing number of message views in a given hour in the last two weeks */
    view_count_by_hour_graph: StatisticalGraph,
    /** A graph containing number of message views per source */
    view_count_by_source_graph: StatisticalGraph,
    /** A graph containing number of new member joins per source */
    join_by_source_graph: StatisticalGraph,
    /** A graph containing number of users viewed chat messages per language */
    language_graph: StatisticalGraph,
    /** A graph containing number of chat message views and shares */
    message_interaction_graph: StatisticalGraph,
    /** A graph containing number of views of associated with the chat instant views */
    instant_view_interaction_graph: StatisticalGraph,
    /** Detailed statistics about number of views and shares of recently sent messages */
    recent_message_interactions: Array<chatStatisticsMessageInteractionInfo>,
  }

  export type messageStatistics = {
    /** A detailed statistics about a message */
    _: 'messageStatistics',
    /** A graph containing number of message views and shares */
    message_interaction_graph: StatisticalGraph,
  }

  export type point = {
    /** A point on a Cartesian plane */
    _: 'point',
    /** The point's first coordinate */
    x: number,
    /** The point's second coordinate */
    y: number,
  }

  export type vectorPathCommandLine = {
    /** A straight line to a given point */
    _: 'vectorPathCommandLine',
    /** The end point of the straight line */
    end_point: point,
  }

  export type vectorPathCommandCubicBezierCurve = {
    /** A cubic Bézier curve to a given point */
    _: 'vectorPathCommandCubicBezierCurve',
    /** The start control point of the curve */
    start_control_point: point,
    /** The end control point of the curve */
    end_control_point: point,
    /** The end point of the curve */
    end_point: point,
  }

  export type botCommandScopeDefault$Input = {
    /** A scope covering all users */
    readonly _: 'botCommandScopeDefault',
  }

  export type botCommandScopeAllPrivateChats$Input = {
    /** A scope covering all private chats */
    readonly _: 'botCommandScopeAllPrivateChats',
  }

  export type botCommandScopeAllGroupChats$Input = {
    /** A scope covering all group and supergroup chats */
    readonly _: 'botCommandScopeAllGroupChats',
  }

  export type botCommandScopeAllChatAdministrators$Input = {
    /** A scope covering all group and supergroup chat administrators */
    readonly _: 'botCommandScopeAllChatAdministrators',
  }

  export type botCommandScopeChat$Input = {
    /** A scope covering all members of a chat */
    readonly _: 'botCommandScopeChat',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type botCommandScopeChatAdministrators$Input = {
    /** A scope covering all administrators of a chat */
    readonly _: 'botCommandScopeChatAdministrators',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type botCommandScopeChatMember$Input = {
    /** A scope covering a member of a chat */
    readonly _: 'botCommandScopeChatMember',
    /** Chat identifier */
    readonly chat_id?: number,
    /** User identifier */
    readonly user_id?: number,
  }

  export type updateAuthorizationState = {
    /** The user authorization state has changed */
    _: 'updateAuthorizationState',
    /** New authorization state */
    authorization_state: AuthorizationState,
  }

  export type updateNewMessage = {
    /** A new message was received; can also be an outgoing message */
    _: 'updateNewMessage',
    /** The new message */
    message: message,
  }

  export type updateMessageSendAcknowledged = {
    /**
     * A request to send a message has reached the Telegram server. This doesn't mean
     * that the message will be sent successfully or even that the send message request
     * will be processed. This update will be sent only if the option "use_quick_ack"
     * is set to true. This update may be sent multiple times for the same message
     */
    _: 'updateMessageSendAcknowledged',
    /** The chat identifier of the sent message */
    chat_id: number,
    /** A temporary message identifier */
    message_id: number,
  }

  export type updateMessageSendSucceeded = {
    /** A message has been successfully sent */
    _: 'updateMessageSendSucceeded',
    /**
     * The sent message. Usually only the message identifier, date, and content are
     * changed, but almost all other fields can also change
     */
    message: message,
    /** The previous temporary message identifier */
    old_message_id: number,
  }

  export type updateMessageSendFailed = {
    /**
     * A message failed to send. Be aware that some messages being sent can be irrecoverably
     * deleted, in which case updateDeleteMessages will be received instead of this
     * update
     */
    _: 'updateMessageSendFailed',
    /** The failed to send message */
    message: message,
    /** The previous temporary message identifier */
    old_message_id: number,
    /** The cause of the message sending failure */
    error: error,
  }

  export type updateMessageContent = {
    /** The message content has changed */
    _: 'updateMessageContent',
    /** Chat identifier */
    chat_id: number,
    /** Message identifier */
    message_id: number,
    /** New message content */
    new_content: MessageContent,
  }

  export type updateMessageEdited = {
    /**
     * A message was edited. Changes in the message content will come in a separate
     * updateMessageContent
     */
    _: 'updateMessageEdited',
    /** Chat identifier */
    chat_id: number,
    /** Message identifier */
    message_id: number,
    /** Point in time (Unix timestamp) when the message was edited */
    edit_date: number,
    /** New message reply markup; may be null */
    reply_markup?: ReplyMarkup,
  }

  export type updateMessageIsPinned = {
    /** The message pinned state was changed */
    _: 'updateMessageIsPinned',
    /** Chat identifier */
    chat_id: number,
    /** The message identifier */
    message_id: number,
    /** True, if the message is pinned */
    is_pinned: boolean,
  }

  export type updateMessageInteractionInfo = {
    /** The information about interactions with a message has changed */
    _: 'updateMessageInteractionInfo',
    /** Chat identifier */
    chat_id: number,
    /** Message identifier */
    message_id: number,
    /** New information about interactions with the message; may be null */
    interaction_info?: messageInteractionInfo,
  }

  export type updateMessageContentOpened = {
    /**
     * The message content was opened. Updates voice note messages to "listened", video
     * note messages to "viewed" and starts the self-destruct timer
     */
    _: 'updateMessageContentOpened',
    /** Chat identifier */
    chat_id: number,
    /** Message identifier */
    message_id: number,
  }

  export type updateMessageMentionRead = {
    /** A message with an unread mention was read */
    _: 'updateMessageMentionRead',
    /** Chat identifier */
    chat_id: number,
    /** Message identifier */
    message_id: number,
    /** The new number of unread mention messages left in the chat */
    unread_mention_count: number,
  }

  export type updateMessageUnreadReactions = {
    /** The list of unread reactions added to a message was changed */
    _: 'updateMessageUnreadReactions',
    /** Chat identifier */
    chat_id: number,
    /** Message identifier */
    message_id: number,
    /** The new list of unread reactions */
    unread_reactions: Array<unreadReaction>,
    /** The new number of messages with unread reactions left in the chat */
    unread_reaction_count: number,
  }

  export type updateMessageLiveLocationViewed = {
    /**
     * A message with a live location was viewed. When the update is received, the
     * application is supposed to update the live location
     */
    _: 'updateMessageLiveLocationViewed',
    /** Identifier of the chat with the live location message */
    chat_id: number,
    /** Identifier of the message with live location */
    message_id: number,
  }

  export type updateNewChat = {
    /**
     * A new chat has been loaded/created. This update is guaranteed to come before
     * the chat identifier is returned to the application. The chat field changes will
     * be reported through separate updates
     */
    _: 'updateNewChat',
    /** The chat */
    chat: chat,
  }

  export type updateChatTitle = {
    /** The title of a chat was changed */
    _: 'updateChatTitle',
    /** Chat identifier */
    chat_id: number,
    /** The new chat title */
    title: string,
  }

  export type updateChatPhoto = {
    /** A chat photo was changed */
    _: 'updateChatPhoto',
    /** Chat identifier */
    chat_id: number,
    /** The new chat photo; may be null */
    photo?: chatPhotoInfo,
  }

  export type updateChatPermissions = {
    /** Chat permissions was changed */
    _: 'updateChatPermissions',
    /** Chat identifier */
    chat_id: number,
    /** The new chat permissions */
    permissions: chatPermissions,
  }

  export type updateChatLastMessage = {
    /**
     * The last message of a chat was changed. If last_message is null, then the last
     * message in the chat became unknown. Some new unknown messages might be added
     * to the chat in this case
     */
    _: 'updateChatLastMessage',
    /** Chat identifier */
    chat_id: number,
    /** The new last message in the chat; may be null */
    last_message?: message,
    /** The new chat positions in the chat lists */
    positions: Array<chatPosition>,
  }

  export type updateChatPosition = {
    /**
     * The position of a chat in a chat list has changed. An updateChatLastMessage
     * or updateChatDraftMessage update might be sent instead of the update
     */
    _: 'updateChatPosition',
    /** Chat identifier */
    chat_id: number,
    /**
     * New chat position. If new order is 0, then the chat needs to be removed from
     * the list
     */
    position: chatPosition,
  }

  export type updateChatReadInbox = {
    /** Incoming messages were read or the number of unread messages has been changed */
    _: 'updateChatReadInbox',
    /** Chat identifier */
    chat_id: number,
    /** Identifier of the last read incoming message */
    last_read_inbox_message_id: number,
    /** The number of unread messages left in the chat */
    unread_count: number,
  }

  export type updateChatReadOutbox = {
    /** Outgoing messages were read */
    _: 'updateChatReadOutbox',
    /** Chat identifier */
    chat_id: number,
    /** Identifier of last read outgoing message */
    last_read_outbox_message_id: number,
  }

  export type updateChatActionBar = {
    /** The chat action bar was changed */
    _: 'updateChatActionBar',
    /** Chat identifier */
    chat_id: number,
    /** The new value of the action bar; may be null */
    action_bar?: ChatActionBar,
  }

  export type updateChatAvailableReactions = {
    /** The chat available reactions were changed */
    _: 'updateChatAvailableReactions',
    /** Chat identifier */
    chat_id: number,
    /** The new reactions, available in the chat */
    available_reactions: ChatAvailableReactions,
  }

  export type updateChatDraftMessage = {
    /**
     * A chat draft has changed. Be aware that the update may come in the currently
     * opened chat but with old content of the draft. If the user has changed the content
     * of the draft, this update mustn't be applied
     */
    _: 'updateChatDraftMessage',
    /** Chat identifier */
    chat_id: number,
    /** The new draft message; may be null */
    draft_message?: draftMessage,
    /** The new chat positions in the chat lists */
    positions: Array<chatPosition>,
  }

  export type updateChatMessageSender = {
    /** The message sender that is selected to send messages in a chat has changed */
    _: 'updateChatMessageSender',
    /** Chat identifier */
    chat_id: number,
    /**
     * New value of message_sender_id; may be null if the user can't change message
     * sender
     */
    message_sender_id?: MessageSender,
  }

  export type updateChatMessageAutoDeleteTime = {
    /** The message auto-delete or self-destruct timer setting for a chat was changed */
    _: 'updateChatMessageAutoDeleteTime',
    /** Chat identifier */
    chat_id: number,
    /** New value of message_auto_delete_time */
    message_auto_delete_time: number,
  }

  export type updateChatNotificationSettings = {
    /** Notification settings for a chat were changed */
    _: 'updateChatNotificationSettings',
    /** Chat identifier */
    chat_id: number,
    /** The new notification settings */
    notification_settings: chatNotificationSettings,
  }

  export type updateChatPendingJoinRequests = {
    /** The chat pending join requests were changed */
    _: 'updateChatPendingJoinRequests',
    /** Chat identifier */
    chat_id: number,
    /** The new data about pending join requests; may be null */
    pending_join_requests?: chatJoinRequestsInfo,
  }

  export type updateChatReplyMarkup = {
    /**
     * The default chat reply markup was changed. Can occur because new messages with
     * reply markup were received or because an old reply markup was hidden by the
     * user
     */
    _: 'updateChatReplyMarkup',
    /** Chat identifier */
    chat_id: number,
    /**
     * Identifier of the message from which reply markup needs to be used; 0 if there
     * is no default custom reply markup in the chat
     */
    reply_markup_message_id: number,
  }

  export type updateChatBackground = {
    /** The chat background was changed */
    _: 'updateChatBackground',
    /** Chat identifier */
    chat_id: number,
    /** The new chat background; may be null if background was reset to default */
    background?: chatBackground,
  }

  export type updateChatTheme = {
    /** The chat theme was changed */
    _: 'updateChatTheme',
    /** Chat identifier */
    chat_id: number,
    /** The new name of the chat theme; may be empty if theme was reset to default */
    theme_name: string,
  }

  export type updateChatUnreadMentionCount = {
    /** The chat unread_mention_count has changed */
    _: 'updateChatUnreadMentionCount',
    /** Chat identifier */
    chat_id: number,
    /** The number of unread mention messages left in the chat */
    unread_mention_count: number,
  }

  export type updateChatUnreadReactionCount = {
    /** The chat unread_reaction_count has changed */
    _: 'updateChatUnreadReactionCount',
    /** Chat identifier */
    chat_id: number,
    /** The number of messages with unread reactions left in the chat */
    unread_reaction_count: number,
  }

  export type updateChatVideoChat = {
    /** A chat video chat state has changed */
    _: 'updateChatVideoChat',
    /** Chat identifier */
    chat_id: number,
    /** New value of video_chat */
    video_chat: videoChat,
  }

  export type updateChatDefaultDisableNotification = {
    /**
     * The value of the default disable_notification parameter, used when a message
     * is sent to the chat, was changed
     */
    _: 'updateChatDefaultDisableNotification',
    /** Chat identifier */
    chat_id: number,
    /** The new default_disable_notification value */
    default_disable_notification: boolean,
  }

  export type updateChatHasProtectedContent = {
    /** A chat content was allowed or restricted for saving */
    _: 'updateChatHasProtectedContent',
    /** Chat identifier */
    chat_id: number,
    /** New value of has_protected_content */
    has_protected_content: boolean,
  }

  export type updateChatIsTranslatable = {
    /** Translation of chat messages was enabled or disabled */
    _: 'updateChatIsTranslatable',
    /** Chat identifier */
    chat_id: number,
    /** New value of is_translatable */
    is_translatable: boolean,
  }

  export type updateChatIsMarkedAsUnread = {
    /** A chat was marked as unread or was read */
    _: 'updateChatIsMarkedAsUnread',
    /** Chat identifier */
    chat_id: number,
    /** New value of is_marked_as_unread */
    is_marked_as_unread: boolean,
  }

  export type updateChatBlockList = {
    /** A chat was blocked or unblocked */
    _: 'updateChatBlockList',
    /** Chat identifier */
    chat_id: number,
    /** Block list to which the chat is added; may be null if none */
    block_list?: BlockList,
  }

  export type updateChatHasScheduledMessages = {
    /** A chat's has_scheduled_messages field has changed */
    _: 'updateChatHasScheduledMessages',
    /** Chat identifier */
    chat_id: number,
    /** New value of has_scheduled_messages */
    has_scheduled_messages: boolean,
  }

  export type updateChatFolders = {
    /** The list of chat folders or a chat folder has changed */
    _: 'updateChatFolders',
    /** The new list of chat folders */
    chat_folders: Array<chatFolderInfo>,
    /** Position of the main chat list among chat folders, 0-based */
    main_chat_list_position: number,
  }

  export type updateChatOnlineMemberCount = {
    /**
     * The number of online group members has changed. This update with non-zero number
     * of online group members is sent only for currently opened chats. There is no
     * guarantee that it will be sent just after the number of online users has changed
     */
    _: 'updateChatOnlineMemberCount',
    /** Identifier of the chat */
    chat_id: number,
    /** New number of online members in the chat, or 0 if unknown */
    online_member_count: number,
  }

  export type updateForumTopicInfo = {
    /** Basic information about a topic in a forum chat was changed */
    _: 'updateForumTopicInfo',
    /** Chat identifier */
    chat_id: number,
    /** New information about the topic */
    info: forumTopicInfo,
  }

  export type updateScopeNotificationSettings = {
    /** Notification settings for some type of chats were updated */
    _: 'updateScopeNotificationSettings',
    /** Types of chats for which notification settings were updated */
    scope: NotificationSettingsScope,
    /** The new notification settings */
    notification_settings: scopeNotificationSettings,
  }

  export type updateNotification = {
    /** A notification was changed */
    _: 'updateNotification',
    /** Unique notification group identifier */
    notification_group_id: number,
    /** Changed notification */
    notification: notification,
  }

  export type updateNotificationGroup = {
    /** A list of active notifications in a notification group has changed */
    _: 'updateNotificationGroup',
    /** Unique notification group identifier */
    notification_group_id: number,
    /** New type of the notification group */
    type: NotificationGroupType,
    /** Identifier of a chat to which all notifications in the group belong */
    chat_id: number,
    /** Chat identifier, which notification settings must be applied to the added notifications */
    notification_settings_chat_id: number,
    /** Identifier of the notification sound to be played; 0 if sound is disabled */
    notification_sound_id: number | string,
    /**
     * Total number of unread notifications in the group, can be bigger than number
     * of active notifications
     */
    total_count: number,
    /** List of added group notifications, sorted by notification identifier */
    added_notifications: Array<notification>,
    /** Identifiers of removed group notifications, sorted by notification identifier */
    removed_notification_ids: Array<number>,
  }

  export type updateActiveNotifications = {
    /**
     * Contains active notifications that was shown on previous application launches.
     * This update is sent only if the message database is used. In that case it comes
     * once before any updateNotification and updateNotificationGroup update
     */
    _: 'updateActiveNotifications',
    /** Lists of active notification groups */
    groups: Array<notificationGroup>,
  }

  export type updateHavePendingNotifications = {
    /**
     * Describes whether there are some pending notification updates. Can be used to
     * prevent application from killing, while there are some pending notifications
     */
    _: 'updateHavePendingNotifications',
    /** True, if there are some delayed notification updates, which will be sent soon */
    have_delayed_notifications: boolean,
    /**
     * True, if there can be some yet unreceived notifications, which are being fetched
     * from the server
     */
    have_unreceived_notifications: boolean,
  }

  export type updateDeleteMessages = {
    /** Some messages were deleted */
    _: 'updateDeleteMessages',
    /** Chat identifier */
    chat_id: number,
    /** Identifiers of the deleted messages */
    message_ids: Array<number>,
    /**
     * True, if the messages are permanently deleted by a user (as opposed to just
     * becoming inaccessible)
     */
    is_permanent: boolean,
    /**
     * True, if the messages are deleted only from the cache and can possibly be retrieved
     * again in the future
     */
    from_cache: boolean,
  }

  export type updateChatAction = {
    /** A message sender activity in the chat has changed */
    _: 'updateChatAction',
    /** Chat identifier */
    chat_id: number,
    /** If not 0, a message thread identifier in which the action was performed */
    message_thread_id: number,
    /** Identifier of a message sender performing the action */
    sender_id: MessageSender,
    /** The action */
    action: ChatAction,
  }

  export type updateUserStatus = {
    /** The user went online or offline */
    _: 'updateUserStatus',
    /** User identifier */
    user_id: number,
    /** New status of the user */
    status: UserStatus,
  }

  export type updateUser = {
    /**
     * Some data of a user has changed. This update is guaranteed to come before the
     * user identifier is returned to the application
     */
    _: 'updateUser',
    /** New data about the user */
    user: user,
  }

  export type updateBasicGroup = {
    /**
     * Some data of a basic group has changed. This update is guaranteed to come before
     * the basic group identifier is returned to the application
     */
    _: 'updateBasicGroup',
    /** New data about the group */
    basic_group: basicGroup,
  }

  export type updateSupergroup = {
    /**
     * Some data of a supergroup or a channel has changed. This update is guaranteed
     * to come before the supergroup identifier is returned to the application
     */
    _: 'updateSupergroup',
    /** New data about the supergroup */
    supergroup: supergroup,
  }

  export type updateSecretChat = {
    /**
     * Some data of a secret chat has changed. This update is guaranteed to come before
     * the secret chat identifier is returned to the application
     */
    _: 'updateSecretChat',
    /** New data about the secret chat */
    secret_chat: secretChat,
  }

  export type updateUserFullInfo = {
    /** Some data in userFullInfo has been changed */
    _: 'updateUserFullInfo',
    /** User identifier */
    user_id: number,
    /** New full information about the user */
    user_full_info: userFullInfo,
  }

  export type updateBasicGroupFullInfo = {
    /** Some data in basicGroupFullInfo has been changed */
    _: 'updateBasicGroupFullInfo',
    /** Identifier of a basic group */
    basic_group_id: number,
    /** New full information about the group */
    basic_group_full_info: basicGroupFullInfo,
  }

  export type updateSupergroupFullInfo = {
    /** Some data in supergroupFullInfo has been changed */
    _: 'updateSupergroupFullInfo',
    /** Identifier of the supergroup or channel */
    supergroup_id: number,
    /** New full information about the supergroup */
    supergroup_full_info: supergroupFullInfo,
  }

  export type updateServiceNotification = {
    /**
     * A service notification from the server was received. Upon receiving this the
     * application must show a popup with the content of the notification
     */
    _: 'updateServiceNotification',
    /**
     * Notification type. If type begins with "AUTH_KEY_DROP_", then two buttons "Cancel"
     * and "Log out" must be shown under notification; if user presses the second,
     * all local data must be destroyed using Destroy method
     */
    type: string,
    /** Notification content */
    content: MessageContent,
  }

  export type updateFile = {
    /** Information about a file was updated */
    _: 'updateFile',
    /** New data about the file */
    file: file,
  }

  export type updateFileGenerationStart = {
    /** The file generation process needs to be started by the application */
    _: 'updateFileGenerationStart',
    /** Unique identifier for the generation process */
    generation_id: number | string,
    /** The path to a file from which a new file is generated; may be empty */
    original_path: string,
    /** The path to a file that must be created and where the new file is generated */
    destination_path: string,
    /**
     * String specifying the conversion applied to the original file. If conversion
     * is "#url#" than original_path contains an HTTP/HTTPS URL of a file, which must
     * be downloaded by the application
     */
    conversion: string,
  }

  export type updateFileGenerationStop = {
    /** File generation is no longer needed */
    _: 'updateFileGenerationStop',
    /** Unique identifier for the generation process */
    generation_id: number | string,
  }

  export type updateFileDownloads = {
    /** The state of the file download list has changed */
    _: 'updateFileDownloads',
    /** Total size of files in the file download list, in bytes */
    total_size: number,
    /** Total number of files in the file download list */
    total_count: number,
    /** Total downloaded size of files in the file download list, in bytes */
    downloaded_size: number,
  }

  export type updateFileAddedToDownloads = {
    /**
     * A file was added to the file download list. This update is sent only after file
     * download list is loaded for the first time
     */
    _: 'updateFileAddedToDownloads',
    /** The added file download */
    file_download: fileDownload,
    /** New number of being downloaded and recently downloaded files found */
    counts: downloadedFileCounts,
  }

  export type updateFileDownload = {
    /**
     * A file download was changed. This update is sent only after file download list
     * is loaded for the first time
     */
    _: 'updateFileDownload',
    /** File identifier */
    file_id: number,
    /**
     * Point in time (Unix timestamp) when the file downloading was completed; 0 if
     * the file downloading isn't completed
     */
    complete_date: number,
    /** True, if downloading of the file is paused */
    is_paused: boolean,
    /** New number of being downloaded and recently downloaded files found */
    counts: downloadedFileCounts,
  }

  export type updateFileRemovedFromDownloads = {
    /**
     * A file was removed from the file download list. This update is sent only after
     * file download list is loaded for the first time
     */
    _: 'updateFileRemovedFromDownloads',
    /** File identifier */
    file_id: number,
    /** New number of being downloaded and recently downloaded files found */
    counts: downloadedFileCounts,
  }

  export type updateCall = {
    /** New call was created or information about a call was updated */
    _: 'updateCall',
    /** New data about a call */
    call: call,
  }

  export type updateGroupCall = {
    /** Information about a group call was updated */
    _: 'updateGroupCall',
    /** New data about a group call */
    group_call: groupCall,
  }

  export type updateGroupCallParticipant = {
    /**
     * Information about a group call participant was changed. The updates are sent
     * only after the group call is received through getGroupCall and only if the call
     * is joined or being joined
     */
    _: 'updateGroupCallParticipant',
    /** Identifier of group call */
    group_call_id: number,
    /** New data about a participant */
    participant: groupCallParticipant,
  }

  export type updateNewCallSignalingData = {
    /** New call signaling data arrived */
    _: 'updateNewCallSignalingData',
    /** The call identifier */
    call_id: number,
    /** The data */
    data: string,
  }

  export type updateUserPrivacySettingRules = {
    /** Some privacy setting rules have been changed */
    _: 'updateUserPrivacySettingRules',
    /** The privacy setting */
    setting: UserPrivacySetting,
    /** New privacy rules */
    rules: userPrivacySettingRules,
  }

  export type updateUnreadMessageCount = {
    /**
     * Number of unread messages in a chat list has changed. This update is sent only
     * if the message database is used
     */
    _: 'updateUnreadMessageCount',
    /** The chat list with changed number of unread messages */
    chat_list: ChatList,
    /** Total number of unread messages */
    unread_count: number,
    /** Total number of unread messages in unmuted chats */
    unread_unmuted_count: number,
  }

  export type updateUnreadChatCount = {
    /**
     * Number of unread chats, i.e. with unread messages or marked as unread, has changed.
     * This update is sent only if the message database is used
     */
    _: 'updateUnreadChatCount',
    /** The chat list with changed number of unread messages */
    chat_list: ChatList,
    /** Approximate total number of chats in the chat list */
    total_count: number,
    /** Total number of unread chats */
    unread_count: number,
    /** Total number of unread unmuted chats */
    unread_unmuted_count: number,
    /** Total number of chats marked as unread */
    marked_as_unread_count: number,
    /** Total number of unmuted chats marked as unread */
    marked_as_unread_unmuted_count: number,
  }

  export type updateStory = {
    /** A story was changed */
    _: 'updateStory',
    /** The new information about the story */
    story: story,
  }

  export type updateStoryDeleted = {
    /** A story became inaccessible */
    _: 'updateStoryDeleted',
    /** Identifier of the chat that posted the story */
    story_sender_chat_id: number,
    /** Story identifier */
    story_id: number,
  }

  export type updateStorySendSucceeded = {
    /** A story has been successfully sent */
    _: 'updateStorySendSucceeded',
    /** The sent story */
    story: story,
    /** The previous temporary story identifier */
    old_story_id: number,
  }

  export type updateStorySendFailed = {
    /**
     * A story failed to send. If the story sending is canceled, then updateStoryDeleted
     * will be received instead of this update
     */
    _: 'updateStorySendFailed',
    /** The failed to send story */
    story: story,
    /** The cause of the story sending failure */
    error: error,
    /** Type of the error; may be null if unknown */
    error_type?: CanSendStoryResult,
  }

  export type updateChatActiveStories = {
    /** The list of active stories posted by a specific chat has changed */
    _: 'updateChatActiveStories',
    /** The new list of active stories */
    active_stories: chatActiveStories,
  }

  export type updateStoryListChatCount = {
    /** Number of chats in a story list has changed */
    _: 'updateStoryListChatCount',
    /** The story list */
    story_list: StoryList,
    /** Approximate total number of chats with active stories in the list */
    chat_count: number,
  }

  export type updateStoryStealthMode = {
    /** Story stealth mode settings have changed */
    _: 'updateStoryStealthMode',
    /** Point in time (Unix timestamp) until stealth mode is active; 0 if it is disabled */
    active_until_date: number,
    /**
     * Point in time (Unix timestamp) when stealth mode can be enabled again; 0 if
     * there is no active cooldown
     */
    cooldown_until_date: number,
  }

  export type updateOption = {
    /** An option changed its value */
    _: 'updateOption',
    /** The option name */
    name: string,
    /** The new option value */
    value: OptionValue,
  }

  export type updateStickerSet = {
    /** A sticker set has changed */
    _: 'updateStickerSet',
    /** The sticker set */
    sticker_set: stickerSet,
  }

  export type updateInstalledStickerSets = {
    /** The list of installed sticker sets was updated */
    _: 'updateInstalledStickerSets',
    /** Type of the affected stickers */
    sticker_type: StickerType,
    /** The new list of installed ordinary sticker sets */
    sticker_set_ids: Array<number | string>,
  }

  export type updateTrendingStickerSets = {
    /** The list of trending sticker sets was updated or some of them were viewed */
    _: 'updateTrendingStickerSets',
    /** Type of the affected stickers */
    sticker_type: StickerType,
    /**
     * The prefix of the list of trending sticker sets with the newest trending sticker
     * sets
     */
    sticker_sets: trendingStickerSets,
  }

  export type updateRecentStickers = {
    /** The list of recently used stickers was updated */
    _: 'updateRecentStickers',
    /**
     * True, if the list of stickers attached to photo or video files was updated;
     * otherwise, the list of sent stickers is updated
     */
    is_attached: boolean,
    /** The new list of file identifiers of recently used stickers */
    sticker_ids: Array<number>,
  }

  export type updateFavoriteStickers = {
    /** The list of favorite stickers was updated */
    _: 'updateFavoriteStickers',
    /** The new list of file identifiers of favorite stickers */
    sticker_ids: Array<number>,
  }

  export type updateSavedAnimations = {
    /** The list of saved animations was updated */
    _: 'updateSavedAnimations',
    /** The new list of file identifiers of saved animations */
    animation_ids: Array<number>,
  }

  export type updateSavedNotificationSounds = {
    /**
     * The list of saved notifications sounds was updated. This update may not be sent
     * until information about a notification sound was requested for the first time
     */
    _: 'updateSavedNotificationSounds',
    /** The new list of identifiers of saved notification sounds */
    notification_sound_ids: Array<number | string>,
  }

  export type updateSelectedBackground = {
    /** The selected background has changed */
    _: 'updateSelectedBackground',
    /** True, if background for dark theme has changed */
    for_dark_theme: boolean,
    /** The new selected background; may be null */
    background?: background,
  }

  export type updateChatThemes = {
    /** The list of available chat themes has changed */
    _: 'updateChatThemes',
    /** The new list of chat themes */
    chat_themes: Array<chatTheme>,
  }

  export type updateLanguagePackStrings = {
    /** Some language pack strings have been updated */
    _: 'updateLanguagePackStrings',
    /** Localization target to which the language pack belongs */
    localization_target: string,
    /** Identifier of the updated language pack */
    language_pack_id: string,
    /** List of changed language pack strings; empty if all strings have changed */
    strings: Array<languagePackString>,
  }

  export type updateConnectionState = {
    /**
     * The connection state has changed. This update must be used only to show a human-readable
     * description of the connection state
     */
    _: 'updateConnectionState',
    /** The new connection state */
    state: ConnectionState,
  }

  export type updateTermsOfService = {
    /**
     * New terms of service must be accepted by the user. If the terms of service are
     * declined, then the deleteAccount method must be called with the reason "Decline
     * ToS update"
     */
    _: 'updateTermsOfService',
    /** Identifier of the terms of service */
    terms_of_service_id: string,
    /** The new terms of service */
    terms_of_service: termsOfService,
  }

  export type updateUsersNearby = {
    /**
     * The list of users nearby has changed. The update is guaranteed to be sent only
     * 60 seconds after a successful searchChatsNearby request
     */
    _: 'updateUsersNearby',
    /** The new list of users nearby */
    users_nearby: Array<chatNearby>,
  }

  export type updateUnconfirmedSession = {
    /** The first unconfirmed session has changed */
    _: 'updateUnconfirmedSession',
    /** The unconfirmed session; may be null if none */
    session?: unconfirmedSession,
  }

  export type updateAttachmentMenuBots = {
    /** The list of bots added to attachment or side menu has changed */
    _: 'updateAttachmentMenuBots',
    /** The new list of bots. The bots must not be shown on scheduled messages screen */
    bots: Array<attachmentMenuBot>,
  }

  export type updateWebAppMessageSent = {
    /** A message was sent by an opened Web App, so the Web App needs to be closed */
    _: 'updateWebAppMessageSent',
    /** Identifier of Web App launch */
    web_app_launch_id: number | string,
  }

  export type updateActiveEmojiReactions = {
    /** The list of active emoji reactions has changed */
    _: 'updateActiveEmojiReactions',
    /** The new list of active emoji reactions */
    emojis: Array<string>,
  }

  export type updateDefaultReactionType = {
    /** The type of default reaction has changed */
    _: 'updateDefaultReactionType',
    /** The new type of the default reaction */
    reaction_type: ReactionType,
  }

  export type updateDiceEmojis = {
    /** The list of supported dice emojis has changed */
    _: 'updateDiceEmojis',
    /** The new list of supported dice emojis */
    emojis: Array<string>,
  }

  export type updateAnimatedEmojiMessageClicked = {
    /**
     * Some animated emoji message was clicked and a big animated sticker must be played
     * if the message is visible on the screen. chatActionWatchingAnimations with the
     * text of the message needs to be sent if the sticker is played
     */
    _: 'updateAnimatedEmojiMessageClicked',
    /** Chat identifier */
    chat_id: number,
    /** Message identifier */
    message_id: number,
    /** The animated sticker to be played */
    sticker: sticker,
  }

  export type updateAnimationSearchParameters = {
    /**
     * The parameters of animation search through getOption("animation_search_bot_username")
     * bot has changed
     */
    _: 'updateAnimationSearchParameters',
    /** Name of the animation search provider */
    provider: string,
    /** The new list of emojis suggested for searching */
    emojis: Array<string>,
  }

  export type updateSuggestedActions = {
    /** The list of suggested to the user actions has changed */
    _: 'updateSuggestedActions',
    /** Added suggested actions */
    added_actions: Array<SuggestedAction>,
    /** Removed suggested actions */
    removed_actions: Array<SuggestedAction>,
  }

  export type updateAddChatMembersPrivacyForbidden = {
    /**
     * Adding users to a chat has failed because of their privacy settings. An invite
     * link can be shared with the users if appropriate
     */
    _: 'updateAddChatMembersPrivacyForbidden',
    /** Chat identifier */
    chat_id: number,
    /** Identifiers of users, which weren't added because of their privacy settings */
    user_ids: Array<number>,
  }

  export type updateAutosaveSettings = {
    /** Autosave settings for some type of chats were updated */
    _: 'updateAutosaveSettings',
    /** Type of chats for which autosave settings were updated */
    scope: AutosaveSettingsScope,
    /** The new autosave settings; may be null if the settings are reset to default */
    settings?: scopeAutosaveSettings,
  }

  export type updateNewInlineQuery = {
    /** A new incoming inline query; for bots only */
    _: 'updateNewInlineQuery',
    /** Unique query identifier */
    id: number | string,
    /** Identifier of the user who sent the query */
    sender_user_id: number,
    /** User location; may be null */
    user_location?: location,
    /** The type of the chat from which the query originated; may be null if unknown */
    chat_type?: ChatType,
    /** Text of the query */
    query: string,
    /** Offset of the first entry to return */
    offset: string,
  }

  export type updateNewChosenInlineResult = {
    /** The user has chosen a result of an inline query; for bots only */
    _: 'updateNewChosenInlineResult',
    /** Identifier of the user who sent the query */
    sender_user_id: number,
    /** User location; may be null */
    user_location?: location,
    /** Text of the query */
    query: string,
    /** Identifier of the chosen result */
    result_id: string,
    /** Identifier of the sent inline message, if known */
    inline_message_id: string,
  }

  export type updateNewCallbackQuery = {
    /** A new incoming callback query; for bots only */
    _: 'updateNewCallbackQuery',
    /** Unique query identifier */
    id: number | string,
    /** Identifier of the user who sent the query */
    sender_user_id: number,
    /** Identifier of the chat where the query was sent */
    chat_id: number,
    /** Identifier of the message from which the query originated */
    message_id: number,
    /** Identifier that uniquely corresponds to the chat to which the message was sent */
    chat_instance: number | string,
    /** Query payload */
    payload: CallbackQueryPayload,
  }

  export type updateNewInlineCallbackQuery = {
    /** A new incoming callback query from a message sent via a bot; for bots only */
    _: 'updateNewInlineCallbackQuery',
    /** Unique query identifier */
    id: number | string,
    /** Identifier of the user who sent the query */
    sender_user_id: number,
    /** Identifier of the inline message from which the query originated */
    inline_message_id: string,
    /** An identifier uniquely corresponding to the chat a message was sent to */
    chat_instance: number | string,
    /** Query payload */
    payload: CallbackQueryPayload,
  }

  export type updateNewShippingQuery = {
    /**
     * A new incoming shipping query; for bots only. Only for invoices with flexible
     * price
     */
    _: 'updateNewShippingQuery',
    /** Unique query identifier */
    id: number | string,
    /** Identifier of the user who sent the query */
    sender_user_id: number,
    /** Invoice payload */
    invoice_payload: string,
    /** User shipping address */
    shipping_address: address,
  }

  export type updateNewPreCheckoutQuery = {
    /**
     * A new incoming pre-checkout query; for bots only. Contains full information
     * about a checkout
     */
    _: 'updateNewPreCheckoutQuery',
    /** Unique query identifier */
    id: number | string,
    /** Identifier of the user who sent the query */
    sender_user_id: number,
    /** Currency for the product price */
    currency: string,
    /** Total price for the product, in the smallest units of the currency */
    total_amount: number,
    /** Invoice payload */
    invoice_payload: string,
    /** Identifier of a shipping option chosen by the user; may be empty if not applicable */
    shipping_option_id: string,
    /** Information about the order; may be null */
    order_info?: orderInfo,
  }

  export type updateNewCustomEvent = {
    /** A new incoming event; for bots only */
    _: 'updateNewCustomEvent',
    /** A JSON-serialized event */
    event: string,
  }

  export type updateNewCustomQuery = {
    /** A new incoming query; for bots only */
    _: 'updateNewCustomQuery',
    /** The query identifier */
    id: number | string,
    /** JSON-serialized query data */
    data: string,
    /** Query timeout */
    timeout: number,
  }

  export type updatePoll = {
    /** A poll was updated; for bots only */
    _: 'updatePoll',
    /** New data about the poll */
    poll: poll,
  }

  export type updatePollAnswer = {
    /** A user changed the answer to a poll; for bots only */
    _: 'updatePollAnswer',
    /** Unique poll identifier */
    poll_id: number | string,
    /** Identifier of the message sender that changed the answer to the poll */
    voter_id: MessageSender,
    /** 0-based identifiers of answer options, chosen by the user */
    option_ids: Array<number>,
  }

  export type updateChatMember = {
    /** User rights changed in a chat; for bots only */
    _: 'updateChatMember',
    /** Chat identifier */
    chat_id: number,
    /** Identifier of the user, changing the rights */
    actor_user_id: number,
    /** Point in time (Unix timestamp) when the user rights was changed */
    date: number,
    /** If user has joined the chat using an invite link, the invite link; may be null */
    invite_link?: chatInviteLink,
    /** True, if the user has joined the chat using an invite link for a chat folder */
    via_chat_folder_invite_link: boolean,
    /** Previous chat member */
    old_chat_member: chatMember,
    /** New chat member */
    new_chat_member: chatMember,
  }

  export type updateNewChatJoinRequest = {
    /** A user sent a join request to a chat; for bots only */
    _: 'updateNewChatJoinRequest',
    /** Chat identifier */
    chat_id: number,
    /** Join request */
    request: chatJoinRequest,
    /** Chat identifier of the private chat with the user */
    user_chat_id: number,
    /** The invite link, which was used to send join request; may be null */
    invite_link?: chatInviteLink,
  }

  export type updates = {
    /** Contains a list of updates */
    _: 'updates',
    /** List of updates */
    updates: Array<Update>,
  }

  export type logStreamDefault = {
    /** The log is written to stderr or an OS specific log */
    _: 'logStreamDefault',
  }

  export type logStreamDefault$Input = {
    /** The log is written to stderr or an OS specific log */
    readonly _: 'logStreamDefault',
  }

  export type logStreamFile = {
    /** The log is written to a file */
    _: 'logStreamFile',
    /** Path to the file to where the internal TDLib log will be written */
    path: string,
    /**
     * The maximum size of the file to where the internal TDLib log is written before
     * the file will automatically be rotated, in bytes
     */
    max_file_size: number,
    /** Pass true to additionally redirect stderr to the log file. Ignored on Windows */
    redirect_stderr: boolean,
  }

  export type logStreamFile$Input = {
    /** The log is written to a file */
    readonly _: 'logStreamFile',
    /** Path to the file to where the internal TDLib log will be written */
    readonly path?: string,
    /**
     * The maximum size of the file to where the internal TDLib log is written before
     * the file will automatically be rotated, in bytes
     */
    readonly max_file_size?: number,
    /** Pass true to additionally redirect stderr to the log file. Ignored on Windows */
    readonly redirect_stderr?: boolean,
  }

  export type logStreamEmpty = {
    /** The log is written nowhere */
    _: 'logStreamEmpty',
  }

  export type logStreamEmpty$Input = {
    /** The log is written nowhere */
    readonly _: 'logStreamEmpty',
  }

  export type logVerbosityLevel = {
    /** Contains a TDLib internal log verbosity level */
    _: 'logVerbosityLevel',
    /** Log verbosity level */
    verbosity_level: number,
  }

  export type logTags = {
    /** Contains a list of available TDLib internal log tags */
    _: 'logTags',
    /** List of log tags */
    tags: Array<string>,
  }

  export type userSupportInfo = {
    /** Contains custom information about the user */
    _: 'userSupportInfo',
    /** Information message */
    message: formattedText,
    /** Information author */
    author: string,
    /** Information change date */
    date: number,
  }

  export type testInt = {
    /** A simple object containing a number; for testing only */
    _: 'testInt',
    /** Number */
    value: number,
  }

  export type testInt$Input = {
    /** A simple object containing a number; for testing only */
    readonly _: 'testInt',
    /** Number */
    readonly value?: number,
  }

  export type testString = {
    /** A simple object containing a string; for testing only */
    _: 'testString',
    /** String */
    value: string,
  }

  export type testString$Input = {
    /** A simple object containing a string; for testing only */
    readonly _: 'testString',
    /** String */
    readonly value?: string,
  }

  export type testBytes = {
    /** A simple object containing a sequence of bytes; for testing only */
    _: 'testBytes',
    /** Bytes */
    value: string,
  }

  export type testVectorInt = {
    /** A simple object containing a vector of numbers; for testing only */
    _: 'testVectorInt',
    /** Vector of numbers */
    value: Array<number>,
  }

  export type testVectorIntObject = {
    /**
     * A simple object containing a vector of objects that hold a number; for testing
     * only
     */
    _: 'testVectorIntObject',
    /** Vector of objects */
    value: Array<testInt>,
  }

  export type testVectorString = {
    /** A simple object containing a vector of strings; for testing only */
    _: 'testVectorString',
    /** Vector of strings */
    value: Array<string>,
  }

  export type testVectorStringObject = {
    /**
     * A simple object containing a vector of objects that hold a string; for testing
     * only
     */
    _: 'testVectorStringObject',
    /** Vector of objects */
    value: Array<testString>,
  }

  export type getAuthorizationState = {
    /**
     * Returns the current authorization state; this is an offline request. For informational
     * purposes only. Use updateAuthorizationState instead to maintain the current
     * authorization state. Can be called before initialization
     */
    readonly _: 'getAuthorizationState',
  }

  export type setTdlibParameters = {
    /**
     * Sets the parameters for TDLib initialization. Works only when the current authorization
     * state is authorizationStateWaitTdlibParameters
     */
    readonly _: 'setTdlibParameters',
    /** Pass true to use Telegram test environment instead of the production environment */
    readonly use_test_dc?: boolean,
    /**
     * The path to the directory for the persistent database; if empty, the current
     * working directory will be used
     */
    readonly database_directory?: string,
    /**
     * The path to the directory for storing files; if empty, database_directory will
     * be used
     */
    readonly files_directory?: string,
    /**
     * Encryption key for the database. If the encryption key is invalid, then an error
     * with code 401 will be returned
     */
    readonly database_encryption_key?: string,
    /**
     * Pass true to keep information about downloaded and uploaded files between application
     * restarts
     */
    readonly use_file_database?: boolean,
    /**
     * Pass true to keep cache of users, basic groups, supergroups, channels and secret
     * chats between restarts. Implies use_file_database
     */
    readonly use_chat_info_database?: boolean,
    /** Pass true to keep cache of chats and messages between restarts. Implies use_chat_info_database */
    readonly use_message_database?: boolean,
    /** Pass true to enable support for secret chats */
    readonly use_secret_chats?: boolean,
    /** Application identifier for Telegram API access, which can be obtained at https://my.telegram.org */
    readonly api_id?: number,
    /**
     * Application identifier hash for Telegram API access, which can be obtained at
     * https://my.telegram.org
     */
    readonly api_hash?: string,
    /** IETF language tag of the user's operating system language; must be non-empty */
    readonly system_language_code?: string,
    /** Model of the device the application is being run on; must be non-empty */
    readonly device_model?: string,
    /**
     * Version of the operating system the application is being run on. If empty, the
     * version is automatically detected by TDLib
     */
    readonly system_version?: string,
    /** Application version; must be non-empty */
    readonly application_version?: string,
    /** Pass true to automatically delete old files in background */
    readonly enable_storage_optimizer?: boolean,
    /**
     * Pass true to ignore original file names for downloaded files. Otherwise, downloaded
     * files are saved under names as close as possible to the original name
     */
    readonly ignore_file_names?: boolean,
  }

  export type setAuthenticationPhoneNumber = {
    /**
     * Sets the phone number of the user and sends an authentication code to the user.
     * Works only when the current authorization state is authorizationStateWaitPhoneNumber,
     * or if there is no pending authentication query and the current authorization
     * state is authorizationStateWaitEmailAddress, authorizationStateWaitEmailCode,
     * authorizationStateWaitCode, authorizationStateWaitRegistration, or authorizationStateWaitPassword
     */
    readonly _: 'setAuthenticationPhoneNumber',
    /** The phone number of the user, in international format */
    readonly phone_number?: string,
    /**
     * Settings for the authentication of the user's phone number; pass null to use
     * default settings
     */
    readonly settings?: phoneNumberAuthenticationSettings$Input,
  }

  export type setAuthenticationEmailAddress = {
    /**
     * Sets the email address of the user and sends an authentication code to the email
     * address. Works only when the current authorization state is authorizationStateWaitEmailAddress
     */
    readonly _: 'setAuthenticationEmailAddress',
    /** The email address of the user */
    readonly email_address?: string,
  }

  export type resendAuthenticationCode = {
    /**
     * Resends an authentication code to the user. Works only when the current authorization
     * state is authorizationStateWaitCode, the next_code_type of the result is not
     * null and the server-specified timeout has passed, or when the current authorization
     * state is authorizationStateWaitEmailCode
     */
    readonly _: 'resendAuthenticationCode',
  }

  export type checkAuthenticationEmailCode = {
    /**
     * Checks the authentication of a email address. Works only when the current authorization
     * state is authorizationStateWaitEmailCode
     */
    readonly _: 'checkAuthenticationEmailCode',
    /** Email address authentication to check */
    readonly code?: EmailAddressAuthentication$Input,
  }

  export type checkAuthenticationCode = {
    /**
     * Checks the authentication code. Works only when the current authorization state
     * is authorizationStateWaitCode
     */
    readonly _: 'checkAuthenticationCode',
    /** Authentication code to check */
    readonly code?: string,
  }

  export type requestQrCodeAuthentication = {
    /**
     * Requests QR code authentication by scanning a QR code on another logged in device.
     * Works only when the current authorization state is authorizationStateWaitPhoneNumber,
     * or if there is no pending authentication query and the current authorization
     * state is authorizationStateWaitEmailAddress, authorizationStateWaitEmailCode,
     * authorizationStateWaitCode, authorizationStateWaitRegistration, or authorizationStateWaitPassword
     */
    readonly _: 'requestQrCodeAuthentication',
    /** List of user identifiers of other users currently using the application */
    readonly other_user_ids?: ReadonlyArray<number>,
  }

  export type registerUser = {
    /**
     * Finishes user registration. Works only when the current authorization state
     * is authorizationStateWaitRegistration
     */
    readonly _: 'registerUser',
    /** The first name of the user; 1-64 characters */
    readonly first_name?: string,
    /** The last name of the user; 0-64 characters */
    readonly last_name?: string,
  }

  export type resetAuthenticationEmailAddress = {
    /**
     * Resets the login email address. May return an error with a message "TASK_ALREADY_EXISTS"
     * if reset is still pending. Works only when the current authorization state is
     * authorizationStateWaitEmailCode and authorization_state.can_reset_email_address
     * == true
     */
    readonly _: 'resetAuthenticationEmailAddress',
  }

  export type checkAuthenticationPassword = {
    /**
     * Checks the 2-step verification password for correctness. Works only when the
     * current authorization state is authorizationStateWaitPassword
     */
    readonly _: 'checkAuthenticationPassword',
    /** The 2-step verification password to check */
    readonly password?: string,
  }

  export type requestAuthenticationPasswordRecovery = {
    /**
     * Requests to send a 2-step verification password recovery code to an email address
     * that was previously set up. Works only when the current authorization state
     * is authorizationStateWaitPassword
     */
    readonly _: 'requestAuthenticationPasswordRecovery',
  }

  export type checkAuthenticationPasswordRecoveryCode = {
    /**
     * Checks whether a 2-step verification password recovery code sent to an email
     * address is valid. Works only when the current authorization state is authorizationStateWaitPassword
     */
    readonly _: 'checkAuthenticationPasswordRecoveryCode',
    /** Recovery code to check */
    readonly recovery_code?: string,
  }

  export type recoverAuthenticationPassword = {
    /**
     * Recovers the 2-step verification password with a password recovery code sent
     * to an email address that was previously set up. Works only when the current
     * authorization state is authorizationStateWaitPassword
     */
    readonly _: 'recoverAuthenticationPassword',
    /** Recovery code to check */
    readonly recovery_code?: string,
    /** New 2-step verification password of the user; may be empty to remove the password */
    readonly new_password?: string,
    /** New password hint; may be empty */
    readonly new_hint?: string,
  }

  export type sendAuthenticationFirebaseSms = {
    /**
     * Sends Firebase Authentication SMS to the phone number of the user. Works only
     * when the current authorization state is authorizationStateWaitCode and the server
     * returned code of the type authenticationCodeTypeFirebaseAndroid or authenticationCodeTypeFirebaseIos
     */
    readonly _: 'sendAuthenticationFirebaseSms',
    /**
     * SafetyNet Attestation API token for the Android application, or secret from
     * push notification for the iOS application
     */
    readonly token?: string,
  }

  export type checkAuthenticationBotToken = {
    /**
     * Checks the authentication token of a bot; to log in as a bot. Works only when
     * the current authorization state is authorizationStateWaitPhoneNumber. Can be
     * used instead of setAuthenticationPhoneNumber and checkAuthenticationCode to
     * log in
     */
    readonly _: 'checkAuthenticationBotToken',
    /** The bot token */
    readonly token?: string,
  }

  export type logOut = {
    /**
     * Closes the TDLib instance after a proper logout. Requires an available network
     * connection. All local data will be destroyed. After the logout completes, updateAuthorizationState
     * with authorizationStateClosed will be sent
     */
    readonly _: 'logOut',
  }

  export type close = {
    /**
     * Closes the TDLib instance. All databases will be flushed to disk and properly
     * closed. After the close completes, updateAuthorizationState with authorizationStateClosed
     * will be sent. Can be called before initialization
     */
    readonly _: 'close',
  }

  export type destroy = {
    /**
     * Closes the TDLib instance, destroying all local data without a proper logout.
     * The current user session will remain in the list of all active sessions. All
     * local data will be destroyed. After the destruction completes updateAuthorizationState
     * with authorizationStateClosed will be sent. Can be called before authorization
     */
    readonly _: 'destroy',
  }

  export type confirmQrCodeAuthentication = {
    /**
     * Confirms QR code authentication on another device. Returns created session on
     * success
     */
    readonly _: 'confirmQrCodeAuthentication',
    /** A link from a QR code. The link must be scanned by the in-app camera */
    readonly link?: string,
  }

  export type getCurrentState = {
    /**
     * Returns all updates needed to restore current TDLib state, i.e. all actual updateAuthorizationState/updateUser/updateNewChat
     * and others. This is especially useful if TDLib is run in a separate process.
     * Can be called before initialization
     */
    readonly _: 'getCurrentState',
  }

  export type setDatabaseEncryptionKey = {
    /**
     * Changes the database encryption key. Usually the encryption key is never changed
     * and is stored in some OS keychain
     */
    readonly _: 'setDatabaseEncryptionKey',
    /** New encryption key */
    readonly new_encryption_key?: string,
  }

  export type getPasswordState = {
    /** Returns the current state of 2-step verification */
    readonly _: 'getPasswordState',
  }

  export type setPassword = {
    /**
     * Changes the 2-step verification password for the current user. If a new recovery
     * email address is specified, then the change will not be applied until the new
     * recovery email address is confirmed
     */
    readonly _: 'setPassword',
    /** Previous 2-step verification password of the user */
    readonly old_password?: string,
    /** New 2-step verification password of the user; may be empty to remove the password */
    readonly new_password?: string,
    /** New password hint; may be empty */
    readonly new_hint?: string,
    /** Pass true to change also the recovery email address */
    readonly set_recovery_email_address?: boolean,
    /** New recovery email address; may be empty */
    readonly new_recovery_email_address?: string,
  }

  export type setLoginEmailAddress = {
    /**
     * Changes the login email address of the user. The email address can be changed
     * only if the current user already has login email and passwordState.login_email_address_pattern
     * is non-empty. The change will not be applied until the new login email address
     * is confirmed with checkLoginEmailAddressCode. To use Apple ID/Google ID instead
     * of a email address, call checkLoginEmailAddressCode directly
     */
    readonly _: 'setLoginEmailAddress',
    /** New login email address */
    readonly new_login_email_address?: string,
  }

  export type resendLoginEmailAddressCode = {
    /** Resends the login email address verification code */
    readonly _: 'resendLoginEmailAddressCode',
  }

  export type checkLoginEmailAddressCode = {
    /** Checks the login email address authentication */
    readonly _: 'checkLoginEmailAddressCode',
    /** Email address authentication to check */
    readonly code?: EmailAddressAuthentication$Input,
  }

  export type getRecoveryEmailAddress = {
    /**
     * Returns a 2-step verification recovery email address that was previously set
     * up. This method can be used to verify a password provided by the user
     */
    readonly _: 'getRecoveryEmailAddress',
    /** The 2-step verification password for the current user */
    readonly password?: string,
  }

  export type setRecoveryEmailAddress = {
    /**
     * Changes the 2-step verification recovery email address of the user. If a new
     * recovery email address is specified, then the change will not be applied until
     * the new recovery email address is confirmed. If new_recovery_email_address is
     * the same as the email address that is currently set up, this call succeeds immediately
     * and aborts all other requests waiting for an email confirmation
     */
    readonly _: 'setRecoveryEmailAddress',
    /** The 2-step verification password of the current user */
    readonly password?: string,
    /** New recovery email address */
    readonly new_recovery_email_address?: string,
  }

  export type checkRecoveryEmailAddressCode = {
    /** Checks the 2-step verification recovery email address verification code */
    readonly _: 'checkRecoveryEmailAddressCode',
    /** Verification code to check */
    readonly code?: string,
  }

  export type resendRecoveryEmailAddressCode = {
    /** Resends the 2-step verification recovery email address verification code */
    readonly _: 'resendRecoveryEmailAddressCode',
  }

  export type requestPasswordRecovery = {
    /**
     * Requests to send a 2-step verification password recovery code to an email address
     * that was previously set up
     */
    readonly _: 'requestPasswordRecovery',
  }

  export type checkPasswordRecoveryCode = {
    /**
     * Checks whether a 2-step verification password recovery code sent to an email
     * address is valid
     */
    readonly _: 'checkPasswordRecoveryCode',
    /** Recovery code to check */
    readonly recovery_code?: string,
  }

  export type recoverPassword = {
    /**
     * Recovers the 2-step verification password using a recovery code sent to an email
     * address that was previously set up
     */
    readonly _: 'recoverPassword',
    /** Recovery code to check */
    readonly recovery_code?: string,
    /** New 2-step verification password of the user; may be empty to remove the password */
    readonly new_password?: string,
    /** New password hint; may be empty */
    readonly new_hint?: string,
  }

  export type resetPassword = {
    /**
     * Removes 2-step verification password without previous password and access to
     * recovery email address. The password can't be reset immediately and the request
     * needs to be repeated after the specified time
     */
    readonly _: 'resetPassword',
  }

  export type cancelPasswordReset = {
    /**
     * Cancels reset of 2-step verification password. The method can be called if passwordState.pending_reset_date
     * > 0
     */
    readonly _: 'cancelPasswordReset',
  }

  export type createTemporaryPassword = {
    /** Creates a new temporary password for processing payments */
    readonly _: 'createTemporaryPassword',
    /** The 2-step verification password of the current user */
    readonly password?: string,
    /**
     * Time during which the temporary password will be valid, in seconds; must be
     * between 60 and 86400
     */
    readonly valid_for?: number,
  }

  export type getTemporaryPasswordState = {
    /** Returns information about the current temporary password */
    readonly _: 'getTemporaryPasswordState',
  }

  export type getMe = {
    /** Returns the current user */
    readonly _: 'getMe',
  }

  export type getUser = {
    /**
     * Returns information about a user by their identifier. This is an offline request
     * if the current user is not a bot
     */
    readonly _: 'getUser',
    /** User identifier */
    readonly user_id?: number,
  }

  export type getUserFullInfo = {
    /** Returns full information about a user by their identifier */
    readonly _: 'getUserFullInfo',
    /** User identifier */
    readonly user_id?: number,
  }

  export type getBasicGroup = {
    /**
     * Returns information about a basic group by its identifier. This is an offline
     * request if the current user is not a bot
     */
    readonly _: 'getBasicGroup',
    /** Basic group identifier */
    readonly basic_group_id?: number,
  }

  export type getBasicGroupFullInfo = {
    /** Returns full information about a basic group by its identifier */
    readonly _: 'getBasicGroupFullInfo',
    /** Basic group identifier */
    readonly basic_group_id?: number,
  }

  export type getSupergroup = {
    /**
     * Returns information about a supergroup or a channel by its identifier. This
     * is an offline request if the current user is not a bot
     */
    readonly _: 'getSupergroup',
    /** Supergroup or channel identifier */
    readonly supergroup_id?: number,
  }

  export type getSupergroupFullInfo = {
    /**
     * Returns full information about a supergroup or a channel by its identifier,
     * cached for up to 1 minute
     */
    readonly _: 'getSupergroupFullInfo',
    /** Supergroup or channel identifier */
    readonly supergroup_id?: number,
  }

  export type getSecretChat = {
    /**
     * Returns information about a secret chat by its identifier. This is an offline
     * request
     */
    readonly _: 'getSecretChat',
    /** Secret chat identifier */
    readonly secret_chat_id?: number,
  }

  export type getChat = {
    /**
     * Returns information about a chat by its identifier; this is an offline request
     * if the current user is not a bot
     */
    readonly _: 'getChat',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type getMessage = {
    /** Returns information about a message */
    readonly _: 'getMessage',
    /** Identifier of the chat the message belongs to */
    readonly chat_id?: number,
    /** Identifier of the message to get */
    readonly message_id?: number,
  }

  export type getMessageLocally = {
    /**
     * Returns information about a message, if it is available without sending network
     * request. This is an offline request
     */
    readonly _: 'getMessageLocally',
    /** Identifier of the chat the message belongs to */
    readonly chat_id?: number,
    /** Identifier of the message to get */
    readonly message_id?: number,
  }

  export type getRepliedMessage = {
    /**
     * Returns information about a message that is replied by a given message. Also,
     * returns the pinned message, the game message, the invoice message, and the topic
     * creation message for messages of the types messagePinMessage, messageGameScore,
     * messagePaymentSuccessful, messageChatSetBackground and topic messages without
     * replied message respectively
     */
    readonly _: 'getRepliedMessage',
    /** Identifier of the chat the message belongs to */
    readonly chat_id?: number,
    /** Identifier of the reply message */
    readonly message_id?: number,
  }

  export type getChatPinnedMessage = {
    /** Returns information about a newest pinned message in the chat */
    readonly _: 'getChatPinnedMessage',
    /** Identifier of the chat the message belongs to */
    readonly chat_id?: number,
  }

  export type getCallbackQueryMessage = {
    /**
     * Returns information about a message with the callback button that originated
     * a callback query; for bots only
     */
    readonly _: 'getCallbackQueryMessage',
    /** Identifier of the chat the message belongs to */
    readonly chat_id?: number,
    /** Message identifier */
    readonly message_id?: number,
    /** Identifier of the callback query */
    readonly callback_query_id?: number | string,
  }

  export type getMessages = {
    /**
     * Returns information about messages. If a message is not found, returns null
     * on the corresponding position of the result
     */
    readonly _: 'getMessages',
    /** Identifier of the chat the messages belong to */
    readonly chat_id?: number,
    /** Identifiers of the messages to get */
    readonly message_ids?: ReadonlyArray<number>,
  }

  export type getMessageThread = {
    /**
     * Returns information about a message thread. Can be used only if message.can_get_message_thread
     * == true
     */
    readonly _: 'getMessageThread',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
  }

  export type getMessageViewers = {
    /**
     * Returns viewers of a recent outgoing message in a basic group or a supergroup
     * chat. For video notes and voice notes only users, opened content of the message,
     * are returned. The method can be called if message.can_get_viewers == true
     */
    readonly _: 'getMessageViewers',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
  }

  export type getFile = {
    /** Returns information about a file; this is an offline request */
    readonly _: 'getFile',
    /** Identifier of the file to get */
    readonly file_id?: number,
  }

  export type getRemoteFile = {
    /**
     * Returns information about a file by its remote identifier; this is an offline
     * request. Can be used to register a URL as a file for further uploading, or sending
     * as a message. Even the request succeeds, the file can be used only if it is
     * still accessible to the user. For example, if the file is from a message, then
     * the message must be not deleted and accessible to the user. If the file database
     * is disabled, then the corresponding object with the file must be preloaded by
     * the application
     */
    readonly _: 'getRemoteFile',
    /** Remote identifier of the file to get */
    readonly remote_file_id?: string,
    /** File type; pass null if unknown */
    readonly file_type?: FileType$Input,
  }

  export type loadChats = {
    /**
     * Loads more chats from a chat list. The loaded chats and their positions in the
     * chat list will be sent through updates. Chats are sorted by the pair (chat.position.order,
     * chat.id) in descending order. Returns a 404 error if all chats have been loaded
     */
    readonly _: 'loadChats',
    /**
     * The chat list in which to load chats; pass null to load chats from the main
     * chat list
     */
    readonly chat_list?: ChatList$Input,
    /**
     * The maximum number of chats to be loaded. For optimal performance, the number
     * of loaded chats is chosen by TDLib and can be smaller than the specified limit,
     * even if the end of the list is not reached
     */
    readonly limit?: number,
  }

  export type getChats = {
    /**
     * Returns an ordered list of chats from the beginning of a chat list. For informational
     * purposes only. Use loadChats and updates processing instead to maintain chat
     * lists in a consistent state
     */
    readonly _: 'getChats',
    /**
     * The chat list in which to return chats; pass null to get chats from the main
     * chat list
     */
    readonly chat_list?: ChatList$Input,
    /** The maximum number of chats to be returned */
    readonly limit?: number,
  }

  export type searchPublicChat = {
    /**
     * Searches a public chat by its username. Currently, only private chats, supergroups
     * and channels can be public. Returns the chat if found; otherwise, an error is
     * returned
     */
    readonly _: 'searchPublicChat',
    /** Username to be resolved */
    readonly username?: string,
  }

  export type searchPublicChats = {
    /**
     * Searches public chats by looking for specified query in their username and title.
     * Currently, only private chats, supergroups and channels can be public. Returns
     * a meaningful number of results. Excludes private chats with contacts and chats
     * from the chat list from the results
     */
    readonly _: 'searchPublicChats',
    /** Query to search for */
    readonly query?: string,
  }

  export type searchChats = {
    /**
     * Searches for the specified query in the title and username of already known
     * chats; this is an offline request. Returns chats in the order seen in the main
     * chat list
     */
    readonly _: 'searchChats',
    /**
     * Query to search for. If the query is empty, returns up to 50 recently found
     * chats
     */
    readonly query?: string,
    /** The maximum number of chats to be returned */
    readonly limit?: number,
  }

  export type searchChatsOnServer = {
    /**
     * Searches for the specified query in the title and username of already known
     * chats via request to the server. Returns chats in the order seen in the main
     * chat list
     */
    readonly _: 'searchChatsOnServer',
    /** Query to search for */
    readonly query?: string,
    /** The maximum number of chats to be returned */
    readonly limit?: number,
  }

  export type searchChatsNearby = {
    /**
     * Returns a list of users and location-based supergroups nearby. The list of users
     * nearby will be updated for 60 seconds after the request by the updates updateUsersNearby.
     * The request must be sent again every 25 seconds with adjusted location to not
     * miss new chats
     */
    readonly _: 'searchChatsNearby',
    /** Current user location */
    readonly location?: location$Input,
  }

  export type getTopChats = {
    /** Returns a list of frequently used chats */
    readonly _: 'getTopChats',
    /** Category of chats to be returned */
    readonly category?: TopChatCategory$Input,
    /** The maximum number of chats to be returned; up to 30 */
    readonly limit?: number,
  }

  export type removeTopChat = {
    /**
     * Removes a chat from the list of frequently used chats. Supported only if the
     * chat info database is enabled
     */
    readonly _: 'removeTopChat',
    /** Category of frequently used chats */
    readonly category?: TopChatCategory$Input,
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type searchRecentlyFoundChats = {
    /**
     * Searches for the specified query in the title and username of up to 50 recently
     * found chats; this is an offline request
     */
    readonly _: 'searchRecentlyFoundChats',
    /** Query to search for */
    readonly query?: string,
    /** The maximum number of chats to be returned */
    readonly limit?: number,
  }

  export type addRecentlyFoundChat = {
    /**
     * Adds a chat to the list of recently found chats. The chat is added to the beginning
     * of the list. If the chat is already in the list, it will be removed from the
     * list first
     */
    readonly _: 'addRecentlyFoundChat',
    /** Identifier of the chat to add */
    readonly chat_id?: number,
  }

  export type removeRecentlyFoundChat = {
    /** Removes a chat from the list of recently found chats */
    readonly _: 'removeRecentlyFoundChat',
    /** Identifier of the chat to be removed */
    readonly chat_id?: number,
  }

  export type clearRecentlyFoundChats = {
    /** Clears the list of recently found chats */
    readonly _: 'clearRecentlyFoundChats',
  }

  export type getRecentlyOpenedChats = {
    /**
     * Returns recently opened chats; this is an offline request. Returns chats in
     * the order of last opening
     */
    readonly _: 'getRecentlyOpenedChats',
    /** The maximum number of chats to be returned */
    readonly limit?: number,
  }

  export type checkChatUsername = {
    /** Checks whether a username can be set for a chat */
    readonly _: 'checkChatUsername',
    /**
     * Chat identifier; must be identifier of a supergroup chat, or a channel chat,
     * or a private chat with self, or 0 if the chat is being created
     */
    readonly chat_id?: number,
    /** Username to be checked */
    readonly username?: string,
  }

  export type getCreatedPublicChats = {
    /** Returns a list of public chats of the specified type, owned by the user */
    readonly _: 'getCreatedPublicChats',
    /** Type of the public chats to return */
    readonly type?: PublicChatType$Input,
  }

  export type checkCreatedPublicChatsLimit = {
    /**
     * Checks whether the maximum number of owned public chats has been reached. Returns
     * corresponding error if the limit was reached. The limit can be increased with
     * Telegram Premium
     */
    readonly _: 'checkCreatedPublicChatsLimit',
    /** Type of the public chats, for which to check the limit */
    readonly type?: PublicChatType$Input,
  }

  export type getSuitableDiscussionChats = {
    /**
     * Returns a list of basic group and supergroup chats, which can be used as a discussion
     * group for a channel. Returned basic group chats must be first upgraded to supergroups
     * before they can be set as a discussion group. To set a returned supergroup as
     * a discussion group, access to its old messages must be enabled using toggleSupergroupIsAllHistoryAvailable
     * first
     */
    readonly _: 'getSuitableDiscussionChats',
  }

  export type getInactiveSupergroupChats = {
    /**
     * Returns a list of recently inactive supergroups and channels. Can be used when
     * user reaches limit on the number of joined supergroups and channels and receives
     * CHANNELS_TOO_MUCH error. Also, the limit can be increased with Telegram Premium
     */
    readonly _: 'getInactiveSupergroupChats',
  }

  export type getGroupsInCommon = {
    /**
     * Returns a list of common group chats with a given user. Chats are sorted by
     * their type and creation date
     */
    readonly _: 'getGroupsInCommon',
    /** User identifier */
    readonly user_id?: number,
    /** Chat identifier starting from which to return chats; use 0 for the first request */
    readonly offset_chat_id?: number,
    /** The maximum number of chats to be returned; up to 100 */
    readonly limit?: number,
  }

  export type getChatHistory = {
    /**
     * Returns messages in a chat. The messages are returned in a reverse chronological
     * order (i.e., in order of decreasing message_id). For optimal performance, the
     * number of returned messages is chosen by TDLib. This is an offline request if
     * only_local is true
     */
    readonly _: 'getChatHistory',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * Identifier of the message starting from which history must be fetched; use 0
     * to get results from the last message
     */
    readonly from_message_id?: number,
    /**
     * Specify 0 to get results from exactly the from_message_id or a negative offset
     * up to 99 to get additionally some newer messages
     */
    readonly offset?: number,
    /**
     * The maximum number of messages to be returned; must be positive and can't be
     * greater than 100. If the offset is negative, the limit must be greater than
     * or equal to -offset. For optimal performance, the number of returned messages
     * is chosen by TDLib and can be smaller than the specified limit
     */
    readonly limit?: number,
    /** Pass true to get only messages that are available without sending network requests */
    readonly only_local?: boolean,
  }

  export type getMessageThreadHistory = {
    /**
     * Returns messages in a message thread of a message. Can be used only if message.can_get_message_thread
     * == true. Message thread of a channel message is in the channel's linked supergroup.
     * The messages are returned in a reverse chronological order (i.e., in order of
     * decreasing message_id). For optimal performance, the number of returned messages
     * is chosen by TDLib
     */
    readonly _: 'getMessageThreadHistory',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Message identifier, which thread history needs to be returned */
    readonly message_id?: number,
    /**
     * Identifier of the message starting from which history must be fetched; use 0
     * to get results from the last message
     */
    readonly from_message_id?: number,
    /**
     * Specify 0 to get results from exactly the from_message_id or a negative offset
     * up to 99 to get additionally some newer messages
     */
    readonly offset?: number,
    /**
     * The maximum number of messages to be returned; must be positive and can't be
     * greater than 100. If the offset is negative, the limit must be greater than
     * or equal to -offset. For optimal performance, the number of returned messages
     * is chosen by TDLib and can be smaller than the specified limit
     */
    readonly limit?: number,
  }

  export type deleteChatHistory = {
    /**
     * Deletes all messages in the chat. Use chat.can_be_deleted_only_for_self and
     * chat.can_be_deleted_for_all_users fields to find whether and how the method
     * can be applied to the chat
     */
    readonly _: 'deleteChatHistory',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Pass true to remove the chat from all chat lists */
    readonly remove_from_chat_list?: boolean,
    /** Pass true to delete chat history for all users */
    readonly revoke?: boolean,
  }

  export type deleteChat = {
    /**
     * Deletes a chat along with all messages in the corresponding chat for all chat
     * members. For group chats this will release the usernames and remove all members.
     * Use the field chat.can_be_deleted_for_all_users to find whether the method can
     * be applied to the chat
     */
    readonly _: 'deleteChat',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type searchChatMessages = {
    /**
     * Searches for messages with given words in the chat. Returns the results in reverse
     * chronological order, i.e. in order of decreasing message_id. Cannot be used
     * in secret chats with a non-empty query (searchSecretMessages must be used instead),
     * or without an enabled message database. For optimal performance, the number
     * of returned messages is chosen by TDLib and can be smaller than the specified
     * limit. A combination of query, sender_id, filter and message_thread_id search
     * criteria is expected to be supported, only if it is required for Telegram official
     * application implementation
     */
    readonly _: 'searchChatMessages',
    /** Identifier of the chat in which to search messages */
    readonly chat_id?: number,
    /** Query to search for */
    readonly query?: string,
    /**
     * Identifier of the sender of messages to search for; pass null to search for
     * messages from any sender. Not supported in secret chats
     */
    readonly sender_id?: MessageSender$Input,
    /**
     * Identifier of the message starting from which history must be fetched; use 0
     * to get results from the last message
     */
    readonly from_message_id?: number,
    /**
     * Specify 0 to get results from exactly the from_message_id or a negative offset
     * to get the specified message and some newer messages
     */
    readonly offset?: number,
    /**
     * The maximum number of messages to be returned; must be positive and can't be
     * greater than 100. If the offset is negative, the limit must be greater than
     * -offset. For optimal performance, the number of returned messages is chosen
     * by TDLib and can be smaller than the specified limit
     */
    readonly limit?: number,
    /** Additional filter for messages to search; pass null to search for all messages */
    readonly filter?: SearchMessagesFilter$Input,
    /**
     * If not 0, only messages in the specified thread will be returned; supergroups
     * only
     */
    readonly message_thread_id?: number,
  }

  export type searchMessages = {
    /**
     * Searches for messages in all chats except secret chats. Returns the results
     * in reverse chronological order (i.e., in order of decreasing (date, chat_id,
     * message_id)). For optimal performance, the number of returned messages is chosen
     * by TDLib and can be smaller than the specified limit
     */
    readonly _: 'searchMessages',
    /**
     * Chat list in which to search messages; pass null to search in all chats regardless
     * of their chat list. Only Main and Archive chat lists are supported
     */
    readonly chat_list?: ChatList$Input,
    /** Query to search for */
    readonly query?: string,
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    readonly offset?: string,
    /**
     * The maximum number of messages to be returned; up to 100. For optimal performance,
     * the number of returned messages is chosen by TDLib and can be smaller than the
     * specified limit
     */
    readonly limit?: number,
    /**
     * Additional filter for messages to search; pass null to search for all messages.
     * Filters searchMessagesFilterMention, searchMessagesFilterUnreadMention, searchMessagesFilterUnreadReaction,
     * searchMessagesFilterFailedToSend, and searchMessagesFilterPinned are unsupported
     * in this function
     */
    readonly filter?: SearchMessagesFilter$Input,
    /** If not 0, the minimum date of the messages to return */
    readonly min_date?: number,
    /** If not 0, the maximum date of the messages to return */
    readonly max_date?: number,
  }

  export type searchSecretMessages = {
    /**
     * Searches for messages in secret chats. Returns the results in reverse chronological
     * order. For optimal performance, the number of returned messages is chosen by
     * TDLib
     */
    readonly _: 'searchSecretMessages',
    /**
     * Identifier of the chat in which to search. Specify 0 to search in all secret
     * chats
     */
    readonly chat_id?: number,
    /** Query to search for. If empty, searchChatMessages must be used instead */
    readonly query?: string,
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    readonly offset?: string,
    /**
     * The maximum number of messages to be returned; up to 100. For optimal performance,
     * the number of returned messages is chosen by TDLib and can be smaller than the
     * specified limit
     */
    readonly limit?: number,
    /** Additional filter for messages to search; pass null to search for all messages */
    readonly filter?: SearchMessagesFilter$Input,
  }

  export type searchCallMessages = {
    /**
     * Searches for call messages. Returns the results in reverse chronological order
     * (i.e., in order of decreasing message_id). For optimal performance, the number
     * of returned messages is chosen by TDLib
     */
    readonly _: 'searchCallMessages',
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    readonly offset?: string,
    /**
     * The maximum number of messages to be returned; up to 100. For optimal performance,
     * the number of returned messages is chosen by TDLib and can be smaller than the
     * specified limit
     */
    readonly limit?: number,
    /** Pass true to search only for messages with missed/declined calls */
    readonly only_missed?: boolean,
  }

  export type searchOutgoingDocumentMessages = {
    /**
     * Searches for outgoing messages with content of the type messageDocument in all
     * chats except secret chats. Returns the results in reverse chronological order
     */
    readonly _: 'searchOutgoingDocumentMessages',
    /** Query to search for in document file name and message caption */
    readonly query?: string,
    /** The maximum number of messages to be returned; up to 100 */
    readonly limit?: number,
  }

  export type deleteAllCallMessages = {
    /** Deletes all call messages */
    readonly _: 'deleteAllCallMessages',
    /** Pass true to delete the messages for all users */
    readonly revoke?: boolean,
  }

  export type searchChatRecentLocationMessages = {
    /**
     * Returns information about the recent locations of chat members that were sent
     * to the chat. Returns up to 1 location message per user
     */
    readonly _: 'searchChatRecentLocationMessages',
    /** Chat identifier */
    readonly chat_id?: number,
    /** The maximum number of messages to be returned */
    readonly limit?: number,
  }

  export type getActiveLiveLocationMessages = {
    /**
     * Returns all active live locations that need to be updated by the application.
     * The list is persistent across application restarts only if the message database
     * is used
     */
    readonly _: 'getActiveLiveLocationMessages',
  }

  export type getChatMessageByDate = {
    /** Returns the last message sent in a chat no later than the specified date */
    readonly _: 'getChatMessageByDate',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Point in time (Unix timestamp) relative to which to search for messages */
    readonly date?: number,
  }

  export type getChatSparseMessagePositions = {
    /**
     * Returns sparse positions of messages of the specified type in the chat to be
     * used for shared media scroll implementation. Returns the results in reverse
     * chronological order (i.e., in order of decreasing message_id). Cannot be used
     * in secret chats or with searchMessagesFilterFailedToSend filter without an enabled
     * message database
     */
    readonly _: 'getChatSparseMessagePositions',
    /** Identifier of the chat in which to return information about message positions */
    readonly chat_id?: number,
    /**
     * Filter for message content. Filters searchMessagesFilterEmpty, searchMessagesFilterMention,
     * searchMessagesFilterUnreadMention, and searchMessagesFilterUnreadReaction are
     * unsupported in this function
     */
    readonly filter?: SearchMessagesFilter$Input,
    /** The message identifier from which to return information about message positions */
    readonly from_message_id?: number,
    /**
     * The expected number of message positions to be returned; 50-2000. A smaller
     * number of positions can be returned, if there are not enough appropriate messages
     */
    readonly limit?: number,
  }

  export type getChatMessageCalendar = {
    /**
     * Returns information about the next messages of the specified type in the chat
     * split by days. Returns the results in reverse chronological order. Can return
     * partial result for the last returned day. Behavior of this method depends on
     * the value of the option "utc_time_offset"
     */
    readonly _: 'getChatMessageCalendar',
    /** Identifier of the chat in which to return information about messages */
    readonly chat_id?: number,
    /**
     * Filter for message content. Filters searchMessagesFilterEmpty, searchMessagesFilterMention,
     * searchMessagesFilterUnreadMention, and searchMessagesFilterUnreadReaction are
     * unsupported in this function
     */
    readonly filter?: SearchMessagesFilter$Input,
    /**
     * The message identifier from which to return information about messages; use
     * 0 to get results from the last message
     */
    readonly from_message_id?: number,
  }

  export type getChatMessageCount = {
    /** Returns approximate number of messages of the specified type in the chat */
    readonly _: 'getChatMessageCount',
    /** Identifier of the chat in which to count messages */
    readonly chat_id?: number,
    /**
     * Filter for message content; searchMessagesFilterEmpty is unsupported in this
     * function
     */
    readonly filter?: SearchMessagesFilter$Input,
    /**
     * Pass true to get the number of messages without sending network requests, or
     * -1 if the number of messages is unknown locally
     */
    readonly return_local?: boolean,
  }

  export type getChatMessagePosition = {
    /**
     * Returns approximate 1-based position of a message among messages, which can
     * be found by the specified filter in the chat. Cannot be used in secret chats
     */
    readonly _: 'getChatMessagePosition',
    /** Identifier of the chat in which to find message position */
    readonly chat_id?: number,
    /** Message identifier */
    readonly message_id?: number,
    /**
     * Filter for message content; searchMessagesFilterEmpty, searchMessagesFilterUnreadMention,
     * searchMessagesFilterUnreadReaction, and searchMessagesFilterFailedToSend are
     * unsupported in this function
     */
    readonly filter?: SearchMessagesFilter$Input,
    /**
     * If not 0, only messages in the specified thread will be considered; supergroups
     * only
     */
    readonly message_thread_id?: number,
  }

  export type getChatScheduledMessages = {
    /**
     * Returns all scheduled messages in a chat. The messages are returned in a reverse
     * chronological order (i.e., in order of decreasing message_id)
     */
    readonly _: 'getChatScheduledMessages',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type getMessagePublicForwards = {
    /**
     * Returns forwarded copies of a channel message to different public channels.
     * For optimal performance, the number of returned messages is chosen by TDLib
     */
    readonly _: 'getMessagePublicForwards',
    /** Chat identifier of the message */
    readonly chat_id?: number,
    /** Message identifier */
    readonly message_id?: number,
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    readonly offset?: string,
    /**
     * The maximum number of messages to be returned; must be positive and can't be
     * greater than 100. For optimal performance, the number of returned messages is
     * chosen by TDLib and can be smaller than the specified limit
     */
    readonly limit?: number,
  }

  export type getChatSponsoredMessages = {
    /** Returns sponsored messages to be shown in a chat; for channel chats only */
    readonly _: 'getChatSponsoredMessages',
    /** Identifier of the chat */
    readonly chat_id?: number,
  }

  export type clickChatSponsoredMessage = {
    /**
     * Informs TDLib that the user opened the sponsored chat via the button, the name,
     * the photo, or a mention in the sponsored message
     */
    readonly _: 'clickChatSponsoredMessage',
    /** Chat identifier of the sponsored message */
    readonly chat_id?: number,
    /** Identifier of the sponsored message */
    readonly message_id?: number,
  }

  export type removeNotification = {
    /**
     * Removes an active notification from notification list. Needs to be called only
     * if the notification is removed by the current user
     */
    readonly _: 'removeNotification',
    /** Identifier of notification group to which the notification belongs */
    readonly notification_group_id?: number,
    /** Identifier of removed notification */
    readonly notification_id?: number,
  }

  export type removeNotificationGroup = {
    /**
     * Removes a group of active notifications. Needs to be called only if the notification
     * group is removed by the current user
     */
    readonly _: 'removeNotificationGroup',
    /** Notification group identifier */
    readonly notification_group_id?: number,
    /** The maximum identifier of removed notifications */
    readonly max_notification_id?: number,
  }

  export type getMessageLink = {
    /**
     * Returns an HTTPS link to a message in a chat. Available only for already sent
     * messages in supergroups and channels, or if message.can_get_media_timestamp_links
     * and a media timestamp link is generated. This is an offline request
     */
    readonly _: 'getMessageLink',
    /** Identifier of the chat to which the message belongs */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /**
     * If not 0, timestamp from which the video/audio/video note/voice note playing
     * must start, in seconds. The media can be in the message content or in its web
     * page preview
     */
    readonly media_timestamp?: number,
    /** Pass true to create a link for the whole media album */
    readonly for_album?: boolean,
    /**
     * Pass true to create a link to the message as a channel post comment, in a message
     * thread, or a forum topic
     */
    readonly in_message_thread?: boolean,
  }

  export type getMessageEmbeddingCode = {
    /**
     * Returns an HTML code for embedding the message. Available only for messages
     * in supergroups and channels with a username
     */
    readonly _: 'getMessageEmbeddingCode',
    /** Identifier of the chat to which the message belongs */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** Pass true to return an HTML code for embedding of the whole media album */
    readonly for_album?: boolean,
  }

  export type getMessageLinkInfo = {
    /**
     * Returns information about a public or private message link. Can be called for
     * any internal link of the type internalLinkTypeMessage
     */
    readonly _: 'getMessageLinkInfo',
    /** The message link */
    readonly url?: string,
  }

  export type translateText = {
    /**
     * Translates a text to the given language. If the current user is a Telegram Premium
     * user, then text formatting is preserved
     */
    readonly _: 'translateText',
    /** Text to translate */
    readonly text?: formattedText$Input,
    /**
     * Language code of the language to which the message is translated. Must be one
     * of "af", "sq", "am", "ar", "hy", "az", "eu", "be", "bn", "bs", "bg", "ca", "ceb",
     * "zh-CN", "zh", "zh-Hans", "zh-TW", "zh-Hant", "co", "hr", "cs", "da", "nl",
     * "en", "eo", "et", "fi", "fr", "fy", "gl", "ka", "de", "el", "gu", "ht", "ha",
     * "haw", "he", "iw", "hi", "hmn", "hu", "is", "ig", "id", "in", "ga", "it", "ja",
     * "jv", "kn", "kk", "km", "rw", "ko", "ku", "ky", "lo", "la", "lv", "lt", "lb",
     * "mk", "mg", "ms", "ml", "mt", "mi", "mr", "mn", "my", "ne", "no", "ny", "or",
     * "ps", "fa", "pl", "pt", "pa", "ro", "ru", "sm", "gd", "sr", "st", "sn", "sd",
     * "si", "sk", "sl", "so", "es", "su", "sw", "sv", "tl", "tg", "ta", "tt", "te",
     * "th", "tr", "tk", "uk", "ur", "ug", "uz", "vi", "cy", "xh", "yi", "ji", "yo",
     * "zu"
     */
    readonly to_language_code?: string,
  }

  export type translateMessageText = {
    /**
     * Extracts text or caption of the given message and translates it to the given
     * language. If the current user is a Telegram Premium user, then text formatting
     * is preserved
     */
    readonly _: 'translateMessageText',
    /** Identifier of the chat to which the message belongs */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /**
     * Language code of the language to which the message is translated. Must be one
     * of "af", "sq", "am", "ar", "hy", "az", "eu", "be", "bn", "bs", "bg", "ca", "ceb",
     * "zh-CN", "zh", "zh-Hans", "zh-TW", "zh-Hant", "co", "hr", "cs", "da", "nl",
     * "en", "eo", "et", "fi", "fr", "fy", "gl", "ka", "de", "el", "gu", "ht", "ha",
     * "haw", "he", "iw", "hi", "hmn", "hu", "is", "ig", "id", "in", "ga", "it", "ja",
     * "jv", "kn", "kk", "km", "rw", "ko", "ku", "ky", "lo", "la", "lv", "lt", "lb",
     * "mk", "mg", "ms", "ml", "mt", "mi", "mr", "mn", "my", "ne", "no", "ny", "or",
     * "ps", "fa", "pl", "pt", "pa", "ro", "ru", "sm", "gd", "sr", "st", "sn", "sd",
     * "si", "sk", "sl", "so", "es", "su", "sw", "sv", "tl", "tg", "ta", "tt", "te",
     * "th", "tr", "tk", "uk", "ur", "ug", "uz", "vi", "cy", "xh", "yi", "ji", "yo",
     * "zu"
     */
    readonly to_language_code?: string,
  }

  export type recognizeSpeech = {
    /**
     * Recognizes speech in a video note or a voice note message. The message must
     * be successfully sent and must not be scheduled. May return an error with a message
     * "MSG_VOICE_TOO_LONG" if media duration is too big to be recognized
     */
    readonly _: 'recognizeSpeech',
    /** Identifier of the chat to which the message belongs */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
  }

  export type rateSpeechRecognition = {
    /** Rates recognized speech in a video note or a voice note message */
    readonly _: 'rateSpeechRecognition',
    /** Identifier of the chat to which the message belongs */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** Pass true if the speech recognition is good */
    readonly is_good?: boolean,
  }

  export type getChatAvailableMessageSenders = {
    /**
     * Returns list of message sender identifiers, which can be used to send messages
     * in a chat
     */
    readonly _: 'getChatAvailableMessageSenders',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type setChatMessageSender = {
    /** Selects a message sender to send messages in a chat */
    readonly _: 'setChatMessageSender',
    /** Chat identifier */
    readonly chat_id?: number,
    /** New message sender for the chat */
    readonly message_sender_id?: MessageSender$Input,
  }

  export type sendMessage = {
    /** Sends a message. Returns the sent message */
    readonly _: 'sendMessage',
    /** Target chat */
    readonly chat_id?: number,
    /** If not 0, a message thread identifier in which the message will be sent */
    readonly message_thread_id?: number,
    /** Identifier of the replied message or story; pass null if none */
    readonly reply_to?: MessageReplyTo$Input,
    /** Options to be used to send the message; pass null to use default options */
    readonly options?: messageSendOptions$Input,
    /** Markup for replying to the message; pass null if none; for bots only */
    readonly reply_markup?: ReplyMarkup$Input,
    /** The content of the message to be sent */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type sendMessageAlbum = {
    /**
     * Sends 2-10 messages grouped together into an album. Currently, only audio, document,
     * photo and video messages can be grouped into an album. Documents and audio files
     * can be only grouped in an album with messages of the same type. Returns sent
     * messages
     */
    readonly _: 'sendMessageAlbum',
    /** Target chat */
    readonly chat_id?: number,
    /** If not 0, a message thread identifier in which the messages will be sent */
    readonly message_thread_id?: number,
    /** Identifier of the replied message or story; pass null if none */
    readonly reply_to?: MessageReplyTo$Input,
    /** Options to be used to send the messages; pass null to use default options */
    readonly options?: messageSendOptions$Input,
    /** Contents of messages to be sent. At most 10 messages can be added to an album */
    readonly input_message_contents?: ReadonlyArray<InputMessageContent$Input>,
    /** Pass true to get fake messages instead of actually sending them */
    readonly only_preview?: boolean,
  }

  export type sendBotStartMessage = {
    /**
     * Invites a bot to a chat (if it is not yet a member) and sends it the /start
     * command. Bots can't be invited to a private chat other than the chat with the
     * bot. Bots can't be invited to channels (although they can be added as admins)
     * and secret chats. Returns the sent message
     */
    readonly _: 'sendBotStartMessage',
    /** Identifier of the bot */
    readonly bot_user_id?: number,
    /** Identifier of the target chat */
    readonly chat_id?: number,
    /** A hidden parameter sent to the bot for deep linking purposes (https://core.telegram.org/bots#deep-linking) */
    readonly parameter?: string,
  }

  export type sendInlineQueryResultMessage = {
    /**
     * Sends the result of an inline query as a message. Returns the sent message.
     * Always clears a chat draft message
     */
    readonly _: 'sendInlineQueryResultMessage',
    /** Target chat */
    readonly chat_id?: number,
    /** If not 0, a message thread identifier in which the message will be sent */
    readonly message_thread_id?: number,
    /** Identifier of the replied message or story; pass null if none */
    readonly reply_to?: MessageReplyTo$Input,
    /** Options to be used to send the message; pass null to use default options */
    readonly options?: messageSendOptions$Input,
    /** Identifier of the inline query */
    readonly query_id?: number | string,
    /** Identifier of the inline query result */
    readonly result_id?: string,
    /**
     * Pass true to hide the bot, via which the message is sent. Can be used only for
     * bots getOption("animation_search_bot_username"), getOption("photo_search_bot_username"),
     * and getOption("venue_search_bot_username")
     */
    readonly hide_via_bot?: boolean,
  }

  export type forwardMessages = {
    /**
     * Forwards previously sent messages. Returns the forwarded messages in the same
     * order as the message identifiers passed in message_ids. If a message can't be
     * forwarded, null will be returned instead of the message
     */
    readonly _: 'forwardMessages',
    /** Identifier of the chat to which to forward messages */
    readonly chat_id?: number,
    /**
     * If not 0, a message thread identifier in which the message will be sent; for
     * forum threads only
     */
    readonly message_thread_id?: number,
    /** Identifier of the chat from which to forward messages */
    readonly from_chat_id?: number,
    /**
     * Identifiers of the messages to forward. Message identifiers must be in a strictly
     * increasing order. At most 100 messages can be forwarded simultaneously
     */
    readonly message_ids?: ReadonlyArray<number>,
    /** Options to be used to send the messages; pass null to use default options */
    readonly options?: messageSendOptions$Input,
    /**
     * Pass true to copy content of the messages without reference to the original
     * sender. Always true if the messages are forwarded to a secret chat or are local
     */
    readonly send_copy?: boolean,
    /**
     * Pass true to remove media captions of message copies. Ignored if send_copy is
     * false
     */
    readonly remove_caption?: boolean,
    /** Pass true to get fake messages instead of actually forwarding them */
    readonly only_preview?: boolean,
  }

  export type resendMessages = {
    /**
     * Resends messages which failed to send. Can be called only for messages for which
     * messageSendingStateFailed.can_retry is true and after specified in messageSendingStateFailed.retry_after
     * time passed. If a message is re-sent, the corresponding failed to send message
     * is deleted. Returns the sent messages in the same order as the message identifiers
     * passed in message_ids. If a message can't be re-sent, null will be returned
     * instead of the message
     */
    readonly _: 'resendMessages',
    /** Identifier of the chat to send messages */
    readonly chat_id?: number,
    /**
     * Identifiers of the messages to resend. Message identifiers must be in a strictly
     * increasing order
     */
    readonly message_ids?: ReadonlyArray<number>,
  }

  export type addLocalMessage = {
    /**
     * Adds a local message to a chat. The message is persistent across application
     * restarts only if the message database is used. Returns the added message
     */
    readonly _: 'addLocalMessage',
    /** Target chat */
    readonly chat_id?: number,
    /** Identifier of the sender of the message */
    readonly sender_id?: MessageSender$Input,
    /** Identifier of the replied message or story; pass null if none */
    readonly reply_to?: MessageReplyTo$Input,
    /** Pass true to disable notification for the message */
    readonly disable_notification?: boolean,
    /** The content of the message to be added */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type deleteMessages = {
    /** Deletes messages */
    readonly _: 'deleteMessages',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Identifiers of the messages to be deleted */
    readonly message_ids?: ReadonlyArray<number>,
    /**
     * Pass true to delete messages for all chat members. Always true for supergroups,
     * channels and secret chats
     */
    readonly revoke?: boolean,
  }

  export type deleteChatMessagesBySender = {
    /**
     * Deletes all messages sent by the specified message sender in a chat. Supported
     * only for supergroups; requires can_delete_messages administrator privileges
     */
    readonly _: 'deleteChatMessagesBySender',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Identifier of the sender of messages to delete */
    readonly sender_id?: MessageSender$Input,
  }

  export type deleteChatMessagesByDate = {
    /**
     * Deletes all messages between the specified dates in a chat. Supported only for
     * private chats and basic groups. Messages sent in the last 30 seconds will not
     * be deleted
     */
    readonly _: 'deleteChatMessagesByDate',
    /** Chat identifier */
    readonly chat_id?: number,
    /** The minimum date of the messages to delete */
    readonly min_date?: number,
    /** The maximum date of the messages to delete */
    readonly max_date?: number,
    /** Pass true to delete chat messages for all users; private chats only */
    readonly revoke?: boolean,
  }

  export type editMessageText = {
    /**
     * Edits the text of a message (or a text of a game message). Returns the edited
     * message after the edit is completed on the server side
     */
    readonly _: 'editMessageText',
    /** The chat the message belongs to */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** The new message reply markup; pass null if none; for bots only */
    readonly reply_markup?: ReplyMarkup$Input,
    /** New text content of the message. Must be of type inputMessageText */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type editMessageLiveLocation = {
    /**
     * Edits the message content of a live location. Messages can be edited for a limited
     * period of time specified in the live location. Returns the edited message after
     * the edit is completed on the server side
     */
    readonly _: 'editMessageLiveLocation',
    /** The chat the message belongs to */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** The new message reply markup; pass null if none; for bots only */
    readonly reply_markup?: ReplyMarkup$Input,
    /** New location content of the message; pass null to stop sharing the live location */
    readonly location?: location$Input,
    /**
     * The new direction in which the location moves, in degrees; 1-360. Pass 0 if
     * unknown
     */
    readonly heading?: number,
    /**
     * The new maximum distance for proximity alerts, in meters (0-100000). Pass 0
     * if the notification is disabled
     */
    readonly proximity_alert_radius?: number,
  }

  export type editMessageMedia = {
    /**
     * Edits the content of a message with an animation, an audio, a document, a photo
     * or a video, including message caption. If only the caption needs to be edited,
     * use editMessageCaption instead. The media can't be edited if the message was
     * set to self-destruct or to a self-destructing media. The type of message content
     * in an album can't be changed with exception of replacing a photo with a video
     * or vice versa. Returns the edited message after the edit is completed on the
     * server side
     */
    readonly _: 'editMessageMedia',
    /** The chat the message belongs to */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** The new message reply markup; pass null if none; for bots only */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * New content of the message. Must be one of the following types: inputMessageAnimation,
     * inputMessageAudio, inputMessageDocument, inputMessagePhoto or inputMessageVideo
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type editMessageCaption = {
    /**
     * Edits the message content caption. Returns the edited message after the edit
     * is completed on the server side
     */
    readonly _: 'editMessageCaption',
    /** The chat the message belongs to */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** The new message reply markup; pass null if none; for bots only */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * New message content caption; 0-getOption("message_caption_length_max") characters;
     * pass null to remove caption
     */
    readonly caption?: formattedText$Input,
  }

  export type editMessageReplyMarkup = {
    /**
     * Edits the message reply markup; for bots only. Returns the edited message after
     * the edit is completed on the server side
     */
    readonly _: 'editMessageReplyMarkup',
    /** The chat the message belongs to */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** The new message reply markup; pass null if none */
    readonly reply_markup?: ReplyMarkup$Input,
  }

  export type editInlineMessageText = {
    /** Edits the text of an inline text or game message sent via a bot; for bots only */
    readonly _: 'editInlineMessageText',
    /** Inline message identifier */
    readonly inline_message_id?: string,
    /** The new message reply markup; pass null if none */
    readonly reply_markup?: ReplyMarkup$Input,
    /** New text content of the message. Must be of type inputMessageText */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type editInlineMessageLiveLocation = {
    /**
     * Edits the content of a live location in an inline message sent via a bot; for
     * bots only
     */
    readonly _: 'editInlineMessageLiveLocation',
    /** Inline message identifier */
    readonly inline_message_id?: string,
    /** The new message reply markup; pass null if none */
    readonly reply_markup?: ReplyMarkup$Input,
    /** New location content of the message; pass null to stop sharing the live location */
    readonly location?: location$Input,
    /**
     * The new direction in which the location moves, in degrees; 1-360. Pass 0 if
     * unknown
     */
    readonly heading?: number,
    /**
     * The new maximum distance for proximity alerts, in meters (0-100000). Pass 0
     * if the notification is disabled
     */
    readonly proximity_alert_radius?: number,
  }

  export type editInlineMessageMedia = {
    /**
     * Edits the content of a message with an animation, an audio, a document, a photo
     * or a video in an inline message sent via a bot; for bots only
     */
    readonly _: 'editInlineMessageMedia',
    /** Inline message identifier */
    readonly inline_message_id?: string,
    /** The new message reply markup; pass null if none; for bots only */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * New content of the message. Must be one of the following types: inputMessageAnimation,
     * inputMessageAudio, inputMessageDocument, inputMessagePhoto or inputMessageVideo
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type editInlineMessageCaption = {
    /** Edits the caption of an inline message sent via a bot; for bots only */
    readonly _: 'editInlineMessageCaption',
    /** Inline message identifier */
    readonly inline_message_id?: string,
    /** The new message reply markup; pass null if none */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * New message content caption; pass null to remove caption; 0-getOption("message_caption_length_max")
     * characters
     */
    readonly caption?: formattedText$Input,
  }

  export type editInlineMessageReplyMarkup = {
    /** Edits the reply markup of an inline message sent via a bot; for bots only */
    readonly _: 'editInlineMessageReplyMarkup',
    /** Inline message identifier */
    readonly inline_message_id?: string,
    /** The new message reply markup; pass null if none */
    readonly reply_markup?: ReplyMarkup$Input,
  }

  export type editMessageSchedulingState = {
    /**
     * Edits the time when a scheduled message will be sent. Scheduling state of all
     * messages in the same album or forwarded together with the message will be also
     * changed
     */
    readonly _: 'editMessageSchedulingState',
    /** The chat the message belongs to */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** The new message scheduling state; pass null to send the message immediately */
    readonly scheduling_state?: MessageSchedulingState$Input,
  }

  export type getForumTopicDefaultIcons = {
    /**
     * Returns list of custom emojis, which can be used as forum topic icon by all
     * users
     */
    readonly _: 'getForumTopicDefaultIcons',
  }

  export type createForumTopic = {
    /**
     * Creates a topic in a forum supergroup chat; requires can_manage_topics rights
     * in the supergroup
     */
    readonly _: 'createForumTopic',
    /** Identifier of the chat */
    readonly chat_id?: number,
    /** Name of the topic; 1-128 characters */
    readonly name?: string,
    /**
     * Icon of the topic. Icon color must be one of 0x6FB9F0, 0xFFD67E, 0xCB86DB, 0x8EEE98,
     * 0xFF93B2, or 0xFB6F5F. Telegram Premium users can use any custom emoji as topic
     * icon, other users can use only a custom emoji returned by getForumTopicDefaultIcons
     */
    readonly icon?: forumTopicIcon$Input,
  }

  export type editForumTopic = {
    /**
     * Edits title and icon of a topic in a forum supergroup chat; requires can_manage_topics
     * administrator right in the supergroup unless the user is creator of the topic
     */
    readonly _: 'editForumTopic',
    /** Identifier of the chat */
    readonly chat_id?: number,
    /** Message thread identifier of the forum topic */
    readonly message_thread_id?: number,
    /**
     * New name of the topic; 0-128 characters. If empty, the previous topic name is
     * kept
     */
    readonly name?: string,
    /**
     * Pass true to edit the icon of the topic. Icon of the General topic can't be
     * edited
     */
    readonly edit_icon_custom_emoji?: boolean,
    /**
     * Identifier of the new custom emoji for topic icon; pass 0 to remove the custom
     * emoji. Ignored if edit_icon_custom_emoji is false. Telegram Premium users can
     * use any custom emoji, other users can use only a custom emoji returned by getForumTopicDefaultIcons
     */
    readonly icon_custom_emoji_id?: number | string,
  }

  export type getForumTopic = {
    /** Returns information about a forum topic */
    readonly _: 'getForumTopic',
    /** Identifier of the chat */
    readonly chat_id?: number,
    /** Message thread identifier of the forum topic */
    readonly message_thread_id?: number,
  }

  export type getForumTopicLink = {
    /** Returns an HTTPS link to a topic in a forum chat. This is an offline request */
    readonly _: 'getForumTopicLink',
    /** Identifier of the chat */
    readonly chat_id?: number,
    /** Message thread identifier of the forum topic */
    readonly message_thread_id?: number,
  }

  export type getForumTopics = {
    /**
     * Returns found forum topics in a forum chat. This is a temporary method for getting
     * information about topic list from the server
     */
    readonly _: 'getForumTopics',
    /** Identifier of the forum chat */
    readonly chat_id?: number,
    /** Query to search for in the forum topic's name */
    readonly query?: string,
    /**
     * The date starting from which the results need to be fetched. Use 0 or any date
     * in the future to get results from the last topic
     */
    readonly offset_date?: number,
    /**
     * The message identifier of the last message in the last found topic, or 0 for
     * the first request
     */
    readonly offset_message_id?: number,
    /** The message thread identifier of the last found topic, or 0 for the first request */
    readonly offset_message_thread_id?: number,
    /**
     * The maximum number of forum topics to be returned; up to 100. For optimal performance,
     * the number of returned forum topics is chosen by TDLib and can be smaller than
     * the specified limit
     */
    readonly limit?: number,
  }

  export type setForumTopicNotificationSettings = {
    /** Changes the notification settings of a forum topic */
    readonly _: 'setForumTopicNotificationSettings',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Message thread identifier of the forum topic */
    readonly message_thread_id?: number,
    /**
     * New notification settings for the forum topic. If the topic is muted for more
     * than 366 days, it is considered to be muted forever
     */
    readonly notification_settings?: chatNotificationSettings$Input,
  }

  export type toggleForumTopicIsClosed = {
    /**
     * Toggles whether a topic is closed in a forum supergroup chat; requires can_manage_topics
     * administrator right in the supergroup unless the user is creator of the topic
     */
    readonly _: 'toggleForumTopicIsClosed',
    /** Identifier of the chat */
    readonly chat_id?: number,
    /** Message thread identifier of the forum topic */
    readonly message_thread_id?: number,
    /** Pass true to close the topic; pass false to reopen it */
    readonly is_closed?: boolean,
  }

  export type toggleGeneralForumTopicIsHidden = {
    /**
     * Toggles whether a General topic is hidden in a forum supergroup chat; requires
     * can_manage_topics administrator right in the supergroup
     */
    readonly _: 'toggleGeneralForumTopicIsHidden',
    /** Identifier of the chat */
    readonly chat_id?: number,
    /** Pass true to hide and close the General topic; pass false to unhide it */
    readonly is_hidden?: boolean,
  }

  export type toggleForumTopicIsPinned = {
    /**
     * Changes the pinned state of a forum topic; requires can_manage_topics administrator
     * right in the supergroup. There can be up to getOption("pinned_forum_topic_count_max")
     * pinned forum topics
     */
    readonly _: 'toggleForumTopicIsPinned',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Message thread identifier of the forum topic */
    readonly message_thread_id?: number,
    /** Pass true to pin the topic; pass false to unpin it */
    readonly is_pinned?: boolean,
  }

  export type setPinnedForumTopics = {
    /** Changes the order of pinned forum topics */
    readonly _: 'setPinnedForumTopics',
    /** Chat identifier */
    readonly chat_id?: number,
    /** The new list of pinned forum topics */
    readonly message_thread_ids?: ReadonlyArray<number>,
  }

  export type deleteForumTopic = {
    /**
     * Deletes all messages in a forum topic; requires can_delete_messages administrator
     * right in the supergroup unless the user is creator of the topic, the topic has
     * no messages from other users and has at most 11 messages
     */
    readonly _: 'deleteForumTopic',
    /** Identifier of the chat */
    readonly chat_id?: number,
    /** Message thread identifier of the forum topic */
    readonly message_thread_id?: number,
  }

  export type getEmojiReaction = {
    /**
     * Returns information about a emoji reaction. Returns a 404 error if the reaction
     * is not found
     */
    readonly _: 'getEmojiReaction',
    /** Text representation of the reaction */
    readonly emoji?: string,
  }

  export type getCustomEmojiReactionAnimations = {
    /** Returns TGS stickers with generic animations for custom emoji reactions */
    readonly _: 'getCustomEmojiReactionAnimations',
  }

  export type getMessageAvailableReactions = {
    /**
     * Returns reactions, which can be added to a message. The list can change after
     * updateActiveEmojiReactions, updateChatAvailableReactions for the chat, or updateMessageInteractionInfo
     * for the message
     */
    readonly _: 'getMessageAvailableReactions',
    /** Identifier of the chat to which the message belongs */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** Number of reaction per row, 5-25 */
    readonly row_size?: number,
  }

  export type clearRecentReactions = {
    /** Clears the list of recently used reactions */
    readonly _: 'clearRecentReactions',
  }

  export type addMessageReaction = {
    /**
     * Adds a reaction to a message. Use getMessageAvailableReactions to receive the
     * list of available reactions for the message
     */
    readonly _: 'addMessageReaction',
    /** Identifier of the chat to which the message belongs */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** Type of the reaction to add */
    readonly reaction_type?: ReactionType$Input,
    /** Pass true if the reaction is added with a big animation */
    readonly is_big?: boolean,
    /** Pass true if the reaction needs to be added to recent reactions */
    readonly update_recent_reactions?: boolean,
  }

  export type removeMessageReaction = {
    /** Removes a reaction from a message. A chosen reaction can always be removed */
    readonly _: 'removeMessageReaction',
    /** Identifier of the chat to which the message belongs */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** Type of the reaction to remove */
    readonly reaction_type?: ReactionType$Input,
  }

  export type getMessageAddedReactions = {
    /** Returns reactions added for a message, along with their sender */
    readonly _: 'getMessageAddedReactions',
    /** Identifier of the chat to which the message belongs */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** Type of the reactions to return; pass null to return all added reactions */
    readonly reaction_type?: ReactionType$Input,
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    readonly offset?: string,
    /**
     * The maximum number of reactions to be returned; must be positive and can't be
     * greater than 100
     */
    readonly limit?: number,
  }

  export type setDefaultReactionType = {
    /** Changes type of default reaction for the current user */
    readonly _: 'setDefaultReactionType',
    /** New type of the default reaction */
    readonly reaction_type?: ReactionType$Input,
  }

  export type getTextEntities = {
    /**
     * Returns all entities (mentions, hashtags, cashtags, bot commands, bank card
     * numbers, URLs, and email addresses) found in the text. Can be called synchronously
     */
    readonly _: 'getTextEntities',
    /** The text in which to look for entities */
    readonly text?: string,
  }

  export type parseTextEntities = {
    /**
     * Parses Bold, Italic, Underline, Strikethrough, Spoiler, CustomEmoji, Code, Pre,
     * PreCode, TextUrl and MentionName entities from a marked-up text. Can be called
     * synchronously
     */
    readonly _: 'parseTextEntities',
    /** The text to parse */
    readonly text?: string,
    /** Text parse mode */
    readonly parse_mode?: TextParseMode$Input,
  }

  export type parseMarkdown = {
    /**
     * Parses Markdown entities in a human-friendly format, ignoring markup errors.
     * Can be called synchronously
     */
    readonly _: 'parseMarkdown',
    /**
     * The text to parse. For example, "__italic__ ~~strikethrough~~ ||spoiler|| **bold**
     * `code` ```pre``` __[italic__ text_url](telegram.org) __italic**bold italic__bold**"
     */
    readonly text?: formattedText$Input,
  }

  export type getMarkdownText = {
    /**
     * Replaces text entities with Markdown formatting in a human-friendly format.
     * Entities that can't be represented in Markdown unambiguously are kept as is.
     * Can be called synchronously
     */
    readonly _: 'getMarkdownText',
    /** The text */
    readonly text?: formattedText$Input,
  }

  export type getFileMimeType = {
    /**
     * Returns the MIME type of a file, guessed by its extension. Returns an empty
     * string on failure. Can be called synchronously
     */
    readonly _: 'getFileMimeType',
    /** The name of the file or path to the file */
    readonly file_name?: string,
  }

  export type getFileExtension = {
    /**
     * Returns the extension of a file, guessed by its MIME type. Returns an empty
     * string on failure. Can be called synchronously
     */
    readonly _: 'getFileExtension',
    /** The MIME type of the file */
    readonly mime_type?: string,
  }

  export type cleanFileName = {
    /**
     * Removes potentially dangerous characters from the name of a file. The encoding
     * of the file name is supposed to be UTF-8. Returns an empty string on failure.
     * Can be called synchronously
     */
    readonly _: 'cleanFileName',
    /** File name or path to the file */
    readonly file_name?: string,
  }

  export type getLanguagePackString = {
    /**
     * Returns a string stored in the local database from the specified localization
     * target and language pack by its key. Returns a 404 error if the string is not
     * found. Can be called synchronously
     */
    readonly _: 'getLanguagePackString',
    /** Path to the language pack database in which strings are stored */
    readonly language_pack_database_path?: string,
    /** Localization target to which the language pack belongs */
    readonly localization_target?: string,
    /** Language pack identifier */
    readonly language_pack_id?: string,
    /** Language pack key of the string to be returned */
    readonly key?: string,
  }

  export type getJsonValue = {
    /**
     * Converts a JSON-serialized string to corresponding JsonValue object. Can be
     * called synchronously
     */
    readonly _: 'getJsonValue',
    /** The JSON-serialized string */
    readonly json?: string,
  }

  export type getJsonString = {
    /**
     * Converts a JsonValue object to corresponding JSON-serialized string. Can be
     * called synchronously
     */
    readonly _: 'getJsonString',
    /** The JsonValue object */
    readonly json_value?: JsonValue$Input,
  }

  export type getThemeParametersJsonString = {
    /**
     * Converts a themeParameters object to corresponding JSON-serialized string. Can
     * be called synchronously
     */
    readonly _: 'getThemeParametersJsonString',
    /** Theme parameters to convert to JSON */
    readonly theme?: themeParameters$Input,
  }

  export type setPollAnswer = {
    /**
     * Changes the user answer to a poll. A poll in quiz mode can be answered only
     * once
     */
    readonly _: 'setPollAnswer',
    /** Identifier of the chat to which the poll belongs */
    readonly chat_id?: number,
    /** Identifier of the message containing the poll */
    readonly message_id?: number,
    /**
     * 0-based identifiers of answer options, chosen by the user. User can choose more
     * than 1 answer option only is the poll allows multiple answers
     */
    readonly option_ids?: ReadonlyArray<number>,
  }

  export type getPollVoters = {
    /**
     * Returns message senders voted for the specified option in a non-anonymous polls.
     * For optimal performance, the number of returned users is chosen by TDLib
     */
    readonly _: 'getPollVoters',
    /** Identifier of the chat to which the poll belongs */
    readonly chat_id?: number,
    /** Identifier of the message containing the poll */
    readonly message_id?: number,
    /** 0-based identifier of the answer option */
    readonly option_id?: number,
    /** Number of voters to skip in the result; must be non-negative */
    readonly offset?: number,
    /**
     * The maximum number of voters to be returned; must be positive and can't be greater
     * than 50. For optimal performance, the number of returned voters is chosen by
     * TDLib and can be smaller than the specified limit, even if the end of the voter
     * list has not been reached
     */
    readonly limit?: number,
  }

  export type stopPoll = {
    /**
     * Stops a poll. A poll in a message can be stopped when the message has can_be_edited
     * flag is set
     */
    readonly _: 'stopPoll',
    /** Identifier of the chat to which the poll belongs */
    readonly chat_id?: number,
    /** Identifier of the message containing the poll */
    readonly message_id?: number,
    /** The new message reply markup; pass null if none; for bots only */
    readonly reply_markup?: ReplyMarkup$Input,
  }

  export type hideSuggestedAction = {
    /** Hides a suggested action */
    readonly _: 'hideSuggestedAction',
    /** Suggested action to hide */
    readonly action?: SuggestedAction$Input,
  }

  export type getLoginUrlInfo = {
    /**
     * Returns information about a button of type inlineKeyboardButtonTypeLoginUrl.
     * The method needs to be called when the user presses the button
     */
    readonly _: 'getLoginUrlInfo',
    /** Chat identifier of the message with the button */
    readonly chat_id?: number,
    /** Message identifier of the message with the button */
    readonly message_id?: number,
    /** Button identifier */
    readonly button_id?: number,
  }

  export type getLoginUrl = {
    /**
     * Returns an HTTP URL which can be used to automatically authorize the user on
     * a website after clicking an inline button of type inlineKeyboardButtonTypeLoginUrl.
     * Use the method getLoginUrlInfo to find whether a prior user confirmation is
     * needed. If an error is returned, then the button must be handled as an ordinary
     * URL button
     */
    readonly _: 'getLoginUrl',
    /** Chat identifier of the message with the button */
    readonly chat_id?: number,
    /** Message identifier of the message with the button */
    readonly message_id?: number,
    /** Button identifier */
    readonly button_id?: number,
    /** Pass true to allow the bot to send messages to the current user */
    readonly allow_write_access?: boolean,
  }

  export type shareUserWithBot = {
    /**
     * Shares a user after pressing a keyboardButtonTypeRequestUser button with the
     * bot
     */
    readonly _: 'shareUserWithBot',
    /** Identifier of the chat with the bot */
    readonly chat_id?: number,
    /** Identifier of the message with the button */
    readonly message_id?: number,
    /** Identifier of the button */
    readonly button_id?: number,
    /** Identifier of the shared user */
    readonly shared_user_id?: number,
    /**
     * Pass true to check that the user can be shared by the button instead of actually
     * sharing them
     */
    readonly only_check?: boolean,
  }

  export type shareChatWithBot = {
    /**
     * Shares a chat after pressing a keyboardButtonTypeRequestChat button with the
     * bot
     */
    readonly _: 'shareChatWithBot',
    /** Identifier of the chat with the bot */
    readonly chat_id?: number,
    /** Identifier of the message with the button */
    readonly message_id?: number,
    /** Identifier of the button */
    readonly button_id?: number,
    /** Identifier of the shared chat */
    readonly shared_chat_id?: number,
    /**
     * Pass true to check that the chat can be shared by the button instead of actually
     * sharing it. Doesn't check bot_is_member and bot_administrator_rights restrictions.
     * If the bot must be a member, then all chats from getGroupsInCommon and all chats,
     * where the user can add the bot, are suitable. In the latter case the bot will
     * be automatically added to the chat. If the bot must be an administrator, then
     * all chats, where the bot already has requested rights or can be added to administrators
     * by the user, are suitable. In the latter case the bot will be automatically
     * granted requested rights
     */
    readonly only_check?: boolean,
  }

  export type getInlineQueryResults = {
    /**
     * Sends an inline query to a bot and returns its results. Returns an error with
     * code 502 if the bot fails to answer the query before the query timeout expires
     */
    readonly _: 'getInlineQueryResults',
    /** Identifier of the target bot */
    readonly bot_user_id?: number,
    /** Identifier of the chat where the query was sent */
    readonly chat_id?: number,
    /** Location of the user; pass null if unknown or the bot doesn't need user's location */
    readonly user_location?: location$Input,
    /** Text of the query */
    readonly query?: string,
    /**
     * Offset of the first entry to return; use empty string to get the first chunk
     * of results
     */
    readonly offset?: string,
  }

  export type answerInlineQuery = {
    /** Sets the result of an inline query; for bots only */
    readonly _: 'answerInlineQuery',
    /** Identifier of the inline query */
    readonly inline_query_id?: number | string,
    /**
     * Pass true if results may be cached and returned only for the user that sent
     * the query. By default, results may be returned to any user who sends the same
     * query
     */
    readonly is_personal?: boolean,
    /** Button to be shown above inline query results; pass null if none */
    readonly button?: inlineQueryResultsButton$Input,
    /** The results of the query */
    readonly results?: ReadonlyArray<InputInlineQueryResult$Input>,
    /** Allowed time to cache the results of the query, in seconds */
    readonly cache_time?: number,
    /**
     * Offset for the next inline query; pass an empty string if there are no more
     * results
     */
    readonly next_offset?: string,
  }

  export type searchWebApp = {
    /**
     * Returns information about a Web App by its short name. Returns a 404 error if
     * the Web App is not found
     */
    readonly _: 'searchWebApp',
    /** Identifier of the target bot */
    readonly bot_user_id?: number,
    /** Short name of the Web App */
    readonly web_app_short_name?: string,
  }

  export type getWebAppLinkUrl = {
    /**
     * Returns an HTTPS URL of a Web App to open after a link of the type internalLinkTypeWebApp
     * is clicked
     */
    readonly _: 'getWebAppLinkUrl',
    /** Identifier of the chat in which the link was clicked; pass 0 if none */
    readonly chat_id?: number,
    /** Identifier of the target bot */
    readonly bot_user_id?: number,
    /** Short name of the Web App */
    readonly web_app_short_name?: string,
    /** Start parameter from internalLinkTypeWebApp */
    readonly start_parameter?: string,
    /** Preferred Web App theme; pass null to use the default theme */
    readonly theme?: themeParameters$Input,
    /** Short name of the application; 0-64 English letters, digits, and underscores */
    readonly application_name?: string,
    /** Pass true if the current user allowed the bot to send them messages */
    readonly allow_write_access?: boolean,
  }

  export type getWebAppUrl = {
    /**
     * Returns an HTTPS URL of a Web App to open from the side menu, a keyboardButtonTypeWebApp
     * button, an inlineQueryResultsButtonTypeWebApp button, or an internalLinkTypeSideMenuBot
     * link
     */
    readonly _: 'getWebAppUrl',
    /** Identifier of the target bot */
    readonly bot_user_id?: number,
    /**
     * The URL from a keyboardButtonTypeWebApp button, inlineQueryResultsButtonTypeWebApp
     * button, an internalLinkTypeSideMenuBot link, or an empty when the bot is opened
     * from the side menu
     */
    readonly url?: string,
    /** Preferred Web App theme; pass null to use the default theme */
    readonly theme?: themeParameters$Input,
    /** Short name of the application; 0-64 English letters, digits, and underscores */
    readonly application_name?: string,
  }

  export type sendWebAppData = {
    /** Sends data received from a keyboardButtonTypeWebApp Web App to a bot */
    readonly _: 'sendWebAppData',
    /** Identifier of the target bot */
    readonly bot_user_id?: number,
    /** Text of the keyboardButtonTypeWebApp button, which opened the Web App */
    readonly button_text?: string,
    /** The data */
    readonly data?: string,
  }

  export type openWebApp = {
    /**
     * Informs TDLib that a Web App is being opened from the attachment menu, a botMenuButton
     * button, an internalLinkTypeAttachmentMenuBot link, or an inlineKeyboardButtonTypeWebApp
     * button. For each bot, a confirmation alert about data sent to the bot must be
     * shown once
     */
    readonly _: 'openWebApp',
    /**
     * Identifier of the chat in which the Web App is opened. The Web App can't be
     * opened in secret chats
     */
    readonly chat_id?: number,
    /** Identifier of the bot, providing the Web App */
    readonly bot_user_id?: number,
    /**
     * The URL from an inlineKeyboardButtonTypeWebApp button, a botMenuButton button,
     * an internalLinkTypeAttachmentMenuBot link, or an empty string otherwise
     */
    readonly url?: string,
    /** Preferred Web App theme; pass null to use the default theme */
    readonly theme?: themeParameters$Input,
    /** Short name of the application; 0-64 English letters, digits, and underscores */
    readonly application_name?: string,
    /** If not 0, a message thread identifier in which the message will be sent */
    readonly message_thread_id?: number,
    /**
     * Identifier of the replied message or story for the message sent by the Web App;
     * pass null if none
     */
    readonly reply_to?: MessageReplyTo$Input,
  }

  export type closeWebApp = {
    /** Informs TDLib that a previously opened Web App was closed */
    readonly _: 'closeWebApp',
    /** Identifier of Web App launch, received from openWebApp */
    readonly web_app_launch_id?: number | string,
  }

  export type answerWebAppQuery = {
    /**
     * Sets the result of interaction with a Web App and sends corresponding message
     * on behalf of the user to the chat from which the query originated; for bots
     * only
     */
    readonly _: 'answerWebAppQuery',
    /** Identifier of the Web App query */
    readonly web_app_query_id?: string,
    /** The result of the query */
    readonly result?: InputInlineQueryResult$Input,
  }

  export type getCallbackQueryAnswer = {
    /**
     * Sends a callback query to a bot and returns an answer. Returns an error with
     * code 502 if the bot fails to answer the query before the query timeout expires
     */
    readonly _: 'getCallbackQueryAnswer',
    /** Identifier of the chat with the message */
    readonly chat_id?: number,
    /** Identifier of the message from which the query originated */
    readonly message_id?: number,
    /** Query payload */
    readonly payload?: CallbackQueryPayload$Input,
  }

  export type answerCallbackQuery = {
    /** Sets the result of a callback query; for bots only */
    readonly _: 'answerCallbackQuery',
    /** Identifier of the callback query */
    readonly callback_query_id?: number | string,
    /** Text of the answer */
    readonly text?: string,
    /** Pass true to show an alert to the user instead of a toast notification */
    readonly show_alert?: boolean,
    /** URL to be opened */
    readonly url?: string,
    /** Time during which the result of the query can be cached, in seconds */
    readonly cache_time?: number,
  }

  export type answerShippingQuery = {
    /** Sets the result of a shipping query; for bots only */
    readonly _: 'answerShippingQuery',
    /** Identifier of the shipping query */
    readonly shipping_query_id?: number | string,
    /** Available shipping options */
    readonly shipping_options?: ReadonlyArray<shippingOption$Input>,
    /** An error message, empty on success */
    readonly error_message?: string,
  }

  export type answerPreCheckoutQuery = {
    /** Sets the result of a pre-checkout query; for bots only */
    readonly _: 'answerPreCheckoutQuery',
    /** Identifier of the pre-checkout query */
    readonly pre_checkout_query_id?: number | string,
    /** An error message, empty on success */
    readonly error_message?: string,
  }

  export type setGameScore = {
    /** Updates the game score of the specified user in the game; for bots only */
    readonly _: 'setGameScore',
    /** The chat to which the message with the game belongs */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** Pass true to edit the game message to include the current scoreboard */
    readonly edit_message?: boolean,
    /** User identifier */
    readonly user_id?: number,
    /** The new score */
    readonly score?: number,
    /**
     * Pass true to update the score even if it decreases. If the score is 0, the user
     * will be deleted from the high score table
     */
    readonly force?: boolean,
  }

  export type setInlineGameScore = {
    /** Updates the game score of the specified user in a game; for bots only */
    readonly _: 'setInlineGameScore',
    /** Inline message identifier */
    readonly inline_message_id?: string,
    /** Pass true to edit the game message to include the current scoreboard */
    readonly edit_message?: boolean,
    /** User identifier */
    readonly user_id?: number,
    /** The new score */
    readonly score?: number,
    /**
     * Pass true to update the score even if it decreases. If the score is 0, the user
     * will be deleted from the high score table
     */
    readonly force?: boolean,
  }

  export type getGameHighScores = {
    /**
     * Returns the high scores for a game and some part of the high score table in
     * the range of the specified user; for bots only
     */
    readonly _: 'getGameHighScores',
    /** The chat that contains the message with the game */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** User identifier */
    readonly user_id?: number,
  }

  export type getInlineGameHighScores = {
    /**
     * Returns game high scores and some part of the high score table in the range
     * of the specified user; for bots only
     */
    readonly _: 'getInlineGameHighScores',
    /** Inline message identifier */
    readonly inline_message_id?: string,
    /** User identifier */
    readonly user_id?: number,
  }

  export type deleteChatReplyMarkup = {
    /**
     * Deletes the default reply markup from a chat. Must be called after a one-time
     * keyboard or a replyMarkupForceReply reply markup has been used. An updateChatReplyMarkup
     * update will be sent if the reply markup is changed
     */
    readonly _: 'deleteChatReplyMarkup',
    /** Chat identifier */
    readonly chat_id?: number,
    /** The message identifier of the used keyboard */
    readonly message_id?: number,
  }

  export type sendChatAction = {
    /** Sends a notification about user activity in a chat */
    readonly _: 'sendChatAction',
    /** Chat identifier */
    readonly chat_id?: number,
    /** If not 0, a message thread identifier in which the action was performed */
    readonly message_thread_id?: number,
    /** The action description; pass null to cancel the currently active action */
    readonly action?: ChatAction$Input,
  }

  export type openChat = {
    /**
     * Informs TDLib that the chat is opened by the user. Many useful activities depend
     * on the chat being opened or closed (e.g., in supergroups and channels all updates
     * are received only for opened chats)
     */
    readonly _: 'openChat',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type closeChat = {
    /**
     * Informs TDLib that the chat is closed by the user. Many useful activities depend
     * on the chat being opened or closed
     */
    readonly _: 'closeChat',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type viewMessages = {
    /**
     * Informs TDLib that messages are being viewed by the user. Sponsored messages
     * must be marked as viewed only when the entire text of the message is shown on
     * the screen (excluding the button). Many useful activities depend on whether
     * the messages are currently being viewed or not (e.g., marking messages as read,
     * incrementing a view counter, updating a view counter, removing deleted messages
     * in supergroups and channels)
     */
    readonly _: 'viewMessages',
    /** Chat identifier */
    readonly chat_id?: number,
    /** The identifiers of the messages being viewed */
    readonly message_ids?: ReadonlyArray<number>,
    /**
     * Source of the message view; pass null to guess the source based on chat open
     * state
     */
    readonly source?: MessageSource$Input,
    /** Pass true to mark as read the specified messages even the chat is closed */
    readonly force_read?: boolean,
  }

  export type openMessageContent = {
    /**
     * Informs TDLib that the message content has been opened (e.g., the user has opened
     * a photo, video, document, location or venue, or has listened to an audio file
     * or voice note message). An updateMessageContentOpened update will be generated
     * if something has changed
     */
    readonly _: 'openMessageContent',
    /** Chat identifier of the message */
    readonly chat_id?: number,
    /** Identifier of the message with the opened content */
    readonly message_id?: number,
  }

  export type clickAnimatedEmojiMessage = {
    /**
     * Informs TDLib that a message with an animated emoji was clicked by the user.
     * Returns a big animated sticker to be played or a 404 error if usual animation
     * needs to be played
     */
    readonly _: 'clickAnimatedEmojiMessage',
    /** Chat identifier of the message */
    readonly chat_id?: number,
    /** Identifier of the clicked message */
    readonly message_id?: number,
  }

  export type getInternalLink = {
    /** Returns an HTTPS or a tg: link with the given type. Can be called before authorization */
    readonly _: 'getInternalLink',
    /** Expected type of the link */
    readonly type?: InternalLinkType$Input,
    /**
     * Pass true to create an HTTPS link (only available for some link types); pass
     * false to create a tg: link
     */
    readonly is_http?: boolean,
  }

  export type getInternalLinkType = {
    /**
     * Returns information about the type of an internal link. Returns a 404 error
     * if the link is not internal. Can be called before authorization
     */
    readonly _: 'getInternalLinkType',
    /** The link */
    readonly link?: string,
  }

  export type getExternalLinkInfo = {
    /**
     * Returns information about an action to be done when the current user clicks
     * an external link. Don't use this method for links from secret chats if web page
     * preview is disabled in secret chats
     */
    readonly _: 'getExternalLinkInfo',
    /** The link */
    readonly link?: string,
  }

  export type getExternalLink = {
    /**
     * Returns an HTTP URL which can be used to automatically authorize the current
     * user on a website after clicking an HTTP link. Use the method getExternalLinkInfo
     * to find whether a prior user confirmation is needed
     */
    readonly _: 'getExternalLink',
    /** The HTTP link */
    readonly link?: string,
    /**
     * Pass true if the current user allowed the bot, returned in getExternalLinkInfo,
     * to send them messages
     */
    readonly allow_write_access?: boolean,
  }

  export type readAllChatMentions = {
    /** Marks all mentions in a chat as read */
    readonly _: 'readAllChatMentions',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type readAllMessageThreadMentions = {
    /** Marks all mentions in a forum topic as read */
    readonly _: 'readAllMessageThreadMentions',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Message thread identifier in which mentions are marked as read */
    readonly message_thread_id?: number,
  }

  export type readAllChatReactions = {
    /** Marks all reactions in a chat or a forum topic as read */
    readonly _: 'readAllChatReactions',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type readAllMessageThreadReactions = {
    /** Marks all reactions in a forum topic as read */
    readonly _: 'readAllMessageThreadReactions',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Message thread identifier in which reactions are marked as read */
    readonly message_thread_id?: number,
  }

  export type createPrivateChat = {
    /** Returns an existing chat corresponding to a given user */
    readonly _: 'createPrivateChat',
    /** User identifier */
    readonly user_id?: number,
    /**
     * Pass true to create the chat without a network request. In this case all information
     * about the chat except its type, title and photo can be incorrect
     */
    readonly force?: boolean,
  }

  export type createBasicGroupChat = {
    /** Returns an existing chat corresponding to a known basic group */
    readonly _: 'createBasicGroupChat',
    /** Basic group identifier */
    readonly basic_group_id?: number,
    /**
     * Pass true to create the chat without a network request. In this case all information
     * about the chat except its type, title and photo can be incorrect
     */
    readonly force?: boolean,
  }

  export type createSupergroupChat = {
    /** Returns an existing chat corresponding to a known supergroup or channel */
    readonly _: 'createSupergroupChat',
    /** Supergroup or channel identifier */
    readonly supergroup_id?: number,
    /**
     * Pass true to create the chat without a network request. In this case all information
     * about the chat except its type, title and photo can be incorrect
     */
    readonly force?: boolean,
  }

  export type createSecretChat = {
    /** Returns an existing chat corresponding to a known secret chat */
    readonly _: 'createSecretChat',
    /** Secret chat identifier */
    readonly secret_chat_id?: number,
  }

  export type createNewBasicGroupChat = {
    /**
     * Creates a new basic group and sends a corresponding messageBasicGroupChatCreate.
     * Returns the newly created chat
     */
    readonly _: 'createNewBasicGroupChat',
    /**
     * Identifiers of users to be added to the basic group; may be empty to create
     * a basic group without other members
     */
    readonly user_ids?: ReadonlyArray<number>,
    /** Title of the new basic group; 1-128 characters */
    readonly title?: string,
    /**
     * Message auto-delete time value, in seconds; must be from 0 up to 365 * 86400
     * and be divisible by 86400. If 0, then messages aren't deleted automatically
     */
    readonly message_auto_delete_time?: number,
  }

  export type createNewSupergroupChat = {
    /**
     * Creates a new supergroup or channel and sends a corresponding messageSupergroupChatCreate.
     * Returns the newly created chat
     */
    readonly _: 'createNewSupergroupChat',
    /** Title of the new chat; 1-128 characters */
    readonly title?: string,
    /** Pass true to create a forum supergroup chat */
    readonly is_forum?: boolean,
    /** Pass true to create a channel chat; ignored if a forum is created */
    readonly is_channel?: boolean,
    /** Chat description; 0-255 characters */
    readonly description?: string,
    /**
     * Chat location if a location-based supergroup is being created; pass null to
     * create an ordinary supergroup chat
     */
    readonly location?: chatLocation$Input,
    /**
     * Message auto-delete time value, in seconds; must be from 0 up to 365 * 86400
     * and be divisible by 86400. If 0, then messages aren't deleted automatically
     */
    readonly message_auto_delete_time?: number,
    /** Pass true to create a supergroup for importing messages using importMessages */
    readonly for_import?: boolean,
  }

  export type createNewSecretChat = {
    /** Creates a new secret chat. Returns the newly created chat */
    readonly _: 'createNewSecretChat',
    /** Identifier of the target user */
    readonly user_id?: number,
  }

  export type upgradeBasicGroupChatToSupergroupChat = {
    /**
     * Creates a new supergroup from an existing basic group and sends a corresponding
     * messageChatUpgradeTo and messageChatUpgradeFrom; requires creator privileges.
     * Deactivates the original basic group
     */
    readonly _: 'upgradeBasicGroupChatToSupergroupChat',
    /** Identifier of the chat to upgrade */
    readonly chat_id?: number,
  }

  export type getChatListsToAddChat = {
    /** Returns chat lists to which the chat can be added. This is an offline request */
    readonly _: 'getChatListsToAddChat',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type addChatToList = {
    /**
     * Adds a chat to a chat list. A chat can't be simultaneously in Main and Archive
     * chat lists, so it is automatically removed from another one if needed
     */
    readonly _: 'addChatToList',
    /** Chat identifier */
    readonly chat_id?: number,
    /** The chat list. Use getChatListsToAddChat to get suitable chat lists */
    readonly chat_list?: ChatList$Input,
  }

  export type getChatFolder = {
    /** Returns information about a chat folder by its identifier */
    readonly _: 'getChatFolder',
    /** Chat folder identifier */
    readonly chat_folder_id?: number,
  }

  export type createChatFolder = {
    /**
     * Creates new chat folder. Returns information about the created chat folder.
     * There can be up to getOption("chat_folder_count_max") chat folders, but the
     * limit can be increased with Telegram Premium
     */
    readonly _: 'createChatFolder',
    /** The new chat folder */
    readonly folder?: chatFolder$Input,
  }

  export type editChatFolder = {
    /** Edits existing chat folder. Returns information about the edited chat folder */
    readonly _: 'editChatFolder',
    /** Chat folder identifier */
    readonly chat_folder_id?: number,
    /** The edited chat folder */
    readonly folder?: chatFolder$Input,
  }

  export type deleteChatFolder = {
    /** Deletes existing chat folder */
    readonly _: 'deleteChatFolder',
    /** Chat folder identifier */
    readonly chat_folder_id?: number,
    /**
     * Identifiers of the chats to leave. The chats must be pinned or always included
     * in the folder
     */
    readonly leave_chat_ids?: ReadonlyArray<number>,
  }

  export type getChatFolderChatsToLeave = {
    /**
     * Returns identifiers of pinned or always included chats from a chat folder, which
     * are suggested to be left when the chat folder is deleted
     */
    readonly _: 'getChatFolderChatsToLeave',
    /** Chat folder identifier */
    readonly chat_folder_id?: number,
  }

  export type getChatFolderChatCount = {
    /**
     * Returns approximate number of chats in a being created chat folder. Main and
     * archive chat lists must be fully preloaded for this function to work correctly
     */
    readonly _: 'getChatFolderChatCount',
    /** The new chat folder */
    readonly folder?: chatFolder$Input,
  }

  export type reorderChatFolders = {
    /** Changes the order of chat folders */
    readonly _: 'reorderChatFolders',
    /** Identifiers of chat folders in the new correct order */
    readonly chat_folder_ids?: ReadonlyArray<number>,
    /**
     * Position of the main chat list among chat folders, 0-based. Can be non-zero
     * only for Premium users
     */
    readonly main_chat_list_position?: number,
  }

  export type getRecommendedChatFolders = {
    /** Returns recommended chat folders for the current user */
    readonly _: 'getRecommendedChatFolders',
  }

  export type getChatFolderDefaultIconName = {
    /** Returns default icon name for a folder. Can be called synchronously */
    readonly _: 'getChatFolderDefaultIconName',
    /** Chat folder */
    readonly folder?: chatFolder$Input,
  }

  export type getChatsForChatFolderInviteLink = {
    /**
     * Returns identifiers of chats from a chat folder, suitable for adding to a chat
     * folder invite link
     */
    readonly _: 'getChatsForChatFolderInviteLink',
    /** Chat folder identifier */
    readonly chat_folder_id?: number,
  }

  export type createChatFolderInviteLink = {
    /**
     * Creates a new invite link for a chat folder. A link can be created for a chat
     * folder if it has only pinned and included chats
     */
    readonly _: 'createChatFolderInviteLink',
    /** Chat folder identifier */
    readonly chat_folder_id?: number,
    /** Name of the link; 0-32 characters */
    readonly name?: string,
    /**
     * Identifiers of chats to be accessible by the invite link. Use getChatsForChatFolderInviteLink
     * to get suitable chats. Basic groups will be automatically converted to supergroups
     * before link creation
     */
    readonly chat_ids?: ReadonlyArray<number>,
  }

  export type getChatFolderInviteLinks = {
    /** Returns invite links created by the current user for a shareable chat folder */
    readonly _: 'getChatFolderInviteLinks',
    /** Chat folder identifier */
    readonly chat_folder_id?: number,
  }

  export type editChatFolderInviteLink = {
    /** Edits an invite link for a chat folder */
    readonly _: 'editChatFolderInviteLink',
    /** Chat folder identifier */
    readonly chat_folder_id?: number,
    /** Invite link to be edited */
    readonly invite_link?: string,
    /** New name of the link; 0-32 characters */
    readonly name?: string,
    /**
     * New identifiers of chats to be accessible by the invite link. Use getChatsForChatFolderInviteLink
     * to get suitable chats. Basic groups will be automatically converted to supergroups
     * before link editing
     */
    readonly chat_ids?: ReadonlyArray<number>,
  }

  export type deleteChatFolderInviteLink = {
    /** Deletes an invite link for a chat folder */
    readonly _: 'deleteChatFolderInviteLink',
    /** Chat folder identifier */
    readonly chat_folder_id?: number,
    /** Invite link to be deleted */
    readonly invite_link?: string,
  }

  export type checkChatFolderInviteLink = {
    /**
     * Checks the validity of an invite link for a chat folder and returns information
     * about the corresponding chat folder
     */
    readonly _: 'checkChatFolderInviteLink',
    /** Invite link to be checked */
    readonly invite_link?: string,
  }

  export type addChatFolderByInviteLink = {
    /** Adds a chat folder by an invite link */
    readonly _: 'addChatFolderByInviteLink',
    /** Invite link for the chat folder */
    readonly invite_link?: string,
    /**
     * Identifiers of the chats added to the chat folder. The chats are automatically
     * joined if they aren't joined yet
     */
    readonly chat_ids?: ReadonlyArray<number>,
  }

  export type getChatFolderNewChats = {
    /**
     * Returns new chats added to a shareable chat folder by its owner. The method
     * must be called at most once in getOption("chat_folder_new_chats_update_period")
     * for the given chat folder
     */
    readonly _: 'getChatFolderNewChats',
    /** Chat folder identifier */
    readonly chat_folder_id?: number,
  }

  export type processChatFolderNewChats = {
    /** Process new chats added to a shareable chat folder by its owner */
    readonly _: 'processChatFolderNewChats',
    /** Chat folder identifier */
    readonly chat_folder_id?: number,
    /**
     * Identifiers of the new chats, which are added to the chat folder. The chats
     * are automatically joined if they aren't joined yet
     */
    readonly added_chat_ids?: ReadonlyArray<number>,
  }

  export type getArchiveChatListSettings = {
    /**
     * Returns settings for automatic moving of chats to and from the Archive chat
     * lists
     */
    readonly _: 'getArchiveChatListSettings',
  }

  export type setArchiveChatListSettings = {
    /**
     * Changes settings for automatic moving of chats to and from the Archive chat
     * lists
     */
    readonly _: 'setArchiveChatListSettings',
    /** New settings */
    readonly settings?: archiveChatListSettings$Input,
  }

  export type setChatTitle = {
    /**
     * Changes the chat title. Supported only for basic groups, supergroups and channels.
     * Requires can_change_info administrator right
     */
    readonly _: 'setChatTitle',
    /** Chat identifier */
    readonly chat_id?: number,
    /** New title of the chat; 1-128 characters */
    readonly title?: string,
  }

  export type setChatPhoto = {
    /**
     * Changes the photo of a chat. Supported only for basic groups, supergroups and
     * channels. Requires can_change_info administrator right
     */
    readonly _: 'setChatPhoto',
    /** Chat identifier */
    readonly chat_id?: number,
    /** New chat photo; pass null to delete the chat photo */
    readonly photo?: InputChatPhoto$Input,
  }

  export type setChatMessageAutoDeleteTime = {
    /**
     * Changes the message auto-delete or self-destruct (for secret chats) time in
     * a chat. Requires change_info administrator right in basic groups, supergroups
     * and channels Message auto-delete time can't be changed in a chat with the current
     * user (Saved Messages) and the chat 777000 (Telegram).
     */
    readonly _: 'setChatMessageAutoDeleteTime',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * New time value, in seconds; unless the chat is secret, it must be from 0 up
     * to 365 * 86400 and be divisible by 86400. If 0, then messages aren't deleted
     * automatically
     */
    readonly message_auto_delete_time?: number,
  }

  export type setChatPermissions = {
    /**
     * Changes the chat members permissions. Supported only for basic groups and supergroups.
     * Requires can_restrict_members administrator right
     */
    readonly _: 'setChatPermissions',
    /** Chat identifier */
    readonly chat_id?: number,
    /** New non-administrator members permissions in the chat */
    readonly permissions?: chatPermissions$Input,
  }

  export type setChatBackground = {
    /**
     * Changes the background in a specific chat. Supported only in private and secret
     * chats with non-deleted users
     */
    readonly _: 'setChatBackground',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * The input background to use; pass null to create a new filled background or
     * to remove the current background
     */
    readonly background?: InputBackground$Input,
    /** Background type; pass null to remove the current background */
    readonly type?: BackgroundType$Input,
    /** Dimming of the background in dark themes, as a percentage; 0-100 */
    readonly dark_theme_dimming?: number,
  }

  export type setChatTheme = {
    /** Changes the chat theme. Supported only in private and secret chats */
    readonly _: 'setChatTheme',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Name of the new chat theme; pass an empty string to return the default theme */
    readonly theme_name?: string,
  }

  export type setChatDraftMessage = {
    /** Changes the draft message in a chat */
    readonly _: 'setChatDraftMessage',
    /** Chat identifier */
    readonly chat_id?: number,
    /** If not 0, a message thread identifier in which the draft was changed */
    readonly message_thread_id?: number,
    /** New draft message; pass null to remove the draft */
    readonly draft_message?: draftMessage$Input,
  }

  export type setChatNotificationSettings = {
    /**
     * Changes the notification settings of a chat. Notification settings of a chat
     * with the current user (Saved Messages) can't be changed
     */
    readonly _: 'setChatNotificationSettings',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * New notification settings for the chat. If the chat is muted for more than 366
     * days, it is considered to be muted forever
     */
    readonly notification_settings?: chatNotificationSettings$Input,
  }

  export type toggleChatHasProtectedContent = {
    /**
     * Changes the ability of users to save, forward, or copy chat content. Supported
     * only for basic groups, supergroups and channels. Requires owner privileges
     */
    readonly _: 'toggleChatHasProtectedContent',
    /** Chat identifier */
    readonly chat_id?: number,
    /** New value of has_protected_content */
    readonly has_protected_content?: boolean,
  }

  export type toggleChatIsTranslatable = {
    /** Changes the translatable state of a chat; for Telegram Premium users only */
    readonly _: 'toggleChatIsTranslatable',
    /** Chat identifier */
    readonly chat_id?: number,
    /** New value of is_translatable */
    readonly is_translatable?: boolean,
  }

  export type toggleChatIsMarkedAsUnread = {
    /** Changes the marked as unread state of a chat */
    readonly _: 'toggleChatIsMarkedAsUnread',
    /** Chat identifier */
    readonly chat_id?: number,
    /** New value of is_marked_as_unread */
    readonly is_marked_as_unread?: boolean,
  }

  export type toggleChatDefaultDisableNotification = {
    /**
     * Changes the value of the default disable_notification parameter, used when a
     * message is sent to a chat
     */
    readonly _: 'toggleChatDefaultDisableNotification',
    /** Chat identifier */
    readonly chat_id?: number,
    /** New value of default_disable_notification */
    readonly default_disable_notification?: boolean,
  }

  export type setChatAvailableReactions = {
    /**
     * Changes reactions, available in a chat. Available for basic groups, supergroups,
     * and channels. Requires can_change_info administrator right
     */
    readonly _: 'setChatAvailableReactions',
    /** Identifier of the chat */
    readonly chat_id?: number,
    /** Reactions available in the chat. All emoji reactions must be active */
    readonly available_reactions?: ChatAvailableReactions$Input,
  }

  export type setChatClientData = {
    /** Changes application-specific data associated with a chat */
    readonly _: 'setChatClientData',
    /** Chat identifier */
    readonly chat_id?: number,
    /** New value of client_data */
    readonly client_data?: string,
  }

  export type setChatDescription = {
    /**
     * Changes information about a chat. Available for basic groups, supergroups, and
     * channels. Requires can_change_info administrator right
     */
    readonly _: 'setChatDescription',
    /** Identifier of the chat */
    readonly chat_id?: number,
    /** New chat description; 0-255 characters */
    readonly description?: string,
  }

  export type setChatDiscussionGroup = {
    /**
     * Changes the discussion group of a channel chat; requires can_change_info administrator
     * right in the channel if it is specified
     */
    readonly _: 'setChatDiscussionGroup',
    /**
     * Identifier of the channel chat. Pass 0 to remove a link from the supergroup
     * passed in the second argument to a linked channel chat (requires can_pin_messages
     * rights in the supergroup)
     */
    readonly chat_id?: number,
    /**
     * Identifier of a new channel's discussion group. Use 0 to remove the discussion
     * group. Use the method getSuitableDiscussionChats to find all suitable groups.
     * Basic group chats must be first upgraded to supergroup chats. If new chat members
     * don't have access to old messages in the supergroup, then toggleSupergroupIsAllHistoryAvailable
     * must be used first to change that
     */
    readonly discussion_chat_id?: number,
  }

  export type setChatLocation = {
    /**
     * Changes the location of a chat. Available only for some location-based supergroups,
     * use supergroupFullInfo.can_set_location to check whether the method is allowed
     * to use
     */
    readonly _: 'setChatLocation',
    /** Chat identifier */
    readonly chat_id?: number,
    /** New location for the chat; must be valid and not null */
    readonly location?: chatLocation$Input,
  }

  export type setChatSlowModeDelay = {
    /**
     * Changes the slow mode delay of a chat. Available only for supergroups; requires
     * can_restrict_members rights
     */
    readonly _: 'setChatSlowModeDelay',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * New slow mode delay for the chat, in seconds; must be one of 0, 10, 30, 60,
     * 300, 900, 3600
     */
    readonly slow_mode_delay?: number,
  }

  export type pinChatMessage = {
    /**
     * Pins a message in a chat; requires can_pin_messages rights or can_edit_messages
     * rights in the channel
     */
    readonly _: 'pinChatMessage',
    /** Identifier of the chat */
    readonly chat_id?: number,
    /** Identifier of the new pinned message */
    readonly message_id?: number,
    /**
     * Pass true to disable notification about the pinned message. Notifications are
     * always disabled in channels and private chats
     */
    readonly disable_notification?: boolean,
    /** Pass true to pin the message only for self; private chats only */
    readonly only_for_self?: boolean,
  }

  export type unpinChatMessage = {
    /**
     * Removes a pinned message from a chat; requires can_pin_messages rights in the
     * group or can_edit_messages rights in the channel
     */
    readonly _: 'unpinChatMessage',
    /** Identifier of the chat */
    readonly chat_id?: number,
    /** Identifier of the removed pinned message */
    readonly message_id?: number,
  }

  export type unpinAllChatMessages = {
    /**
     * Removes all pinned messages from a chat; requires can_pin_messages rights in
     * the group or can_edit_messages rights in the channel
     */
    readonly _: 'unpinAllChatMessages',
    /** Identifier of the chat */
    readonly chat_id?: number,
  }

  export type unpinAllMessageThreadMessages = {
    /**
     * Removes all pinned messages from a forum topic; requires can_pin_messages rights
     * in the supergroup
     */
    readonly _: 'unpinAllMessageThreadMessages',
    /** Identifier of the chat */
    readonly chat_id?: number,
    /** Message thread identifier in which messages will be unpinned */
    readonly message_thread_id?: number,
  }

  export type joinChat = {
    /**
     * Adds the current user as a new member to a chat. Private and secret chats can't
     * be joined using this method. May return an error with a message "INVITE_REQUEST_SENT"
     * if only a join request was created
     */
    readonly _: 'joinChat',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type leaveChat = {
    /**
     * Removes the current user from chat members. Private and secret chats can't be
     * left using this method
     */
    readonly _: 'leaveChat',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type addChatMember = {
    /** Adds a new member to a chat. Members can't be added to private or secret chats */
    readonly _: 'addChatMember',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Identifier of the user */
    readonly user_id?: number,
    /**
     * The number of earlier messages from the chat to be forwarded to the new member;
     * up to 100. Ignored for supergroups and channels, or if the added user is a bot
     */
    readonly forward_limit?: number,
  }

  export type addChatMembers = {
    /**
     * Adds multiple new members to a chat. Currently, this method is only available
     * for supergroups and channels. This method can't be used to join a chat. Members
     * can't be added to a channel if it has more than 200 members
     */
    readonly _: 'addChatMembers',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * Identifiers of the users to be added to the chat. The maximum number of added
     * users is 20 for supergroups and 100 for channels
     */
    readonly user_ids?: ReadonlyArray<number>,
  }

  export type setChatMemberStatus = {
    /**
     * Changes the status of a chat member, needs appropriate privileges. This function
     * is currently not suitable for transferring chat ownership; use transferChatOwnership
     * instead. Use addChatMember or banChatMember if some additional parameters needs
     * to be passed
     */
    readonly _: 'setChatMemberStatus',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * Member identifier. Chats can be only banned and unbanned in supergroups and
     * channels
     */
    readonly member_id?: MessageSender$Input,
    /** The new status of the member in the chat */
    readonly status?: ChatMemberStatus$Input,
  }

  export type banChatMember = {
    /**
     * Bans a member in a chat. Members can't be banned in private or secret chats.
     * In supergroups and channels, the user will not be able to return to the group
     * on their own using invite links, etc., unless unbanned first
     */
    readonly _: 'banChatMember',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Member identifier */
    readonly member_id?: MessageSender$Input,
    /**
     * Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If
     * the user is banned for more than 366 days or for less than 30 seconds from the
     * current time, the user is considered to be banned forever. Ignored in basic
     * groups and if a chat is banned
     */
    readonly banned_until_date?: number,
    /**
     * Pass true to delete all messages in the chat for the user that is being removed.
     * Always true for supergroups and channels
     */
    readonly revoke_messages?: boolean,
  }

  export type canTransferOwnership = {
    /**
     * Checks whether the current session can be used to transfer a chat ownership
     * to another user
     */
    readonly _: 'canTransferOwnership',
  }

  export type transferChatOwnership = {
    /**
     * Changes the owner of a chat. The current user must be a current owner of the
     * chat. Use the method canTransferOwnership to check whether the ownership can
     * be transferred from the current session. Available only for supergroups and
     * channel chats
     */
    readonly _: 'transferChatOwnership',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * Identifier of the user to which transfer the ownership. The ownership can't
     * be transferred to a bot or to a deleted user
     */
    readonly user_id?: number,
    /** The 2-step verification password of the current user */
    readonly password?: string,
  }

  export type getChatMember = {
    /** Returns information about a single member of a chat */
    readonly _: 'getChatMember',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Member identifier */
    readonly member_id?: MessageSender$Input,
  }

  export type searchChatMembers = {
    /**
     * Searches for a specified query in the first name, last name and usernames of
     * the members of a specified chat. Requires administrator rights in channels
     */
    readonly _: 'searchChatMembers',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Query to search for */
    readonly query?: string,
    /** The maximum number of users to be returned; up to 200 */
    readonly limit?: number,
    /** The type of users to search for; pass null to search among all chat members */
    readonly filter?: ChatMembersFilter$Input,
  }

  export type getChatAdministrators = {
    /** Returns a list of administrators of the chat with their custom titles */
    readonly _: 'getChatAdministrators',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type clearAllDraftMessages = {
    /** Clears message drafts in all chats */
    readonly _: 'clearAllDraftMessages',
    /** Pass true to keep local message drafts in secret chats */
    readonly exclude_secret_chats?: boolean,
  }

  export type getSavedNotificationSound = {
    /**
     * Returns saved notification sound by its identifier. Returns a 404 error if there
     * is no saved notification sound with the specified identifier
     */
    readonly _: 'getSavedNotificationSound',
    /** Identifier of the notification sound */
    readonly notification_sound_id?: number | string,
  }

  export type getSavedNotificationSounds = {
    /**
     * Returns list of saved notification sounds. If a sound isn't in the list, then
     * default sound needs to be used
     */
    readonly _: 'getSavedNotificationSounds',
  }

  export type addSavedNotificationSound = {
    /**
     * Adds a new notification sound to the list of saved notification sounds. The
     * new notification sound is added to the top of the list. If it is already in
     * the list, its position isn't changed
     */
    readonly _: 'addSavedNotificationSound',
    /** Notification sound file to add */
    readonly sound?: InputFile$Input,
  }

  export type removeSavedNotificationSound = {
    /** Removes a notification sound from the list of saved notification sounds */
    readonly _: 'removeSavedNotificationSound',
    /** Identifier of the notification sound */
    readonly notification_sound_id?: number | string,
  }

  export type getChatNotificationSettingsExceptions = {
    /** Returns list of chats with non-default notification settings for new messages */
    readonly _: 'getChatNotificationSettingsExceptions',
    /**
     * If specified, only chats from the scope will be returned; pass null to return
     * chats from all scopes
     */
    readonly scope?: NotificationSettingsScope$Input,
    /** Pass true to include in the response chats with only non-default sound */
    readonly compare_sound?: boolean,
  }

  export type getScopeNotificationSettings = {
    /** Returns the notification settings for chats of a given type */
    readonly _: 'getScopeNotificationSettings',
    /** Types of chats for which to return the notification settings information */
    readonly scope?: NotificationSettingsScope$Input,
  }

  export type setScopeNotificationSettings = {
    /** Changes notification settings for chats of a given type */
    readonly _: 'setScopeNotificationSettings',
    /** Types of chats for which to change the notification settings */
    readonly scope?: NotificationSettingsScope$Input,
    /** The new notification settings for the given scope */
    readonly notification_settings?: scopeNotificationSettings$Input,
  }

  export type resetAllNotificationSettings = {
    /**
     * Resets all notification settings to their default values. By default, all chats
     * are unmuted and message previews are shown
     */
    readonly _: 'resetAllNotificationSettings',
  }

  export type toggleChatIsPinned = {
    /**
     * Changes the pinned state of a chat. There can be up to getOption("pinned_chat_count_max")/getOption("pinned_archived_chat_count_max")
     * pinned non-secret chats and the same number of secret chats in the main/archive
     * chat list. The limit can be increased with Telegram Premium
     */
    readonly _: 'toggleChatIsPinned',
    /** Chat list in which to change the pinned state of the chat */
    readonly chat_list?: ChatList$Input,
    /** Chat identifier */
    readonly chat_id?: number,
    /** Pass true to pin the chat; pass false to unpin it */
    readonly is_pinned?: boolean,
  }

  export type setPinnedChats = {
    /** Changes the order of pinned chats */
    readonly _: 'setPinnedChats',
    /** Chat list in which to change the order of pinned chats */
    readonly chat_list?: ChatList$Input,
    /** The new list of pinned chats */
    readonly chat_ids?: ReadonlyArray<number>,
  }

  export type readChatList = {
    /** Traverse all chats in a chat list and marks all messages in the chats as read */
    readonly _: 'readChatList',
    /** Chat list in which to mark all chats as read */
    readonly chat_list?: ChatList$Input,
  }

  export type getStory = {
    /** Returns a story */
    readonly _: 'getStory',
    /** Identifier of the chat that posted the story */
    readonly story_sender_chat_id?: number,
    /** Story identifier */
    readonly story_id?: number,
    /**
     * Pass true to get only locally available information without sending network
     * requests
     */
    readonly only_local?: boolean,
  }

  export type getChatsToSendStories = {
    /**
     * Returns channel chats in which the current user has the right to post stories.
     * The chats must be rechecked with canSendStory before actually trying to post
     * a story there
     */
    readonly _: 'getChatsToSendStories',
  }

  export type canSendStory = {
    /**
     * Checks whether the current user can send a story on behalf of a chat; requires
     * can_post_stories rights for channel chats
     */
    readonly _: 'canSendStory',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type sendStory = {
    /**
     * Sends a new story to a chat; requires can_post_stories rights for channel chats.
     * Returns a temporary story
     */
    readonly _: 'sendStory',
    /** Identifier of the chat that will post the story */
    readonly chat_id?: number,
    /** Content of the story */
    readonly content?: InputStoryContent$Input,
    /** Clickable rectangle areas to be shown on the story media; pass null if none */
    readonly areas?: inputStoryAreas$Input,
    /**
     * Story caption; pass null to use an empty caption; 0-getOption("story_caption_length_max")
     * characters
     */
    readonly caption?: formattedText$Input,
    /** The privacy settings for the story */
    readonly privacy_settings?: StoryPrivacySettings$Input,
    /**
     * Period after which the story is moved to archive, in seconds; must be one of
     * 6 * 3600, 12 * 3600, 86400, or 2 * 86400 for Telegram Premium users, and 86400
     * otherwise
     */
    readonly active_period?: number,
    /** Pass true to keep the story accessible after expiration */
    readonly is_pinned?: boolean,
    /**
     * Pass true if the content of the story must be protected from forwarding and
     * screenshotting
     */
    readonly protect_content?: boolean,
  }

  export type editStory = {
    /**
     * Changes content and caption of a story. Can be called only if story.can_be_edited
     * == true
     */
    readonly _: 'editStory',
    /** Identifier of the chat that posted the story */
    readonly story_sender_chat_id?: number,
    /** Identifier of the story to edit */
    readonly story_id?: number,
    /** New content of the story; pass null to keep the current content */
    readonly content?: InputStoryContent$Input,
    /**
     * New clickable rectangle areas to be shown on the story media; pass null to keep
     * the current areas. Areas can't be edited if story content isn't changed
     */
    readonly areas?: inputStoryAreas$Input,
    /** New story caption; pass null to keep the current caption */
    readonly caption?: formattedText$Input,
  }

  export type setStoryPrivacySettings = {
    /**
     * Changes privacy settings of a story. Can be called only if story.can_be_edited
     * == true
     */
    readonly _: 'setStoryPrivacySettings',
    /** Identifier of the chat that posted the story */
    readonly story_sender_chat_id?: number,
    /** Identifier of the story */
    readonly story_id?: number,
    /** The new privacy settigs for the story */
    readonly privacy_settings?: StoryPrivacySettings$Input,
  }

  export type toggleStoryIsPinned = {
    /**
     * Toggles whether a story is accessible after expiration. Can be called only if
     * story.can_toggle_is_pinned == true
     */
    readonly _: 'toggleStoryIsPinned',
    /** Identifier of the chat that posted the story */
    readonly story_sender_chat_id?: number,
    /** Identifier of the story */
    readonly story_id?: number,
    /**
     * Pass true to make the story accessible after expiration; pass false to make
     * it private
     */
    readonly is_pinned?: boolean,
  }

  export type deleteStory = {
    /**
     * Deletes a previously sent story. Can be called only if story.can_be_deleted
     * == true
     */
    readonly _: 'deleteStory',
    /** Identifier of the chat that posted the story */
    readonly story_sender_chat_id?: number,
    /** Identifier of the story to delete */
    readonly story_id?: number,
  }

  export type getStoryNotificationSettingsExceptions = {
    /** Returns list of chats with non-default notification settings for stories */
    readonly _: 'getStoryNotificationSettingsExceptions',
  }

  export type loadActiveStories = {
    /**
     * Loads more active stories from a story list. The loaded stories will be sent
     * through updates. Active stories are sorted by the pair (active_stories.order,
     * active_stories.story_sender_chat_id) in descending order. Returns a 404 error
     * if all active stories have been loaded
     */
    readonly _: 'loadActiveStories',
    /** The story list in which to load active stories */
    readonly story_list?: StoryList$Input,
  }

  export type setChatActiveStoriesList = {
    /** Changes story list in which stories from the chat are shown */
    readonly _: 'setChatActiveStoriesList',
    /** Identifier of the chat that posted stories */
    readonly chat_id?: number,
    /** New list for active stories posted by the chat */
    readonly story_list?: StoryList$Input,
  }

  export type getChatActiveStories = {
    /** Returns the list of active stories posted by the given chat */
    readonly _: 'getChatActiveStories',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type getChatPinnedStories = {
    /**
     * Returns the list of pinned stories posted by the given chat. The stories are
     * returned in a reverse chronological order (i.e., in order of decreasing story_id).
     * For optimal performance, the number of returned stories is chosen by TDLib
     */
    readonly _: 'getChatPinnedStories',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * Identifier of the story starting from which stories must be returned; use 0
     * to get results from the last story
     */
    readonly from_story_id?: number,
    /**
     * The maximum number of stories to be returned For optimal performance, the number
     * of returned stories is chosen by TDLib and can be smaller than the specified
     * limit
     */
    readonly limit?: number,
  }

  export type getChatArchivedStories = {
    /**
     * Returns the list of all stories posted by the given chat; requires can_edit_stories
     * rights for channel chats. The stories are returned in a reverse chronological
     * order (i.e., in order of decreasing story_id). For optimal performance, the
     * number of returned stories is chosen by TDLib
     */
    readonly _: 'getChatArchivedStories',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * Identifier of the story starting from which stories must be returned; use 0
     * to get results from the last story
     */
    readonly from_story_id?: number,
    /**
     * The maximum number of stories to be returned For optimal performance, the number
     * of returned stories is chosen by TDLib and can be smaller than the specified
     * limit
     */
    readonly limit?: number,
  }

  export type openStory = {
    /** Informs TDLib that a story is opened and is being viewed by the user */
    readonly _: 'openStory',
    /** The identifier of the sender of the opened story */
    readonly story_sender_chat_id?: number,
    /** The identifier of the story */
    readonly story_id?: number,
  }

  export type closeStory = {
    /** Informs TDLib that a story is closed by the user */
    readonly _: 'closeStory',
    /** The identifier of the sender of the story to close */
    readonly story_sender_chat_id?: number,
    /** The identifier of the story */
    readonly story_id?: number,
  }

  export type getStoryAvailableReactions = {
    /** Returns reactions, which can be chosen for a story */
    readonly _: 'getStoryAvailableReactions',
    /** Number of reaction per row, 5-25 */
    readonly row_size?: number,
  }

  export type setStoryReaction = {
    /** Changes chosen reaction on a story */
    readonly _: 'setStoryReaction',
    /** The identifier of the sender of the story */
    readonly story_sender_chat_id?: number,
    /** The identifier of the story */
    readonly story_id?: number,
    /**
     * Type of the reaction to set; pass null to remove the reaction. `reactionTypeCustomEmoji`
     * reactions can be used only by Telegram Premium users
     */
    readonly reaction_type?: ReactionType$Input,
    /** Pass true if the reaction needs to be added to recent reactions */
    readonly update_recent_reactions?: boolean,
  }

  export type getStoryViewers = {
    /**
     * Returns viewers of a story. The method can be called only for stories posted
     * on behalf of the current user
     */
    readonly _: 'getStoryViewers',
    /** Story identifier */
    readonly story_id?: number,
    /**
     * Query to search for in names and usernames of the viewers; may be empty to get
     * all relevant viewers
     */
    readonly query?: string,
    /** Pass true to get only contacts; pass false to get all relevant viewers */
    readonly only_contacts?: boolean,
    /**
     * Pass true to get viewers with reaction first; pass false to get viewers sorted
     * just by view_date
     */
    readonly prefer_with_reaction?: boolean,
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    readonly offset?: string,
    /** The maximum number of story viewers to return */
    readonly limit?: number,
  }

  export type reportStory = {
    /** Reports a story to the Telegram moderators */
    readonly _: 'reportStory',
    /** The identifier of the sender of the story to report */
    readonly story_sender_chat_id?: number,
    /** The identifier of the story to report */
    readonly story_id?: number,
    /** The reason for reporting the story */
    readonly reason?: ReportReason$Input,
    /** Additional report details; 0-1024 characters */
    readonly text?: string,
  }

  export type activateStoryStealthMode = {
    /**
     * Activates stealth mode for stories, which hides all views of stories from the
     * current user in the last "story_stealth_mode_past_period" seconds and for the
     * next "story_stealth_mode_future_period" seconds; for Telegram Premium users
     * only
     */
    readonly _: 'activateStoryStealthMode',
  }

  export type getChatBoostStatus = {
    /** Returns the current boost status for a channel chat */
    readonly _: 'getChatBoostStatus',
    /** Identifier of the channel chat */
    readonly chat_id?: number,
  }

  export type canBoostChat = {
    /** Checks whether the current user can boost a chat */
    readonly _: 'canBoostChat',
    /** Identifier of the chat */
    readonly chat_id?: number,
  }

  export type boostChat = {
    /** Boosts a chat */
    readonly _: 'boostChat',
    /** Identifier of the chat */
    readonly chat_id?: number,
  }

  export type getChatBoostLink = {
    /** Returns an HTTPS link to boost the specified channel chat */
    readonly _: 'getChatBoostLink',
    /** Identifier of the chat */
    readonly chat_id?: number,
  }

  export type getChatBoostLinkInfo = {
    /**
     * Returns information about a link to boost a chat. Can be called for any internal
     * link of the type internalLinkTypeChatBoost
     */
    readonly _: 'getChatBoostLinkInfo',
    /** The link to boost a chat */
    readonly url?: string,
  }

  export type getChatBoosts = {
    /**
     * Returns list of boosts applied to a chat. The user must be an administrator
     * in the channel chat to get the list of boosts
     */
    readonly _: 'getChatBoosts',
    /** Identifier of the chat */
    readonly chat_id?: number,
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    readonly offset?: string,
    /**
     * The maximum number of boosts to be returned; up to 100. For optimal performance,
     * the number of returned boosts can be smaller than the specified limit
     */
    readonly limit?: number,
  }

  export type getAttachmentMenuBot = {
    /** Returns information about a bot that can be added to attachment or side menu */
    readonly _: 'getAttachmentMenuBot',
    /** Bot's user identifier */
    readonly bot_user_id?: number,
  }

  export type toggleBotIsAddedToAttachmentMenu = {
    /**
     * Adds or removes a bot to attachment and side menu. Bot can be added to the menu,
     * only if userTypeBot.can_be_added_to_attachment_menu == true
     */
    readonly _: 'toggleBotIsAddedToAttachmentMenu',
    /** Bot's user identifier */
    readonly bot_user_id?: number,
    /**
     * Pass true to add the bot to attachment menu; pass false to remove the bot from
     * attachment menu
     */
    readonly is_added?: boolean,
    /**
     * Pass true if the current user allowed the bot to send them messages. Ignored
     * if is_added is false
     */
    readonly allow_write_access?: boolean,
  }

  export type getThemedEmojiStatuses = {
    /**
     * Returns up to 8 emoji statuses, which must be shown right after the default
     * Premium Badge in the emoji status list
     */
    readonly _: 'getThemedEmojiStatuses',
  }

  export type getRecentEmojiStatuses = {
    /** Returns recent emoji statuses */
    readonly _: 'getRecentEmojiStatuses',
  }

  export type getDefaultEmojiStatuses = {
    /** Returns default emoji statuses */
    readonly _: 'getDefaultEmojiStatuses',
  }

  export type clearRecentEmojiStatuses = {
    /** Clears the list of recently used emoji statuses */
    readonly _: 'clearRecentEmojiStatuses',
  }

  export type downloadFile = {
    /**
     * Downloads a file from the cloud. Download progress and completion of the download
     * will be notified through updateFile updates
     */
    readonly _: 'downloadFile',
    /** Identifier of the file to download */
    readonly file_id?: number,
    /**
     * Priority of the download (1-32). The higher the priority, the earlier the file
     * will be downloaded. If the priorities of two files are equal, then the last
     * one for which downloadFile/addFileToDownloads was called will be downloaded
     * first
     */
    readonly priority?: number,
    /** The starting position from which the file needs to be downloaded */
    readonly offset?: number,
    /**
     * Number of bytes which need to be downloaded starting from the "offset" position
     * before the download will automatically be canceled; use 0 to download without
     * a limit
     */
    readonly limit?: number,
    /**
     * Pass true to return response only after the file download has succeeded, has
     * failed, has been canceled, or a new downloadFile request with different offset/limit
     * parameters was sent; pass false to return file state immediately, just after
     * the download has been started
     */
    readonly synchronous?: boolean,
  }

  export type getFileDownloadedPrefixSize = {
    /** Returns file downloaded prefix size from a given offset, in bytes */
    readonly _: 'getFileDownloadedPrefixSize',
    /** Identifier of the file */
    readonly file_id?: number,
    /** Offset from which downloaded prefix size needs to be calculated */
    readonly offset?: number,
  }

  export type cancelDownloadFile = {
    /**
     * Stops the downloading of a file. If a file has already been downloaded, does
     * nothing
     */
    readonly _: 'cancelDownloadFile',
    /** Identifier of a file to stop downloading */
    readonly file_id?: number,
    /**
     * Pass true to stop downloading only if it hasn't been started, i.e. request hasn't
     * been sent to server
     */
    readonly only_if_pending?: boolean,
  }

  export type getSuggestedFileName = {
    /** Returns suggested name for saving a file in a given directory */
    readonly _: 'getSuggestedFileName',
    /** Identifier of the file */
    readonly file_id?: number,
    /** Directory in which the file is supposed to be saved */
    readonly directory?: string,
  }

  export type preliminaryUploadFile = {
    /**
     * Preliminary uploads a file to the cloud before sending it in a message, which
     * can be useful for uploading of being recorded voice and video notes. Updates
     * updateFile will be used to notify about upload progress and successful completion
     * of the upload. The file will not have a persistent remote identifier until it
     * will be sent in a message
     */
    readonly _: 'preliminaryUploadFile',
    /** File to upload */
    readonly file?: InputFile$Input,
    /** File type; pass null if unknown */
    readonly file_type?: FileType$Input,
    /**
     * Priority of the upload (1-32). The higher the priority, the earlier the file
     * will be uploaded. If the priorities of two files are equal, then the first one
     * for which preliminaryUploadFile was called will be uploaded first
     */
    readonly priority?: number,
  }

  export type cancelPreliminaryUploadFile = {
    /**
     * Stops the preliminary uploading of a file. Supported only for files uploaded
     * by using preliminaryUploadFile. For other files the behavior is undefined
     */
    readonly _: 'cancelPreliminaryUploadFile',
    /** Identifier of the file to stop uploading */
    readonly file_id?: number,
  }

  export type writeGeneratedFilePart = {
    /**
     * Writes a part of a generated file. This method is intended to be used only if
     * the application has no direct access to TDLib's file system, because it is usually
     * slower than a direct write to the destination file
     */
    readonly _: 'writeGeneratedFilePart',
    /** The identifier of the generation process */
    readonly generation_id?: number | string,
    /** The offset from which to write the data to the file */
    readonly offset?: number,
    /** The data to write */
    readonly data?: string,
  }

  export type setFileGenerationProgress = {
    /** Informs TDLib on a file generation progress */
    readonly _: 'setFileGenerationProgress',
    /** The identifier of the generation process */
    readonly generation_id?: number | string,
    /** Expected size of the generated file, in bytes; 0 if unknown */
    readonly expected_size?: number,
    /** The number of bytes already generated */
    readonly local_prefix_size?: number,
  }

  export type finishFileGeneration = {
    /** Finishes the file generation */
    readonly _: 'finishFileGeneration',
    /** The identifier of the generation process */
    readonly generation_id?: number | string,
    /**
     * If passed, the file generation has failed and must be terminated; pass null
     * if the file generation succeeded
     */
    readonly error?: error$Input,
  }

  export type readFilePart = {
    /**
     * Reads a part of a file from the TDLib file cache and returns read bytes. This
     * method is intended to be used only if the application has no direct access to
     * TDLib's file system, because it is usually slower than a direct read from the
     * file
     */
    readonly _: 'readFilePart',
    /** Identifier of the file. The file must be located in the TDLib file cache */
    readonly file_id?: number,
    /** The offset from which to read the file */
    readonly offset?: number,
    /**
     * Number of bytes to read. An error will be returned if there are not enough bytes
     * available in the file from the specified position. Pass 0 to read all available
     * data from the specified position
     */
    readonly count?: number,
  }

  export type deleteFile = {
    /** Deletes a file from the TDLib file cache */
    readonly _: 'deleteFile',
    /** Identifier of the file to delete */
    readonly file_id?: number,
  }

  export type addFileToDownloads = {
    /**
     * Adds a file from a message to the list of file downloads. Download progress
     * and completion of the download will be notified through updateFile updates.
     * If message database is used, the list of file downloads is persistent across
     * application restarts. The downloading is independent from download using downloadFile,
     * i.e. it continues if downloadFile is canceled or is used to download a part
     * of the file
     */
    readonly _: 'addFileToDownloads',
    /** Identifier of the file to download */
    readonly file_id?: number,
    /** Chat identifier of the message with the file */
    readonly chat_id?: number,
    /** Message identifier */
    readonly message_id?: number,
    /**
     * Priority of the download (1-32). The higher the priority, the earlier the file
     * will be downloaded. If the priorities of two files are equal, then the last
     * one for which downloadFile/addFileToDownloads was called will be downloaded
     * first
     */
    readonly priority?: number,
  }

  export type toggleDownloadIsPaused = {
    /** Changes pause state of a file in the file download list */
    readonly _: 'toggleDownloadIsPaused',
    /** Identifier of the downloaded file */
    readonly file_id?: number,
    /** Pass true if the download is paused */
    readonly is_paused?: boolean,
  }

  export type toggleAllDownloadsArePaused = {
    /** Changes pause state of all files in the file download list */
    readonly _: 'toggleAllDownloadsArePaused',
    /** Pass true to pause all downloads; pass false to unpause them */
    readonly are_paused?: boolean,
  }

  export type removeFileFromDownloads = {
    /** Removes a file from the file download list */
    readonly _: 'removeFileFromDownloads',
    /** Identifier of the downloaded file */
    readonly file_id?: number,
    /** Pass true to delete the file from the TDLib file cache */
    readonly delete_from_cache?: boolean,
  }

  export type removeAllFilesFromDownloads = {
    /** Removes all files from the file download list */
    readonly _: 'removeAllFilesFromDownloads',
    /** Pass true to remove only active downloads, including paused */
    readonly only_active?: boolean,
    /** Pass true to remove only completed downloads */
    readonly only_completed?: boolean,
    /** Pass true to delete the file from the TDLib file cache */
    readonly delete_from_cache?: boolean,
  }

  export type searchFileDownloads = {
    /**
     * Searches for files in the file download list or recently downloaded files from
     * the list
     */
    readonly _: 'searchFileDownloads',
    /** Query to search for; may be empty to return all downloaded files */
    readonly query?: string,
    /** Pass true to search only for active downloads, including paused */
    readonly only_active?: boolean,
    /** Pass true to search only for completed downloads */
    readonly only_completed?: boolean,
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get the first chunk of results
     */
    readonly offset?: string,
    /** The maximum number of files to be returned */
    readonly limit?: number,
  }

  export type getMessageFileType = {
    /** Returns information about a file with messages exported from another application */
    readonly _: 'getMessageFileType',
    /** Beginning of the message file; up to 100 first lines */
    readonly message_file_head?: string,
  }

  export type getMessageImportConfirmationText = {
    /**
     * Returns a confirmation text to be shown to the user before starting message
     * import
     */
    readonly _: 'getMessageImportConfirmationText',
    /**
     * Identifier of a chat to which the messages will be imported. It must be an identifier
     * of a private chat with a mutual contact or an identifier of a supergroup chat
     * with can_change_info administrator right
     */
    readonly chat_id?: number,
  }

  export type importMessages = {
    /** Imports messages exported from another app */
    readonly _: 'importMessages',
    /**
     * Identifier of a chat to which the messages will be imported. It must be an identifier
     * of a private chat with a mutual contact or an identifier of a supergroup chat
     * with can_change_info administrator right
     */
    readonly chat_id?: number,
    /**
     * File with messages to import. Only inputFileLocal and inputFileGenerated are
     * supported. The file must not be previously uploaded
     */
    readonly message_file?: InputFile$Input,
    /**
     * Files used in the imported messages. Only inputFileLocal and inputFileGenerated
     * are supported. The files must not be previously uploaded
     */
    readonly attached_files?: ReadonlyArray<InputFile$Input>,
  }

  export type replacePrimaryChatInviteLink = {
    /**
     * Replaces current primary invite link for a chat with a new primary invite link.
     * Available for basic groups, supergroups, and channels. Requires administrator
     * privileges and can_invite_users right
     */
    readonly _: 'replacePrimaryChatInviteLink',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type createChatInviteLink = {
    /**
     * Creates a new invite link for a chat. Available for basic groups, supergroups,
     * and channels. Requires administrator privileges and can_invite_users right in
     * the chat
     */
    readonly _: 'createChatInviteLink',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Invite link name; 0-32 characters */
    readonly name?: string,
    /** Point in time (Unix timestamp) when the link will expire; pass 0 if never */
    readonly expiration_date?: number,
    /**
     * The maximum number of chat members that can join the chat via the link simultaneously;
     * 0-99999; pass 0 if not limited
     */
    readonly member_limit?: number,
    /**
     * Pass true if users joining the chat via the link need to be approved by chat
     * administrators. In this case, member_limit must be 0
     */
    readonly creates_join_request?: boolean,
  }

  export type editChatInviteLink = {
    /**
     * Edits a non-primary invite link for a chat. Available for basic groups, supergroups,
     * and channels. Requires administrator privileges and can_invite_users right in
     * the chat for own links and owner privileges for other links
     */
    readonly _: 'editChatInviteLink',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Invite link to be edited */
    readonly invite_link?: string,
    /** Invite link name; 0-32 characters */
    readonly name?: string,
    /** Point in time (Unix timestamp) when the link will expire; pass 0 if never */
    readonly expiration_date?: number,
    /**
     * The maximum number of chat members that can join the chat via the link simultaneously;
     * 0-99999; pass 0 if not limited
     */
    readonly member_limit?: number,
    /**
     * Pass true if users joining the chat via the link need to be approved by chat
     * administrators. In this case, member_limit must be 0
     */
    readonly creates_join_request?: boolean,
  }

  export type getChatInviteLink = {
    /**
     * Returns information about an invite link. Requires administrator privileges
     * and can_invite_users right in the chat to get own links and owner privileges
     * to get other links
     */
    readonly _: 'getChatInviteLink',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Invite link to get */
    readonly invite_link?: string,
  }

  export type getChatInviteLinkCounts = {
    /**
     * Returns list of chat administrators with number of their invite links. Requires
     * owner privileges in the chat
     */
    readonly _: 'getChatInviteLinkCounts',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type getChatInviteLinks = {
    /**
     * Returns invite links for a chat created by specified administrator. Requires
     * administrator privileges and can_invite_users right in the chat to get own links
     * and owner privileges to get other links
     */
    readonly _: 'getChatInviteLinks',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * User identifier of a chat administrator. Must be an identifier of the current
     * user for non-owner
     */
    readonly creator_user_id?: number,
    /** Pass true if revoked links needs to be returned instead of active or expired */
    readonly is_revoked?: boolean,
    /**
     * Creation date of an invite link starting after which to return invite links;
     * use 0 to get results from the beginning
     */
    readonly offset_date?: number,
    /**
     * Invite link starting after which to return invite links; use empty string to
     * get results from the beginning
     */
    readonly offset_invite_link?: string,
    /** The maximum number of invite links to return; up to 100 */
    readonly limit?: number,
  }

  export type getChatInviteLinkMembers = {
    /**
     * Returns chat members joined a chat via an invite link. Requires administrator
     * privileges and can_invite_users right in the chat for own links and owner privileges
     * for other links
     */
    readonly _: 'getChatInviteLinkMembers',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Invite link for which to return chat members */
    readonly invite_link?: string,
    /**
     * A chat member from which to return next chat members; pass null to get results
     * from the beginning
     */
    readonly offset_member?: chatInviteLinkMember$Input,
    /** The maximum number of chat members to return; up to 100 */
    readonly limit?: number,
  }

  export type revokeChatInviteLink = {
    /**
     * Revokes invite link for a chat. Available for basic groups, supergroups, and
     * channels. Requires administrator privileges and can_invite_users right in the
     * chat for own links and owner privileges for other links. If a primary link is
     * revoked, then additionally to the revoked link returns new primary link
     */
    readonly _: 'revokeChatInviteLink',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Invite link to be revoked */
    readonly invite_link?: string,
  }

  export type deleteRevokedChatInviteLink = {
    /**
     * Deletes revoked chat invite links. Requires administrator privileges and can_invite_users
     * right in the chat for own links and owner privileges for other links
     */
    readonly _: 'deleteRevokedChatInviteLink',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Invite link to revoke */
    readonly invite_link?: string,
  }

  export type deleteAllRevokedChatInviteLinks = {
    /**
     * Deletes all revoked chat invite links created by a given chat administrator.
     * Requires administrator privileges and can_invite_users right in the chat for
     * own links and owner privileges for other links
     */
    readonly _: 'deleteAllRevokedChatInviteLinks',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * User identifier of a chat administrator, which links will be deleted. Must be
     * an identifier of the current user for non-owner
     */
    readonly creator_user_id?: number,
  }

  export type checkChatInviteLink = {
    /**
     * Checks the validity of an invite link for a chat and returns information about
     * the corresponding chat
     */
    readonly _: 'checkChatInviteLink',
    /** Invite link to be checked */
    readonly invite_link?: string,
  }

  export type joinChatByInviteLink = {
    /**
     * Uses an invite link to add the current user to the chat if possible. May return
     * an error with a message "INVITE_REQUEST_SENT" if only a join request was created
     */
    readonly _: 'joinChatByInviteLink',
    /** Invite link to use */
    readonly invite_link?: string,
  }

  export type getChatJoinRequests = {
    /** Returns pending join requests in a chat */
    readonly _: 'getChatJoinRequests',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * Invite link for which to return join requests. If empty, all join requests will
     * be returned. Requires administrator privileges and can_invite_users right in
     * the chat for own links and owner privileges for other links
     */
    readonly invite_link?: string,
    /**
     * A query to search for in the first names, last names and usernames of the users
     * to return
     */
    readonly query?: string,
    /**
     * A chat join request from which to return next requests; pass null to get results
     * from the beginning
     */
    readonly offset_request?: chatJoinRequest$Input,
    /** The maximum number of requests to join the chat to return */
    readonly limit?: number,
  }

  export type processChatJoinRequest = {
    /** Handles a pending join request in a chat */
    readonly _: 'processChatJoinRequest',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Identifier of the user that sent the request */
    readonly user_id?: number,
    /** Pass true to approve the request; pass false to decline it */
    readonly approve?: boolean,
  }

  export type processChatJoinRequests = {
    /** Handles all pending join requests for a given link in a chat */
    readonly _: 'processChatJoinRequests',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * Invite link for which to process join requests. If empty, all join requests
     * will be processed. Requires administrator privileges and can_invite_users right
     * in the chat for own links and owner privileges for other links
     */
    readonly invite_link?: string,
    /** Pass true to approve all requests; pass false to decline them */
    readonly approve?: boolean,
  }

  export type createCall = {
    /** Creates a new call */
    readonly _: 'createCall',
    /** Identifier of the user to be called */
    readonly user_id?: number,
    /** The call protocols supported by the application */
    readonly protocol?: callProtocol$Input,
    /** Pass true to create a video call */
    readonly is_video?: boolean,
  }

  export type acceptCall = {
    /** Accepts an incoming call */
    readonly _: 'acceptCall',
    /** Call identifier */
    readonly call_id?: number,
    /** The call protocols supported by the application */
    readonly protocol?: callProtocol$Input,
  }

  export type sendCallSignalingData = {
    /** Sends call signaling data */
    readonly _: 'sendCallSignalingData',
    /** Call identifier */
    readonly call_id?: number,
    /** The data */
    readonly data?: string,
  }

  export type discardCall = {
    /** Discards a call */
    readonly _: 'discardCall',
    /** Call identifier */
    readonly call_id?: number,
    /** Pass true if the user was disconnected */
    readonly is_disconnected?: boolean,
    /** The call duration, in seconds */
    readonly duration?: number,
    /** Pass true if the call was a video call */
    readonly is_video?: boolean,
    /** Identifier of the connection used during the call */
    readonly connection_id?: number | string,
  }

  export type sendCallRating = {
    /** Sends a call rating */
    readonly _: 'sendCallRating',
    /** Call identifier */
    readonly call_id?: number,
    /** Call rating; 1-5 */
    readonly rating?: number,
    /** An optional user comment if the rating is less than 5 */
    readonly comment?: string,
    /** List of the exact types of problems with the call, specified by the user */
    readonly problems?: ReadonlyArray<CallProblem$Input>,
  }

  export type sendCallDebugInformation = {
    /** Sends debug information for a call to Telegram servers */
    readonly _: 'sendCallDebugInformation',
    /** Call identifier */
    readonly call_id?: number,
    /** Debug information in application-specific format */
    readonly debug_information?: string,
  }

  export type sendCallLog = {
    /** Sends log file for a call to Telegram servers */
    readonly _: 'sendCallLog',
    /** Call identifier */
    readonly call_id?: number,
    /** Call log file. Only inputFileLocal and inputFileGenerated are supported */
    readonly log_file?: InputFile$Input,
  }

  export type getVideoChatAvailableParticipants = {
    /**
     * Returns list of participant identifiers, on whose behalf a video chat in the
     * chat can be joined
     */
    readonly _: 'getVideoChatAvailableParticipants',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type setVideoChatDefaultParticipant = {
    /**
     * Changes default participant identifier, on whose behalf a video chat in the
     * chat will be joined
     */
    readonly _: 'setVideoChatDefaultParticipant',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Default group call participant identifier to join the video chats */
    readonly default_participant_id?: MessageSender$Input,
  }

  export type createVideoChat = {
    /**
     * Creates a video chat (a group call bound to a chat). Available only for basic
     * groups, supergroups and channels; requires can_manage_video_chats rights
     */
    readonly _: 'createVideoChat',
    /** Identifier of a chat in which the video chat will be created */
    readonly chat_id?: number,
    /** Group call title; if empty, chat title will be used */
    readonly title?: string,
    /**
     * Point in time (Unix timestamp) when the group call is supposed to be started
     * by an administrator; 0 to start the video chat immediately. The date must be
     * at least 10 seconds and at most 8 days in the future
     */
    readonly start_date?: number,
    /**
     * Pass true to create an RTMP stream instead of an ordinary video chat; requires
     * creator privileges
     */
    readonly is_rtmp_stream?: boolean,
  }

  export type getVideoChatRtmpUrl = {
    /** Returns RTMP URL for streaming to the chat; requires creator privileges */
    readonly _: 'getVideoChatRtmpUrl',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type replaceVideoChatRtmpUrl = {
    /** Replaces the current RTMP URL for streaming to the chat; requires creator privileges */
    readonly _: 'replaceVideoChatRtmpUrl',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type getGroupCall = {
    /** Returns information about a group call */
    readonly _: 'getGroupCall',
    /** Group call identifier */
    readonly group_call_id?: number,
  }

  export type startScheduledGroupCall = {
    /** Starts a scheduled group call */
    readonly _: 'startScheduledGroupCall',
    /** Group call identifier */
    readonly group_call_id?: number,
  }

  export type toggleGroupCallEnabledStartNotification = {
    /**
     * Toggles whether the current user will receive a notification when the group
     * call will start; scheduled group calls only
     */
    readonly _: 'toggleGroupCallEnabledStartNotification',
    /** Group call identifier */
    readonly group_call_id?: number,
    /** New value of the enabled_start_notification setting */
    readonly enabled_start_notification?: boolean,
  }

  export type joinGroupCall = {
    /** Joins an active group call. Returns join response payload for tgcalls */
    readonly _: 'joinGroupCall',
    /** Group call identifier */
    readonly group_call_id?: number,
    /**
     * Identifier of a group call participant, which will be used to join the call;
     * pass null to join as self; video chats only
     */
    readonly participant_id?: MessageSender$Input,
    /** Caller audio channel synchronization source identifier; received from tgcalls */
    readonly audio_source_id?: number,
    /** Group call join payload; received from tgcalls */
    readonly payload?: string,
    /** Pass true to join the call with muted microphone */
    readonly is_muted?: boolean,
    /** Pass true if the user's video is enabled */
    readonly is_my_video_enabled?: boolean,
    /**
     * If non-empty, invite hash to be used to join the group call without being muted
     * by administrators
     */
    readonly invite_hash?: string,
  }

  export type startGroupCallScreenSharing = {
    /**
     * Starts screen sharing in a joined group call. Returns join response payload
     * for tgcalls
     */
    readonly _: 'startGroupCallScreenSharing',
    /** Group call identifier */
    readonly group_call_id?: number,
    /**
     * Screen sharing audio channel synchronization source identifier; received from
     * tgcalls
     */
    readonly audio_source_id?: number,
    /** Group call join payload; received from tgcalls */
    readonly payload?: string,
  }

  export type toggleGroupCallScreenSharingIsPaused = {
    /** Pauses or unpauses screen sharing in a joined group call */
    readonly _: 'toggleGroupCallScreenSharingIsPaused',
    /** Group call identifier */
    readonly group_call_id?: number,
    /** Pass true to pause screen sharing; pass false to unpause it */
    readonly is_paused?: boolean,
  }

  export type endGroupCallScreenSharing = {
    /** Ends screen sharing in a joined group call */
    readonly _: 'endGroupCallScreenSharing',
    /** Group call identifier */
    readonly group_call_id?: number,
  }

  export type setGroupCallTitle = {
    /** Sets group call title. Requires groupCall.can_be_managed group call flag */
    readonly _: 'setGroupCallTitle',
    /** Group call identifier */
    readonly group_call_id?: number,
    /** New group call title; 1-64 characters */
    readonly title?: string,
  }

  export type toggleGroupCallMuteNewParticipants = {
    /**
     * Toggles whether new participants of a group call can be unmuted only by administrators
     * of the group call. Requires groupCall.can_toggle_mute_new_participants group
     * call flag
     */
    readonly _: 'toggleGroupCallMuteNewParticipants',
    /** Group call identifier */
    readonly group_call_id?: number,
    /** New value of the mute_new_participants setting */
    readonly mute_new_participants?: boolean,
  }

  export type inviteGroupCallParticipants = {
    /**
     * Invites users to an active group call. Sends a service message of type messageInviteVideoChatParticipants
     * for video chats
     */
    readonly _: 'inviteGroupCallParticipants',
    /** Group call identifier */
    readonly group_call_id?: number,
    /** User identifiers. At most 10 users can be invited simultaneously */
    readonly user_ids?: ReadonlyArray<number>,
  }

  export type getGroupCallInviteLink = {
    /** Returns invite link to a video chat in a public chat */
    readonly _: 'getGroupCallInviteLink',
    /** Group call identifier */
    readonly group_call_id?: number,
    /**
     * Pass true if the invite link needs to contain an invite hash, passing which
     * to joinGroupCall would allow the invited user to unmute themselves. Requires
     * groupCall.can_be_managed group call flag
     */
    readonly can_self_unmute?: boolean,
  }

  export type revokeGroupCallInviteLink = {
    /**
     * Revokes invite link for a group call. Requires groupCall.can_be_managed group
     * call flag
     */
    readonly _: 'revokeGroupCallInviteLink',
    /** Group call identifier */
    readonly group_call_id?: number,
  }

  export type startGroupCallRecording = {
    /**
     * Starts recording of an active group call. Requires groupCall.can_be_managed
     * group call flag
     */
    readonly _: 'startGroupCallRecording',
    /** Group call identifier */
    readonly group_call_id?: number,
    /** Group call recording title; 0-64 characters */
    readonly title?: string,
    /** Pass true to record a video file instead of an audio file */
    readonly record_video?: boolean,
    /** Pass true to use portrait orientation for video instead of landscape one */
    readonly use_portrait_orientation?: boolean,
  }

  export type endGroupCallRecording = {
    /**
     * Ends recording of an active group call. Requires groupCall.can_be_managed group
     * call flag
     */
    readonly _: 'endGroupCallRecording',
    /** Group call identifier */
    readonly group_call_id?: number,
  }

  export type toggleGroupCallIsMyVideoPaused = {
    /** Toggles whether current user's video is paused */
    readonly _: 'toggleGroupCallIsMyVideoPaused',
    /** Group call identifier */
    readonly group_call_id?: number,
    /** Pass true if the current user's video is paused */
    readonly is_my_video_paused?: boolean,
  }

  export type toggleGroupCallIsMyVideoEnabled = {
    /** Toggles whether current user's video is enabled */
    readonly _: 'toggleGroupCallIsMyVideoEnabled',
    /** Group call identifier */
    readonly group_call_id?: number,
    /** Pass true if the current user's video is enabled */
    readonly is_my_video_enabled?: boolean,
  }

  export type setGroupCallParticipantIsSpeaking = {
    /** Informs TDLib that speaking state of a participant of an active group has changed */
    readonly _: 'setGroupCallParticipantIsSpeaking',
    /** Group call identifier */
    readonly group_call_id?: number,
    /**
     * Group call participant's synchronization audio source identifier, or 0 for the
     * current user
     */
    readonly audio_source?: number,
    /** Pass true if the user is speaking */
    readonly is_speaking?: boolean,
  }

  export type toggleGroupCallParticipantIsMuted = {
    /**
     * Toggles whether a participant of an active group call is muted, unmuted, or
     * allowed to unmute themselves
     */
    readonly _: 'toggleGroupCallParticipantIsMuted',
    /** Group call identifier */
    readonly group_call_id?: number,
    /** Participant identifier */
    readonly participant_id?: MessageSender$Input,
    /** Pass true to mute the user; pass false to unmute them */
    readonly is_muted?: boolean,
  }

  export type setGroupCallParticipantVolumeLevel = {
    /**
     * Changes volume level of a participant of an active group call. If the current
     * user can manage the group call, then the participant's volume level will be
     * changed for all users with the default volume level
     */
    readonly _: 'setGroupCallParticipantVolumeLevel',
    /** Group call identifier */
    readonly group_call_id?: number,
    /** Participant identifier */
    readonly participant_id?: MessageSender$Input,
    /** New participant's volume level; 1-20000 in hundreds of percents */
    readonly volume_level?: number,
  }

  export type toggleGroupCallParticipantIsHandRaised = {
    /** Toggles whether a group call participant hand is rased */
    readonly _: 'toggleGroupCallParticipantIsHandRaised',
    /** Group call identifier */
    readonly group_call_id?: number,
    /** Participant identifier */
    readonly participant_id?: MessageSender$Input,
    /**
     * Pass true if the user's hand needs to be raised. Only self hand can be raised.
     * Requires groupCall.can_be_managed group call flag to lower other's hand
     */
    readonly is_hand_raised?: boolean,
  }

  export type loadGroupCallParticipants = {
    /**
     * Loads more participants of a group call. The loaded participants will be received
     * through updates. Use the field groupCall.loaded_all_participants to check whether
     * all participants have already been loaded
     */
    readonly _: 'loadGroupCallParticipants',
    /**
     * Group call identifier. The group call must be previously received through getGroupCall
     * and must be joined or being joined
     */
    readonly group_call_id?: number,
    /** The maximum number of participants to load; up to 100 */
    readonly limit?: number,
  }

  export type leaveGroupCall = {
    /** Leaves a group call */
    readonly _: 'leaveGroupCall',
    /** Group call identifier */
    readonly group_call_id?: number,
  }

  export type endGroupCall = {
    /** Ends a group call. Requires groupCall.can_be_managed */
    readonly _: 'endGroupCall',
    /** Group call identifier */
    readonly group_call_id?: number,
  }

  export type getGroupCallStreams = {
    /** Returns information about available group call streams */
    readonly _: 'getGroupCallStreams',
    /** Group call identifier */
    readonly group_call_id?: number,
  }

  export type getGroupCallStreamSegment = {
    /**
     * Returns a file with a segment of a group call stream in a modified OGG format
     * for audio or MPEG-4 format for video
     */
    readonly _: 'getGroupCallStreamSegment',
    /** Group call identifier */
    readonly group_call_id?: number,
    /** Point in time when the stream segment begins; Unix timestamp in milliseconds */
    readonly time_offset?: number,
    /** Segment duration scale; 0-1. Segment's duration is 1000/(2**scale) milliseconds */
    readonly scale?: number,
    /** Identifier of an audio/video channel to get as received from tgcalls */
    readonly channel_id?: number,
    /**
     * Video quality as received from tgcalls; pass null to get the worst available
     * quality
     */
    readonly video_quality?: GroupCallVideoQuality$Input,
  }

  export type setMessageSenderBlockList = {
    /**
     * Changes the block list of a message sender. Currently, only users and supergroup
     * chats can be blocked
     */
    readonly _: 'setMessageSenderBlockList',
    /** Identifier of a message sender to block/unblock */
    readonly sender_id?: MessageSender$Input,
    /** New block list for the message sender; pass null to unblock the message sender */
    readonly block_list?: BlockList$Input,
  }

  export type blockMessageSenderFromReplies = {
    /** Blocks an original sender of a message in the Replies chat */
    readonly _: 'blockMessageSenderFromReplies',
    /** The identifier of an incoming message in the Replies chat */
    readonly message_id?: number,
    /** Pass true to delete the message */
    readonly delete_message?: boolean,
    /** Pass true to delete all messages from the same sender */
    readonly delete_all_messages?: boolean,
    /** Pass true to report the sender to the Telegram moderators */
    readonly report_spam?: boolean,
  }

  export type getBlockedMessageSenders = {
    /** Returns users and chats that were blocked by the current user */
    readonly _: 'getBlockedMessageSenders',
    /** Block list from which to return users */
    readonly block_list?: BlockList$Input,
    /** Number of users and chats to skip in the result; must be non-negative */
    readonly offset?: number,
    /** The maximum number of users and chats to return; up to 100 */
    readonly limit?: number,
  }

  export type addContact = {
    /** Adds a user to the contact list or edits an existing contact by their user identifier */
    readonly _: 'addContact',
    /**
     * The contact to add or edit; phone number may be empty and needs to be specified
     * only if known, vCard is ignored
     */
    readonly contact?: contact$Input,
    /**
     * Pass true to share the current user's phone number with the new contact. A corresponding
     * rule to userPrivacySettingShowPhoneNumber will be added if needed. Use the field
     * userFullInfo.need_phone_number_privacy_exception to check whether the current
     * user needs to be asked to share their phone number
     */
    readonly share_phone_number?: boolean,
  }

  export type importContacts = {
    /**
     * Adds new contacts or edits existing contacts by their phone numbers; contacts'
     * user identifiers are ignored
     */
    readonly _: 'importContacts',
    /**
     * The list of contacts to import or edit; contacts' vCard are ignored and are
     * not imported
     */
    readonly contacts?: ReadonlyArray<contact$Input>,
  }

  export type getContacts = {
    /** Returns all contacts of the user */
    readonly _: 'getContacts',
  }

  export type searchContacts = {
    /**
     * Searches for the specified query in the first names, last names and usernames
     * of the known user contacts
     */
    readonly _: 'searchContacts',
    /** Query to search for; may be empty to return all contacts */
    readonly query?: string,
    /** The maximum number of users to be returned */
    readonly limit?: number,
  }

  export type removeContacts = {
    /** Removes users from the contact list */
    readonly _: 'removeContacts',
    /** Identifiers of users to be deleted */
    readonly user_ids?: ReadonlyArray<number>,
  }

  export type getImportedContactCount = {
    /** Returns the total number of imported contacts */
    readonly _: 'getImportedContactCount',
  }

  export type changeImportedContacts = {
    /**
     * Changes imported contacts using the list of contacts saved on the device. Imports
     * newly added contacts and, if at least the file database is enabled, deletes
     * recently deleted contacts. Query result depends on the result of the previous
     * query, so only one query is possible at the same time
     */
    readonly _: 'changeImportedContacts',
    /** The new list of contacts, contact's vCard are ignored and are not imported */
    readonly contacts?: ReadonlyArray<contact$Input>,
  }

  export type clearImportedContacts = {
    /** Clears all imported contacts, contact list remains unchanged */
    readonly _: 'clearImportedContacts',
  }

  export type setCloseFriends = {
    /** Changes the list of close friends of the current user */
    readonly _: 'setCloseFriends',
    /**
     * User identifiers of close friends; the users must be contacts of the current
     * user
     */
    readonly user_ids?: ReadonlyArray<number>,
  }

  export type getCloseFriends = {
    /** Returns all close friends of the current user */
    readonly _: 'getCloseFriends',
  }

  export type setUserPersonalProfilePhoto = {
    /** Changes a personal profile photo of a contact user */
    readonly _: 'setUserPersonalProfilePhoto',
    /** User identifier */
    readonly user_id?: number,
    /**
     * Profile photo to set; pass null to delete the photo; inputChatPhotoPrevious
     * isn't supported in this function
     */
    readonly photo?: InputChatPhoto$Input,
  }

  export type suggestUserProfilePhoto = {
    /** Suggests a profile photo to another regular user with common messages */
    readonly _: 'suggestUserProfilePhoto',
    /** User identifier */
    readonly user_id?: number,
    /** Profile photo to suggest; inputChatPhotoPrevious isn't supported in this function */
    readonly photo?: InputChatPhoto$Input,
  }

  export type searchUserByPhoneNumber = {
    /**
     * Searches a user by their phone number. Returns a 404 error if the user can't
     * be found
     */
    readonly _: 'searchUserByPhoneNumber',
    /** Phone number to search for */
    readonly phone_number?: string,
  }

  export type sharePhoneNumber = {
    /**
     * Shares the phone number of the current user with a mutual contact. Supposed
     * to be called when the user clicks on chatActionBarSharePhoneNumber
     */
    readonly _: 'sharePhoneNumber',
    /**
     * Identifier of the user with whom to share the phone number. The user must be
     * a mutual contact
     */
    readonly user_id?: number,
  }

  export type getUserProfilePhotos = {
    /** Returns the profile photos of a user. Personal and public photo aren't returned */
    readonly _: 'getUserProfilePhotos',
    /** User identifier */
    readonly user_id?: number,
    /** The number of photos to skip; must be non-negative */
    readonly offset?: number,
    /** The maximum number of photos to be returned; up to 100 */
    readonly limit?: number,
  }

  export type getStickers = {
    /**
     * Returns stickers from the installed sticker sets that correspond to any of the
     * given emoji or can be found by sticker-specific keywords. If the query is non-empty,
     * then favorite, recently used or trending stickers may also be returned
     */
    readonly _: 'getStickers',
    /** Type of the stickers to return */
    readonly sticker_type?: StickerType$Input,
    /**
     * Search query; a space-separated list of emoji or a keyword prefix. If empty,
     * returns all known installed stickers
     */
    readonly query?: string,
    /** The maximum number of stickers to be returned */
    readonly limit?: number,
    /**
     * Chat identifier for which to return stickers. Available custom emoji stickers
     * may be different for different chats
     */
    readonly chat_id?: number,
  }

  export type getAllStickerEmojis = {
    /**
     * Returns unique emoji that correspond to stickers to be found by the getStickers(sticker_type,
     * query, 1000000, chat_id)
     */
    readonly _: 'getAllStickerEmojis',
    /** Type of the stickers to search for */
    readonly sticker_type?: StickerType$Input,
    /** Search query */
    readonly query?: string,
    /** Chat identifier for which to find stickers */
    readonly chat_id?: number,
    /**
     * Pass true if only main emoji for each found sticker must be included in the
     * result
     */
    readonly return_only_main_emoji?: boolean,
  }

  export type searchStickers = {
    /**
     * Searches for stickers from public sticker sets that correspond to any of the
     * given emoji
     */
    readonly _: 'searchStickers',
    /** Type of the stickers to return */
    readonly sticker_type?: StickerType$Input,
    /** Space-separated list of emoji to search for; must be non-empty */
    readonly emojis?: string,
    /** The maximum number of stickers to be returned; 0-100 */
    readonly limit?: number,
  }

  export type getPremiumStickers = {
    /** Returns premium stickers from regular sticker sets */
    readonly _: 'getPremiumStickers',
    /** The maximum number of stickers to be returned; 0-100 */
    readonly limit?: number,
  }

  export type getInstalledStickerSets = {
    /** Returns a list of installed sticker sets */
    readonly _: 'getInstalledStickerSets',
    /** Type of the sticker sets to return */
    readonly sticker_type?: StickerType$Input,
  }

  export type getArchivedStickerSets = {
    /** Returns a list of archived sticker sets */
    readonly _: 'getArchivedStickerSets',
    /** Type of the sticker sets to return */
    readonly sticker_type?: StickerType$Input,
    /** Identifier of the sticker set from which to return the result */
    readonly offset_sticker_set_id?: number | string,
    /** The maximum number of sticker sets to return; up to 100 */
    readonly limit?: number,
  }

  export type getTrendingStickerSets = {
    /**
     * Returns a list of trending sticker sets. For optimal performance, the number
     * of returned sticker sets is chosen by TDLib
     */
    readonly _: 'getTrendingStickerSets',
    /** Type of the sticker sets to return */
    readonly sticker_type?: StickerType$Input,
    /** The offset from which to return the sticker sets; must be non-negative */
    readonly offset?: number,
    /**
     * The maximum number of sticker sets to be returned; up to 100. For optimal performance,
     * the number of returned sticker sets is chosen by TDLib and can be smaller than
     * the specified limit, even if the end of the list has not been reached
     */
    readonly limit?: number,
  }

  export type getAttachedStickerSets = {
    /**
     * Returns a list of sticker sets attached to a file, including regular, mask,
     * and emoji sticker sets. Currently, only animations, photos, and videos can have
     * attached sticker sets
     */
    readonly _: 'getAttachedStickerSets',
    /** File identifier */
    readonly file_id?: number,
  }

  export type getStickerSet = {
    /** Returns information about a sticker set by its identifier */
    readonly _: 'getStickerSet',
    /** Identifier of the sticker set */
    readonly set_id?: number | string,
  }

  export type searchStickerSet = {
    /** Searches for a sticker set by its name */
    readonly _: 'searchStickerSet',
    /** Name of the sticker set */
    readonly name?: string,
  }

  export type searchInstalledStickerSets = {
    /**
     * Searches for installed sticker sets by looking for specified query in their
     * title and name
     */
    readonly _: 'searchInstalledStickerSets',
    /** Type of the sticker sets to search for */
    readonly sticker_type?: StickerType$Input,
    /** Query to search for */
    readonly query?: string,
    /** The maximum number of sticker sets to return */
    readonly limit?: number,
  }

  export type searchStickerSets = {
    /**
     * Searches for ordinary sticker sets by looking for specified query in their title
     * and name. Excludes installed sticker sets from the results
     */
    readonly _: 'searchStickerSets',
    /** Query to search for */
    readonly query?: string,
  }

  export type changeStickerSet = {
    /** Installs/uninstalls or activates/archives a sticker set */
    readonly _: 'changeStickerSet',
    /** Identifier of the sticker set */
    readonly set_id?: number | string,
    /** The new value of is_installed */
    readonly is_installed?: boolean,
    /**
     * The new value of is_archived. A sticker set can't be installed and archived
     * simultaneously
     */
    readonly is_archived?: boolean,
  }

  export type viewTrendingStickerSets = {
    /** Informs the server that some trending sticker sets have been viewed by the user */
    readonly _: 'viewTrendingStickerSets',
    /** Identifiers of viewed trending sticker sets */
    readonly sticker_set_ids?: ReadonlyArray<number | string>,
  }

  export type reorderInstalledStickerSets = {
    /** Changes the order of installed sticker sets */
    readonly _: 'reorderInstalledStickerSets',
    /** Type of the sticker sets to reorder */
    readonly sticker_type?: StickerType$Input,
    /** Identifiers of installed sticker sets in the new correct order */
    readonly sticker_set_ids?: ReadonlyArray<number | string>,
  }

  export type getRecentStickers = {
    /** Returns a list of recently used stickers */
    readonly _: 'getRecentStickers',
    /**
     * Pass true to return stickers and masks that were recently attached to photos
     * or video files; pass false to return recently sent stickers
     */
    readonly is_attached?: boolean,
  }

  export type addRecentSticker = {
    /**
     * Manually adds a new sticker to the list of recently used stickers. The new sticker
     * is added to the top of the list. If the sticker was already in the list, it
     * is removed from the list first. Only stickers belonging to a sticker set can
     * be added to this list. Emoji stickers can't be added to recent stickers
     */
    readonly _: 'addRecentSticker',
    /**
     * Pass true to add the sticker to the list of stickers recently attached to photo
     * or video files; pass false to add the sticker to the list of recently sent stickers
     */
    readonly is_attached?: boolean,
    /** Sticker file to add */
    readonly sticker?: InputFile$Input,
  }

  export type removeRecentSticker = {
    /** Removes a sticker from the list of recently used stickers */
    readonly _: 'removeRecentSticker',
    /**
     * Pass true to remove the sticker from the list of stickers recently attached
     * to photo or video files; pass false to remove the sticker from the list of recently
     * sent stickers
     */
    readonly is_attached?: boolean,
    /** Sticker file to delete */
    readonly sticker?: InputFile$Input,
  }

  export type clearRecentStickers = {
    /** Clears the list of recently used stickers */
    readonly _: 'clearRecentStickers',
    /**
     * Pass true to clear the list of stickers recently attached to photo or video
     * files; pass false to clear the list of recently sent stickers
     */
    readonly is_attached?: boolean,
  }

  export type getFavoriteStickers = {
    /** Returns favorite stickers */
    readonly _: 'getFavoriteStickers',
  }

  export type addFavoriteSticker = {
    /**
     * Adds a new sticker to the list of favorite stickers. The new sticker is added
     * to the top of the list. If the sticker was already in the list, it is removed
     * from the list first. Only stickers belonging to a sticker set can be added to
     * this list. Emoji stickers can't be added to favorite stickers
     */
    readonly _: 'addFavoriteSticker',
    /** Sticker file to add */
    readonly sticker?: InputFile$Input,
  }

  export type removeFavoriteSticker = {
    /** Removes a sticker from the list of favorite stickers */
    readonly _: 'removeFavoriteSticker',
    /** Sticker file to delete from the list */
    readonly sticker?: InputFile$Input,
  }

  export type getStickerEmojis = {
    /**
     * Returns emoji corresponding to a sticker. The list is only for informational
     * purposes, because a sticker is always sent with a fixed emoji from the corresponding
     * Sticker object
     */
    readonly _: 'getStickerEmojis',
    /** Sticker file identifier */
    readonly sticker?: InputFile$Input,
  }

  export type searchEmojis = {
    /** Searches for emojis by keywords. Supported only if the file database is enabled */
    readonly _: 'searchEmojis',
    /** Text to search for */
    readonly text?: string,
    /** Pass true if only emojis, which exactly match the text, needs to be returned */
    readonly exact_match?: boolean,
    /**
     * List of possible IETF language tags of the user's input language; may be empty
     * if unknown
     */
    readonly input_language_codes?: ReadonlyArray<string>,
  }

  export type getEmojiCategories = {
    /** Returns available emojis categories */
    readonly _: 'getEmojiCategories',
    /** Type of emoji categories to return; pass null to get default emoji categories */
    readonly type?: EmojiCategoryType$Input,
  }

  export type getAnimatedEmoji = {
    /**
     * Returns an animated emoji corresponding to a given emoji. Returns a 404 error
     * if the emoji has no animated emoji
     */
    readonly _: 'getAnimatedEmoji',
    /** The emoji */
    readonly emoji?: string,
  }

  export type getEmojiSuggestionsUrl = {
    /**
     * Returns an HTTP URL which can be used to automatically log in to the translation
     * platform and suggest new emoji replacements. The URL will be valid for 30 seconds
     * after generation
     */
    readonly _: 'getEmojiSuggestionsUrl',
    /** Language code for which the emoji replacements will be suggested */
    readonly language_code?: string,
  }

  export type getCustomEmojiStickers = {
    /**
     * Returns list of custom emoji stickers by their identifiers. Stickers are returned
     * in arbitrary order. Only found stickers are returned
     */
    readonly _: 'getCustomEmojiStickers',
    /**
     * Identifiers of custom emoji stickers. At most 200 custom emoji stickers can
     * be received simultaneously
     */
    readonly custom_emoji_ids?: ReadonlyArray<number | string>,
  }

  export type getDefaultChatPhotoCustomEmojiStickers = {
    /** Returns default list of custom emoji stickers for placing on a chat photo */
    readonly _: 'getDefaultChatPhotoCustomEmojiStickers',
  }

  export type getDefaultProfilePhotoCustomEmojiStickers = {
    /** Returns default list of custom emoji stickers for placing on a profile photo */
    readonly _: 'getDefaultProfilePhotoCustomEmojiStickers',
  }

  export type getSavedAnimations = {
    /** Returns saved animations */
    readonly _: 'getSavedAnimations',
  }

  export type addSavedAnimation = {
    /**
     * Manually adds a new animation to the list of saved animations. The new animation
     * is added to the beginning of the list. If the animation was already in the list,
     * it is removed first. Only non-secret video animations with MIME type "video/mp4"
     * can be added to the list
     */
    readonly _: 'addSavedAnimation',
    /**
     * The animation file to be added. Only animations known to the server (i.e., successfully
     * sent via a message) can be added to the list
     */
    readonly animation?: InputFile$Input,
  }

  export type removeSavedAnimation = {
    /** Removes an animation from the list of saved animations */
    readonly _: 'removeSavedAnimation',
    /** Animation file to be removed */
    readonly animation?: InputFile$Input,
  }

  export type getRecentInlineBots = {
    /** Returns up to 20 recently used inline bots in the order of their last usage */
    readonly _: 'getRecentInlineBots',
  }

  export type searchHashtags = {
    /** Searches for recently used hashtags by their prefix */
    readonly _: 'searchHashtags',
    /** Hashtag prefix to search for */
    readonly prefix?: string,
    /** The maximum number of hashtags to be returned */
    readonly limit?: number,
  }

  export type removeRecentHashtag = {
    /** Removes a hashtag from the list of recently used hashtags */
    readonly _: 'removeRecentHashtag',
    /** Hashtag to delete */
    readonly hashtag?: string,
  }

  export type getWebPagePreview = {
    /**
     * Returns a web page preview by the text of the message. Do not call this function
     * too often. Returns a 404 error if the web page has no preview
     */
    readonly _: 'getWebPagePreview',
    /** Message text with formatting */
    readonly text?: formattedText$Input,
  }

  export type getWebPageInstantView = {
    /**
     * Returns an instant view version of a web page if available. Returns a 404 error
     * if the web page has no instant view page
     */
    readonly _: 'getWebPageInstantView',
    /** The web page URL */
    readonly url?: string,
    /** Pass true to get full instant view for the web page */
    readonly force_full?: boolean,
  }

  export type setProfilePhoto = {
    /** Changes a profile photo for the current user */
    readonly _: 'setProfilePhoto',
    /** Profile photo to set */
    readonly photo?: InputChatPhoto$Input,
    /**
     * Pass true to set a public photo, which will be visible even the main photo is
     * hidden by privacy settings
     */
    readonly is_public?: boolean,
  }

  export type deleteProfilePhoto = {
    /** Deletes a profile photo */
    readonly _: 'deleteProfilePhoto',
    /** Identifier of the profile photo to delete */
    readonly profile_photo_id?: number | string,
  }

  export type setName = {
    /** Changes the first and last name of the current user */
    readonly _: 'setName',
    /** The new value of the first name for the current user; 1-64 characters */
    readonly first_name?: string,
    /** The new value of the optional last name for the current user; 0-64 characters */
    readonly last_name?: string,
  }

  export type setBio = {
    /** Changes the bio of the current user */
    readonly _: 'setBio',
    /**
     * The new value of the user bio; 0-getOption("bio_length_max") characters without
     * line feeds
     */
    readonly bio?: string,
  }

  export type setUsername = {
    /** Changes the editable username of the current user */
    readonly _: 'setUsername',
    /**
     * The new value of the username. Use an empty string to remove the username. The
     * username can't be completely removed if there is another active or disabled
     * username
     */
    readonly username?: string,
  }

  export type toggleUsernameIsActive = {
    /**
     * Changes active state for a username of the current user. The editable username
     * can't be disabled. May return an error with a message "USERNAMES_ACTIVE_TOO_MUCH"
     * if the maximum number of active usernames has been reached
     */
    readonly _: 'toggleUsernameIsActive',
    /** The username to change */
    readonly username?: string,
    /** Pass true to activate the username; pass false to disable it */
    readonly is_active?: boolean,
  }

  export type reorderActiveUsernames = {
    /** Changes order of active usernames of the current user */
    readonly _: 'reorderActiveUsernames',
    /** The new order of active usernames. All currently active usernames must be specified */
    readonly usernames?: ReadonlyArray<string>,
  }

  export type setEmojiStatus = {
    /** Changes the emoji status of the current user; for Telegram Premium users only */
    readonly _: 'setEmojiStatus',
    /** New emoji status; pass null to switch to the default badge */
    readonly emoji_status?: emojiStatus$Input,
  }

  export type setLocation = {
    /**
     * Changes the location of the current user. Needs to be called if getOption("is_location_visible")
     * is true and location changes for more than 1 kilometer
     */
    readonly _: 'setLocation',
    /** The new location of the user */
    readonly location?: location$Input,
  }

  export type changePhoneNumber = {
    /**
     * Changes the phone number of the user and sends an authentication code to the
     * user's new phone number; for official Android and iOS applications only. On
     * success, returns information about the sent code
     */
    readonly _: 'changePhoneNumber',
    /** The new phone number of the user in international format */
    readonly phone_number?: string,
    /**
     * Settings for the authentication of the user's phone number; pass null to use
     * default settings
     */
    readonly settings?: phoneNumberAuthenticationSettings$Input,
  }

  export type resendChangePhoneNumberCode = {
    /**
     * Resends the authentication code sent to confirm a new phone number for the current
     * user. Works only if the previously received authenticationCodeInfo next_code_type
     * was not null and the server-specified timeout has passed
     */
    readonly _: 'resendChangePhoneNumberCode',
  }

  export type checkChangePhoneNumberCode = {
    /** Checks the authentication code sent to confirm a new phone number of the user */
    readonly _: 'checkChangePhoneNumberCode',
    /** Authentication code to check */
    readonly code?: string,
  }

  export type getUserLink = {
    /**
     * Returns an HTTPS link, which can be used to get information about the current
     * user
     */
    readonly _: 'getUserLink',
  }

  export type searchUserByToken = {
    /** Searches a user by a token from the user's link */
    readonly _: 'searchUserByToken',
    /** Token to search for */
    readonly token?: string,
  }

  export type setCommands = {
    /**
     * Sets the list of commands supported by the bot for the given user scope and
     * language; for bots only
     */
    readonly _: 'setCommands',
    /**
     * The scope to which the commands are relevant; pass null to change commands in
     * the default bot command scope
     */
    readonly scope?: BotCommandScope$Input,
    /**
     * A two-letter ISO 639-1 language code. If empty, the commands will be applied
     * to all users from the given scope, for which language there are no dedicated
     * commands
     */
    readonly language_code?: string,
    /** List of the bot's commands */
    readonly commands?: ReadonlyArray<botCommand$Input>,
  }

  export type deleteCommands = {
    /**
     * Deletes commands supported by the bot for the given user scope and language;
     * for bots only
     */
    readonly _: 'deleteCommands',
    /**
     * The scope to which the commands are relevant; pass null to delete commands in
     * the default bot command scope
     */
    readonly scope?: BotCommandScope$Input,
    /** A two-letter ISO 639-1 language code or an empty string */
    readonly language_code?: string,
  }

  export type getCommands = {
    /**
     * Returns list of commands supported by the bot for the given user scope and language;
     * for bots only
     */
    readonly _: 'getCommands',
    /**
     * The scope to which the commands are relevant; pass null to get commands in the
     * default bot command scope
     */
    readonly scope?: BotCommandScope$Input,
    /** A two-letter ISO 639-1 language code or an empty string */
    readonly language_code?: string,
  }

  export type setMenuButton = {
    /** Sets menu button for the given user or for all users; for bots only */
    readonly _: 'setMenuButton',
    /** Identifier of the user or 0 to set menu button for all users */
    readonly user_id?: number,
    /** New menu button */
    readonly menu_button?: botMenuButton$Input,
  }

  export type getMenuButton = {
    /** Returns menu button set by the bot for the given user; for bots only */
    readonly _: 'getMenuButton',
    /** Identifier of the user or 0 to get the default menu button */
    readonly user_id?: number,
  }

  export type setDefaultGroupAdministratorRights = {
    /**
     * Sets default administrator rights for adding the bot to basic group and supergroup
     * chats; for bots only
     */
    readonly _: 'setDefaultGroupAdministratorRights',
    /**
     * Default administrator rights for adding the bot to basic group and supergroup
     * chats; pass null to remove default rights
     */
    readonly default_group_administrator_rights?: chatAdministratorRights$Input,
  }

  export type setDefaultChannelAdministratorRights = {
    /**
     * Sets default administrator rights for adding the bot to channel chats; for bots
     * only
     */
    readonly _: 'setDefaultChannelAdministratorRights',
    /**
     * Default administrator rights for adding the bot to channels; pass null to remove
     * default rights
     */
    readonly default_channel_administrator_rights?: chatAdministratorRights$Input,
  }

  export type canBotSendMessages = {
    /**
     * Checks whether the specified bot can send messages to the user. Returns a 404
     * error if can't and the access can be granted by call to allowBotToSendMessages
     */
    readonly _: 'canBotSendMessages',
    /** Identifier of the target bot */
    readonly bot_user_id?: number,
  }

  export type allowBotToSendMessages = {
    /** Allows the specified bot to send messages to the user */
    readonly _: 'allowBotToSendMessages',
    /** Identifier of the target bot */
    readonly bot_user_id?: number,
  }

  export type sendWebAppCustomRequest = {
    /** Sends a custom request from a Web App */
    readonly _: 'sendWebAppCustomRequest',
    /** Identifier of the bot */
    readonly bot_user_id?: number,
    /** The method name */
    readonly method?: string,
    /** JSON-serialized method parameters */
    readonly parameters?: string,
  }

  export type setBotName = {
    /** Sets the name of a bot. Can be called only if userTypeBot.can_be_edited == true */
    readonly _: 'setBotName',
    /** Identifier of the target bot */
    readonly bot_user_id?: number,
    /**
     * A two-letter ISO 639-1 language code. If empty, the name will be shown to all
     * users for whose languages there is no dedicated name
     */
    readonly language_code?: string,
    /**
     * New bot's name on the specified language; 0-64 characters; must be non-empty
     * if language code is empty
     */
    readonly name?: string,
  }

  export type getBotName = {
    /**
     * Returns the name of a bot in the given language. Can be called only if userTypeBot.can_be_edited
     * == true
     */
    readonly _: 'getBotName',
    /** Identifier of the target bot */
    readonly bot_user_id?: number,
    /** A two-letter ISO 639-1 language code or an empty string */
    readonly language_code?: string,
  }

  export type setBotProfilePhoto = {
    /** Changes a profile photo for a bot */
    readonly _: 'setBotProfilePhoto',
    /** Identifier of the target bot */
    readonly bot_user_id?: number,
    /** Profile photo to set; pass null to delete the chat photo */
    readonly photo?: InputChatPhoto$Input,
  }

  export type toggleBotUsernameIsActive = {
    /**
     * Changes active state for a username of a bot. The editable username can't be
     * disabled. May return an error with a message "USERNAMES_ACTIVE_TOO_MUCH" if
     * the maximum number of active usernames has been reached. Can be called only
     * if userTypeBot.can_be_edited == true
     */
    readonly _: 'toggleBotUsernameIsActive',
    /** Identifier of the target bot */
    readonly bot_user_id?: number,
    /** The username to change */
    readonly username?: string,
    /** Pass true to activate the username; pass false to disable it */
    readonly is_active?: boolean,
  }

  export type reorderBotActiveUsernames = {
    /**
     * Changes order of active usernames of a bot. Can be called only if userTypeBot.can_be_edited
     * == true
     */
    readonly _: 'reorderBotActiveUsernames',
    /** Identifier of the target bot */
    readonly bot_user_id?: number,
    /** The new order of active usernames. All currently active usernames must be specified */
    readonly usernames?: ReadonlyArray<string>,
  }

  export type setBotInfoDescription = {
    /**
     * Sets the text shown in the chat with a bot if the chat is empty. Can be called
     * only if userTypeBot.can_be_edited == true
     */
    readonly _: 'setBotInfoDescription',
    /** Identifier of the target bot */
    readonly bot_user_id?: number,
    /**
     * A two-letter ISO 639-1 language code. If empty, the description will be shown
     * to all users for whose languages there is no dedicated description
     */
    readonly language_code?: string,
    /** New bot's description on the specified language */
    readonly description?: string,
  }

  export type getBotInfoDescription = {
    /**
     * Returns the text shown in the chat with a bot if the chat is empty in the given
     * language. Can be called only if userTypeBot.can_be_edited == true
     */
    readonly _: 'getBotInfoDescription',
    /** Identifier of the target bot */
    readonly bot_user_id?: number,
    /** A two-letter ISO 639-1 language code or an empty string */
    readonly language_code?: string,
  }

  export type setBotInfoShortDescription = {
    /**
     * Sets the text shown on a bot's profile page and sent together with the link
     * when users share the bot. Can be called only if userTypeBot.can_be_edited ==
     * true
     */
    readonly _: 'setBotInfoShortDescription',
    /** Identifier of the target bot */
    readonly bot_user_id?: number,
    /**
     * A two-letter ISO 639-1 language code. If empty, the short description will be
     * shown to all users for whose languages there is no dedicated description
     */
    readonly language_code?: string,
    /** New bot's short description on the specified language */
    readonly short_description?: string,
  }

  export type getBotInfoShortDescription = {
    /**
     * Returns the text shown on a bot's profile page and sent together with the link
     * when users share the bot in the given language. Can be called only if userTypeBot.can_be_edited
     * == true
     */
    readonly _: 'getBotInfoShortDescription',
    /** Identifier of the target bot */
    readonly bot_user_id?: number,
    /** A two-letter ISO 639-1 language code or an empty string */
    readonly language_code?: string,
  }

  export type getActiveSessions = {
    /** Returns all active sessions of the current user */
    readonly _: 'getActiveSessions',
  }

  export type terminateSession = {
    /** Terminates a session of the current user */
    readonly _: 'terminateSession',
    /** Session identifier */
    readonly session_id?: number | string,
  }

  export type terminateAllOtherSessions = {
    /** Terminates all other sessions of the current user */
    readonly _: 'terminateAllOtherSessions',
  }

  export type confirmSession = {
    /** Confirms an unconfirmed session of the current user from another device */
    readonly _: 'confirmSession',
    /** Session identifier */
    readonly session_id?: number | string,
  }

  export type toggleSessionCanAcceptCalls = {
    /** Toggles whether a session can accept incoming calls */
    readonly _: 'toggleSessionCanAcceptCalls',
    /** Session identifier */
    readonly session_id?: number | string,
    /** Pass true to allow accepting incoming calls by the session; pass false otherwise */
    readonly can_accept_calls?: boolean,
  }

  export type toggleSessionCanAcceptSecretChats = {
    /** Toggles whether a session can accept incoming secret chats */
    readonly _: 'toggleSessionCanAcceptSecretChats',
    /** Session identifier */
    readonly session_id?: number | string,
    /** Pass true to allow accepting secret chats by the session; pass false otherwise */
    readonly can_accept_secret_chats?: boolean,
  }

  export type setInactiveSessionTtl = {
    /**
     * Changes the period of inactivity after which sessions will automatically be
     * terminated
     */
    readonly _: 'setInactiveSessionTtl',
    /**
     * New number of days of inactivity before sessions will be automatically terminated;
     * 1-366 days
     */
    readonly inactive_session_ttl_days?: number,
  }

  export type getConnectedWebsites = {
    /** Returns all website where the current user used Telegram to log in */
    readonly _: 'getConnectedWebsites',
  }

  export type disconnectWebsite = {
    /** Disconnects website from the current user's Telegram account */
    readonly _: 'disconnectWebsite',
    /** Website identifier */
    readonly website_id?: number | string,
  }

  export type disconnectAllWebsites = {
    /** Disconnects all websites from the current user's Telegram account */
    readonly _: 'disconnectAllWebsites',
  }

  export type setSupergroupUsername = {
    /**
     * Changes the editable username of a supergroup or channel, requires owner privileges
     * in the supergroup or channel
     */
    readonly _: 'setSupergroupUsername',
    /** Identifier of the supergroup or channel */
    readonly supergroup_id?: number,
    /**
     * New value of the username. Use an empty string to remove the username. The username
     * can't be completely removed if there is another active or disabled username
     */
    readonly username?: string,
  }

  export type toggleSupergroupUsernameIsActive = {
    /**
     * Changes active state for a username of a supergroup or channel, requires owner
     * privileges in the supergroup or channel. The editable username can't be disabled.
     * May return an error with a message "USERNAMES_ACTIVE_TOO_MUCH" if the maximum
     * number of active usernames has been reached
     */
    readonly _: 'toggleSupergroupUsernameIsActive',
    /** Identifier of the supergroup or channel */
    readonly supergroup_id?: number,
    /** The username to change */
    readonly username?: string,
    /** Pass true to activate the username; pass false to disable it */
    readonly is_active?: boolean,
  }

  export type disableAllSupergroupUsernames = {
    /**
     * Disables all active non-editable usernames of a supergroup or channel, requires
     * owner privileges in the supergroup or channel
     */
    readonly _: 'disableAllSupergroupUsernames',
    /** Identifier of the supergroup or channel */
    readonly supergroup_id?: number,
  }

  export type reorderSupergroupActiveUsernames = {
    /**
     * Changes order of active usernames of a supergroup or channel, requires owner
     * privileges in the supergroup or channel
     */
    readonly _: 'reorderSupergroupActiveUsernames',
    /** Identifier of the supergroup or channel */
    readonly supergroup_id?: number,
    /** The new order of active usernames. All currently active usernames must be specified */
    readonly usernames?: ReadonlyArray<string>,
  }

  export type setSupergroupStickerSet = {
    /**
     * Changes the sticker set of a supergroup; requires can_change_info administrator
     * right
     */
    readonly _: 'setSupergroupStickerSet',
    /** Identifier of the supergroup */
    readonly supergroup_id?: number,
    /**
     * New value of the supergroup sticker set identifier. Use 0 to remove the supergroup
     * sticker set
     */
    readonly sticker_set_id?: number | string,
  }

  export type toggleSupergroupSignMessages = {
    /**
     * Toggles whether sender signature is added to sent messages in a channel; requires
     * can_change_info administrator right
     */
    readonly _: 'toggleSupergroupSignMessages',
    /** Identifier of the channel */
    readonly supergroup_id?: number,
    /** New value of sign_messages */
    readonly sign_messages?: boolean,
  }

  export type toggleSupergroupJoinToSendMessages = {
    /**
     * Toggles whether joining is mandatory to send messages to a discussion supergroup;
     * requires can_restrict_members administrator right
     */
    readonly _: 'toggleSupergroupJoinToSendMessages',
    /** Identifier of the supergroup */
    readonly supergroup_id?: number,
    /** New value of join_to_send_messages */
    readonly join_to_send_messages?: boolean,
  }

  export type toggleSupergroupJoinByRequest = {
    /**
     * Toggles whether all users directly joining the supergroup need to be approved
     * by supergroup administrators; requires can_restrict_members administrator right
     */
    readonly _: 'toggleSupergroupJoinByRequest',
    /** Identifier of the channel */
    readonly supergroup_id?: number,
    /** New value of join_by_request */
    readonly join_by_request?: boolean,
  }

  export type toggleSupergroupIsAllHistoryAvailable = {
    /**
     * Toggles whether the message history of a supergroup is available to new members;
     * requires can_change_info administrator right
     */
    readonly _: 'toggleSupergroupIsAllHistoryAvailable',
    /** The identifier of the supergroup */
    readonly supergroup_id?: number,
    /** The new value of is_all_history_available */
    readonly is_all_history_available?: boolean,
  }

  export type toggleSupergroupHasHiddenMembers = {
    /**
     * Toggles whether non-administrators can receive only administrators and bots
     * using getSupergroupMembers or searchChatMembers. Can be called only if supergroupFullInfo.can_hide_members
     * == true
     */
    readonly _: 'toggleSupergroupHasHiddenMembers',
    /** Identifier of the supergroup */
    readonly supergroup_id?: number,
    /** New value of has_hidden_members */
    readonly has_hidden_members?: boolean,
  }

  export type toggleSupergroupHasAggressiveAntiSpamEnabled = {
    /**
     * Toggles whether aggressive anti-spam checks are enabled in the supergroup. Can
     * be called only if supergroupFullInfo.can_toggle_aggressive_anti_spam == true
     */
    readonly _: 'toggleSupergroupHasAggressiveAntiSpamEnabled',
    /** The identifier of the supergroup, which isn't a broadcast group */
    readonly supergroup_id?: number,
    /** The new value of has_aggressive_anti_spam_enabled */
    readonly has_aggressive_anti_spam_enabled?: boolean,
  }

  export type toggleSupergroupIsForum = {
    /**
     * Toggles whether the supergroup is a forum; requires owner privileges in the
     * supergroup. Discussion supergroups can't be converted to forums
     */
    readonly _: 'toggleSupergroupIsForum',
    /** Identifier of the supergroup */
    readonly supergroup_id?: number,
    /** New value of is_forum */
    readonly is_forum?: boolean,
  }

  export type toggleSupergroupIsBroadcastGroup = {
    /** Upgrades supergroup to a broadcast group; requires owner privileges in the supergroup */
    readonly _: 'toggleSupergroupIsBroadcastGroup',
    /** Identifier of the supergroup */
    readonly supergroup_id?: number,
  }

  export type reportSupergroupSpam = {
    /**
     * Reports messages in a supergroup as spam; requires administrator rights in the
     * supergroup
     */
    readonly _: 'reportSupergroupSpam',
    /** Supergroup identifier */
    readonly supergroup_id?: number,
    /** Identifiers of messages to report */
    readonly message_ids?: ReadonlyArray<number>,
  }

  export type reportSupergroupAntiSpamFalsePositive = {
    /**
     * Reports a false deletion of a message by aggressive anti-spam checks; requires
     * administrator rights in the supergroup. Can be called only for messages from
     * chatEventMessageDeleted with can_report_anti_spam_false_positive == true
     */
    readonly _: 'reportSupergroupAntiSpamFalsePositive',
    /** Supergroup identifier */
    readonly supergroup_id?: number,
    /** Identifier of the erroneously deleted message */
    readonly message_id?: number,
  }

  export type getSupergroupMembers = {
    /**
     * Returns information about members or banned users in a supergroup or channel.
     * Can be used only if supergroupFullInfo.can_get_members == true; additionally,
     * administrator privileges may be required for some filters
     */
    readonly _: 'getSupergroupMembers',
    /** Identifier of the supergroup or channel */
    readonly supergroup_id?: number,
    /** The type of users to return; pass null to use supergroupMembersFilterRecent */
    readonly filter?: SupergroupMembersFilter$Input,
    /** Number of users to skip */
    readonly offset?: number,
    /** The maximum number of users be returned; up to 200 */
    readonly limit?: number,
  }

  export type closeSecretChat = {
    /** Closes a secret chat, effectively transferring its state to secretChatStateClosed */
    readonly _: 'closeSecretChat',
    /** Secret chat identifier */
    readonly secret_chat_id?: number,
  }

  export type getChatEventLog = {
    /**
     * Returns a list of service actions taken by chat members and administrators in
     * the last 48 hours. Available only for supergroups and channels. Requires administrator
     * rights. Returns results in reverse chronological order (i.e., in order of decreasing
     * event_id)
     */
    readonly _: 'getChatEventLog',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Search query by which to filter events */
    readonly query?: string,
    /**
     * Identifier of an event from which to return results. Use 0 to get results from
     * the latest events
     */
    readonly from_event_id?: number | string,
    /** The maximum number of events to return; up to 100 */
    readonly limit?: number,
    /** The types of events to return; pass null to get chat events of all types */
    readonly filters?: chatEventLogFilters$Input,
    /**
     * User identifiers by which to filter events. By default, events relating to all
     * users will be returned
     */
    readonly user_ids?: ReadonlyArray<number>,
  }

  export type getPaymentForm = {
    /**
     * Returns an invoice payment form. This method must be called when the user presses
     * inline button of the type inlineKeyboardButtonTypeBuy
     */
    readonly _: 'getPaymentForm',
    /** The invoice */
    readonly input_invoice?: InputInvoice$Input,
    /** Preferred payment form theme; pass null to use the default theme */
    readonly theme?: themeParameters$Input,
  }

  export type validateOrderInfo = {
    /**
     * Validates the order information provided by a user and returns the available
     * shipping options for a flexible invoice
     */
    readonly _: 'validateOrderInfo',
    /** The invoice */
    readonly input_invoice?: InputInvoice$Input,
    /** The order information, provided by the user; pass null if empty */
    readonly order_info?: orderInfo$Input,
    /** Pass true to save the order information */
    readonly allow_save?: boolean,
  }

  export type sendPaymentForm = {
    /** Sends a filled-out payment form to the bot for final verification */
    readonly _: 'sendPaymentForm',
    /** The invoice */
    readonly input_invoice?: InputInvoice$Input,
    /** Payment form identifier returned by getPaymentForm */
    readonly payment_form_id?: number | string,
    /** Identifier returned by validateOrderInfo, or an empty string */
    readonly order_info_id?: string,
    /** Identifier of a chosen shipping option, if applicable */
    readonly shipping_option_id?: string,
    /** The credentials chosen by user for payment */
    readonly credentials?: InputCredentials$Input,
    /** Chosen by the user amount of tip in the smallest units of the currency */
    readonly tip_amount?: number,
  }

  export type getPaymentReceipt = {
    /** Returns information about a successful payment */
    readonly _: 'getPaymentReceipt',
    /** Chat identifier of the messagePaymentSuccessful message */
    readonly chat_id?: number,
    /** Message identifier */
    readonly message_id?: number,
  }

  export type getSavedOrderInfo = {
    /**
     * Returns saved order information. Returns a 404 error if there is no saved order
     * information
     */
    readonly _: 'getSavedOrderInfo',
  }

  export type deleteSavedOrderInfo = {
    /** Deletes saved order information */
    readonly _: 'deleteSavedOrderInfo',
  }

  export type deleteSavedCredentials = {
    /** Deletes saved credentials for all payment provider bots */
    readonly _: 'deleteSavedCredentials',
  }

  export type createInvoiceLink = {
    /** Creates a link for the given invoice; for bots only */
    readonly _: 'createInvoiceLink',
    /** Information about the invoice of the type inputMessageInvoice */
    readonly invoice?: InputMessageContent$Input,
  }

  export type getSupportUser = {
    /** Returns a user that can be contacted to get support */
    readonly _: 'getSupportUser',
  }

  export type getBackgrounds = {
    /** Returns backgrounds installed by the user */
    readonly _: 'getBackgrounds',
    /** Pass true to order returned backgrounds for a dark theme */
    readonly for_dark_theme?: boolean,
  }

  export type getBackgroundUrl = {
    /** Constructs a persistent HTTP URL for a background */
    readonly _: 'getBackgroundUrl',
    /** Background name */
    readonly name?: string,
    /** Background type */
    readonly type?: BackgroundType$Input,
  }

  export type searchBackground = {
    /** Searches for a background by its name */
    readonly _: 'searchBackground',
    /** The name of the background */
    readonly name?: string,
  }

  export type setBackground = {
    /**
     * Changes the background selected by the user; adds background to the list of
     * installed backgrounds
     */
    readonly _: 'setBackground',
    /**
     * The input background to use; pass null to create a new filled background or
     * to remove the current background
     */
    readonly background?: InputBackground$Input,
    /**
     * Background type; pass null to use the default type of the remote background
     * or to remove the current background
     */
    readonly type?: BackgroundType$Input,
    /** Pass true if the background is changed for a dark theme */
    readonly for_dark_theme?: boolean,
  }

  export type removeBackground = {
    /** Removes background from the list of installed backgrounds */
    readonly _: 'removeBackground',
    /** The background identifier */
    readonly background_id?: number | string,
  }

  export type resetBackgrounds = {
    /** Resets list of installed backgrounds to its default value */
    readonly _: 'resetBackgrounds',
  }

  export type getLocalizationTargetInfo = {
    /**
     * Returns information about the current localization target. This is an offline
     * request if only_local is true. Can be called before authorization
     */
    readonly _: 'getLocalizationTargetInfo',
    /**
     * Pass true to get only locally available information without sending network
     * requests
     */
    readonly only_local?: boolean,
  }

  export type getLanguagePackInfo = {
    /**
     * Returns information about a language pack. Returned language pack identifier
     * may be different from a provided one. Can be called before authorization
     */
    readonly _: 'getLanguagePackInfo',
    /** Language pack identifier */
    readonly language_pack_id?: string,
  }

  export type getLanguagePackStrings = {
    /**
     * Returns strings from a language pack in the current localization target by their
     * keys. Can be called before authorization
     */
    readonly _: 'getLanguagePackStrings',
    /** Language pack identifier of the strings to be returned */
    readonly language_pack_id?: string,
    /**
     * Language pack keys of the strings to be returned; leave empty to request all
     * available strings
     */
    readonly keys?: ReadonlyArray<string>,
  }

  export type synchronizeLanguagePack = {
    /**
     * Fetches the latest versions of all strings from a language pack in the current
     * localization target from the server. This method doesn't need to be called explicitly
     * for the current used/base language packs. Can be called before authorization
     */
    readonly _: 'synchronizeLanguagePack',
    /** Language pack identifier */
    readonly language_pack_id?: string,
  }

  export type addCustomServerLanguagePack = {
    /**
     * Adds a custom server language pack to the list of installed language packs in
     * current localization target. Can be called before authorization
     */
    readonly _: 'addCustomServerLanguagePack',
    /** Identifier of a language pack to be added */
    readonly language_pack_id?: string,
  }

  export type setCustomLanguagePack = {
    /** Adds or changes a custom local language pack to the current localization target */
    readonly _: 'setCustomLanguagePack',
    /**
     * Information about the language pack. Language pack identifier must start with
     * 'X', consist only of English letters, digits and hyphens, and must not exceed
     * 64 characters. Can be called before authorization
     */
    readonly info?: languagePackInfo$Input,
    /** Strings of the new language pack */
    readonly strings?: ReadonlyArray<languagePackString$Input>,
  }

  export type editCustomLanguagePackInfo = {
    /**
     * Edits information about a custom local language pack in the current localization
     * target. Can be called before authorization
     */
    readonly _: 'editCustomLanguagePackInfo',
    /** New information about the custom local language pack */
    readonly info?: languagePackInfo$Input,
  }

  export type setCustomLanguagePackString = {
    /**
     * Adds, edits or deletes a string in a custom local language pack. Can be called
     * before authorization
     */
    readonly _: 'setCustomLanguagePackString',
    /**
     * Identifier of a previously added custom local language pack in the current localization
     * target
     */
    readonly language_pack_id?: string,
    /** New language pack string */
    readonly new_string?: languagePackString$Input,
  }

  export type deleteLanguagePack = {
    /**
     * Deletes all information about a language pack in the current localization target.
     * The language pack which is currently in use (including base language pack) or
     * is being synchronized can't be deleted. Can be called before authorization
     */
    readonly _: 'deleteLanguagePack',
    /** Identifier of the language pack to delete */
    readonly language_pack_id?: string,
  }

  export type registerDevice = {
    /**
     * Registers the currently used device for receiving push notifications. Returns
     * a globally unique identifier of the push notification subscription
     */
    readonly _: 'registerDevice',
    /** Device token */
    readonly device_token?: DeviceToken$Input,
    /** List of user identifiers of other users currently using the application */
    readonly other_user_ids?: ReadonlyArray<number>,
  }

  export type processPushNotification = {
    /**
     * Handles a push notification. Returns error with code 406 if the push notification
     * is not supported and connection to the server is required to fetch new data.
     * Can be called before authorization
     */
    readonly _: 'processPushNotification',
    /**
     * JSON-encoded push notification payload with all fields sent by the server, and
     * "google.sent_time" and "google.notification.sound" fields added
     */
    readonly payload?: string,
  }

  export type getPushReceiverId = {
    /**
     * Returns a globally unique push notification subscription identifier for identification
     * of an account, which has received a push notification. Can be called synchronously
     */
    readonly _: 'getPushReceiverId',
    /** JSON-encoded push notification payload */
    readonly payload?: string,
  }

  export type getRecentlyVisitedTMeUrls = {
    /** Returns t.me URLs recently visited by a newly registered user */
    readonly _: 'getRecentlyVisitedTMeUrls',
    /** Google Play referrer to identify the user */
    readonly referrer?: string,
  }

  export type setUserPrivacySettingRules = {
    /** Changes user privacy settings */
    readonly _: 'setUserPrivacySettingRules',
    /** The privacy setting */
    readonly setting?: UserPrivacySetting$Input,
    /** The new privacy rules */
    readonly rules?: userPrivacySettingRules$Input,
  }

  export type getUserPrivacySettingRules = {
    /** Returns the current privacy settings */
    readonly _: 'getUserPrivacySettingRules',
    /** The privacy setting */
    readonly setting?: UserPrivacySetting$Input,
  }

  export type getOption = {
    /**
     * Returns the value of an option by its name. (Check the list of available options
     * on https://core.telegram.org/tdlib/options.) Can be called before authorization.
     * Can be called synchronously for options "version" and "commit_hash"
     */
    readonly _: 'getOption',
    /** The name of the option */
    readonly name?: string,
  }

  export type setOption = {
    /**
     * Sets the value of an option. (Check the list of available options on https://core.telegram.org/tdlib/options.)
     * Only writable options can be set. Can be called before authorization
     */
    readonly _: 'setOption',
    /** The name of the option */
    readonly name?: string,
    /** The new value of the option; pass null to reset option value to a default value */
    readonly value?: OptionValue$Input,
  }

  export type setAccountTtl = {
    /**
     * Changes the period of inactivity after which the account of the current user
     * will automatically be deleted
     */
    readonly _: 'setAccountTtl',
    /** New account TTL */
    readonly ttl?: accountTtl$Input,
  }

  export type getAccountTtl = {
    /**
     * Returns the period of inactivity after which the account of the current user
     * will automatically be deleted
     */
    readonly _: 'getAccountTtl',
  }

  export type deleteAccount = {
    /**
     * Deletes the account of the current user, deleting all information associated
     * with the user from the server. The phone number of the account can be used to
     * create a new account. Can be called before authorization when the current authorization
     * state is authorizationStateWaitPassword
     */
    readonly _: 'deleteAccount',
    /** The reason why the account was deleted; optional */
    readonly reason?: string,
    /**
     * The 2-step verification password of the current user. If not specified, account
     * deletion can be canceled within one week
     */
    readonly password?: string,
  }

  export type setDefaultMessageAutoDeleteTime = {
    /** Changes the default message auto-delete time for new chats */
    readonly _: 'setDefaultMessageAutoDeleteTime',
    /**
     * New default message auto-delete time; must be from 0 up to 365 * 86400 and be
     * divisible by 86400. If 0, then messages aren't deleted automatically
     */
    readonly message_auto_delete_time?: messageAutoDeleteTime$Input,
  }

  export type getDefaultMessageAutoDeleteTime = {
    /** Returns default message auto-delete time setting for new chats */
    readonly _: 'getDefaultMessageAutoDeleteTime',
  }

  export type removeChatActionBar = {
    /** Removes a chat action bar without any other action */
    readonly _: 'removeChatActionBar',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type reportChat = {
    /**
     * Reports a chat to the Telegram moderators. A chat can be reported only from
     * the chat action bar, or if chat.can_be_reported
     */
    readonly _: 'reportChat',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Identifiers of reported messages; may be empty to report the whole chat */
    readonly message_ids?: ReadonlyArray<number>,
    /** The reason for reporting the chat */
    readonly reason?: ReportReason$Input,
    /** Additional report details; 0-1024 characters */
    readonly text?: string,
  }

  export type reportChatPhoto = {
    /**
     * Reports a chat photo to the Telegram moderators. A chat photo can be reported
     * only if chat.can_be_reported
     */
    readonly _: 'reportChatPhoto',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Identifier of the photo to report. Only full photos from chatPhoto can be reported */
    readonly file_id?: number,
    /** The reason for reporting the chat photo */
    readonly reason?: ReportReason$Input,
    /** Additional report details; 0-1024 characters */
    readonly text?: string,
  }

  export type reportMessageReactions = {
    /**
     * Reports reactions set on a message to the Telegram moderators. Reactions on
     * a message can be reported only if message.can_report_reactions
     */
    readonly _: 'reportMessageReactions',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Message identifier */
    readonly message_id?: number,
    /** Identifier of the sender, which added the reaction */
    readonly sender_id?: MessageSender$Input,
  }

  export type getChatStatistics = {
    /**
     * Returns detailed statistics about a chat. Currently, this method can be used
     * only for supergroups and channels. Can be used only if supergroupFullInfo.can_get_statistics
     * == true
     */
    readonly _: 'getChatStatistics',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Pass true if a dark theme is used by the application */
    readonly is_dark?: boolean,
  }

  export type getMessageStatistics = {
    /**
     * Returns detailed statistics about a message. Can be used only if message.can_get_statistics
     * == true
     */
    readonly _: 'getMessageStatistics',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Message identifier */
    readonly message_id?: number,
    /** Pass true if a dark theme is used by the application */
    readonly is_dark?: boolean,
  }

  export type getStatisticalGraph = {
    /** Loads an asynchronous or a zoomed in statistical graph */
    readonly _: 'getStatisticalGraph',
    /** Chat identifier */
    readonly chat_id?: number,
    /** The token for graph loading */
    readonly token?: string,
    /** X-value for zoomed in graph or 0 otherwise */
    readonly x?: number,
  }

  export type getStorageStatistics = {
    /** Returns storage usage statistics. Can be called before authorization */
    readonly _: 'getStorageStatistics',
    /**
     * The maximum number of chats with the largest storage usage for which separate
     * statistics need to be returned. All other chats will be grouped in entries with
     * chat_id == 0. If the chat info database is not used, the chat_limit is ignored
     * and is always set to 0
     */
    readonly chat_limit?: number,
  }

  export type getStorageStatisticsFast = {
    /** Quickly returns approximate storage usage statistics. Can be called before authorization */
    readonly _: 'getStorageStatisticsFast',
  }

  export type getDatabaseStatistics = {
    /** Returns database statistics */
    readonly _: 'getDatabaseStatistics',
  }

  export type optimizeStorage = {
    /**
     * Optimizes storage usage, i.e. deletes some files and returns new storage usage
     * statistics. Secret thumbnails can't be deleted
     */
    readonly _: 'optimizeStorage',
    /**
     * Limit on the total size of files after deletion, in bytes. Pass -1 to use the
     * default limit
     */
    readonly size?: number,
    /**
     * Limit on the time that has passed since the last time a file was accessed (or
     * creation time for some filesystems). Pass -1 to use the default limit
     */
    readonly ttl?: number,
    /**
     * Limit on the total number of files after deletion. Pass -1 to use the default
     * limit
     */
    readonly count?: number,
    /**
     * The amount of time after the creation of a file during which it can't be deleted,
     * in seconds. Pass -1 to use the default value
     */
    readonly immunity_delay?: number,
    /**
     * If non-empty, only files with the given types are considered. By default, all
     * types except thumbnails, profile photos, stickers and wallpapers are deleted
     */
    readonly file_types?: ReadonlyArray<FileType$Input>,
    /**
     * If non-empty, only files from the given chats are considered. Use 0 as chat
     * identifier to delete files not belonging to any chat (e.g., profile photos)
     */
    readonly chat_ids?: ReadonlyArray<number>,
    /**
     * If non-empty, files from the given chats are excluded. Use 0 as chat identifier
     * to exclude all files not belonging to any chat (e.g., profile photos)
     */
    readonly exclude_chat_ids?: ReadonlyArray<number>,
    /**
     * Pass true if statistics about the files that were deleted must be returned instead
     * of the whole storage usage statistics. Affects only returned statistics
     */
    readonly return_deleted_file_statistics?: boolean,
    /** Same as in getStorageStatistics. Affects only returned statistics */
    readonly chat_limit?: number,
  }

  export type setNetworkType = {
    /**
     * Sets the current network type. Can be called before authorization. Calling this
     * method forces all network connections to reopen, mitigating the delay in switching
     * between different networks, so it must be called whenever the network is changed,
     * even if the network type remains the same. Network type is used to check whether
     * the library can use the network at all and also for collecting detailed network
     * data usage statistics
     */
    readonly _: 'setNetworkType',
    /** The new network type; pass null to set network type to networkTypeOther */
    readonly type?: NetworkType$Input,
  }

  export type getNetworkStatistics = {
    /** Returns network data usage statistics. Can be called before authorization */
    readonly _: 'getNetworkStatistics',
    /** Pass true to get statistics only for the current library launch */
    readonly only_current?: boolean,
  }

  export type addNetworkStatistics = {
    /** Adds the specified data to data usage statistics. Can be called before authorization */
    readonly _: 'addNetworkStatistics',
    /** The network statistics entry with the data to be added to statistics */
    readonly entry?: NetworkStatisticsEntry$Input,
  }

  export type resetNetworkStatistics = {
    /** Resets all network data usage statistics to zero. Can be called before authorization */
    readonly _: 'resetNetworkStatistics',
  }

  export type getAutoDownloadSettingsPresets = {
    /** Returns auto-download settings presets for the current user */
    readonly _: 'getAutoDownloadSettingsPresets',
  }

  export type setAutoDownloadSettings = {
    /** Sets auto-download settings */
    readonly _: 'setAutoDownloadSettings',
    /** New user auto-download settings */
    readonly settings?: autoDownloadSettings$Input,
    /** Type of the network for which the new settings are relevant */
    readonly type?: NetworkType$Input,
  }

  export type getAutosaveSettings = {
    /** Returns autosave settings for the current user */
    readonly _: 'getAutosaveSettings',
  }

  export type setAutosaveSettings = {
    /**
     * Sets autosave settings for the given scope. The method is guaranteed to work
     * only after at least one call to getAutosaveSettings
     */
    readonly _: 'setAutosaveSettings',
    /** Autosave settings scope */
    readonly scope?: AutosaveSettingsScope$Input,
    /** New autosave settings for the scope; pass null to set autosave settings to default */
    readonly settings?: scopeAutosaveSettings$Input,
  }

  export type clearAutosaveSettingsExceptions = {
    /**
     * Clears the list of all autosave settings exceptions. The method is guaranteed
     * to work only after at least one call to getAutosaveSettings
     */
    readonly _: 'clearAutosaveSettingsExceptions',
  }

  export type getBankCardInfo = {
    /** Returns information about a bank card */
    readonly _: 'getBankCardInfo',
    /** The bank card number */
    readonly bank_card_number?: string,
  }

  export type getPassportElement = {
    /** Returns one of the available Telegram Passport elements */
    readonly _: 'getPassportElement',
    /** Telegram Passport element type */
    readonly type?: PassportElementType$Input,
    /** The 2-step verification password of the current user */
    readonly password?: string,
  }

  export type getAllPassportElements = {
    /** Returns all available Telegram Passport elements */
    readonly _: 'getAllPassportElements',
    /** The 2-step verification password of the current user */
    readonly password?: string,
  }

  export type setPassportElement = {
    /**
     * Adds an element to the user's Telegram Passport. May return an error with a
     * message "PHONE_VERIFICATION_NEEDED" or "EMAIL_VERIFICATION_NEEDED" if the chosen
     * phone number or the chosen email address must be verified first
     */
    readonly _: 'setPassportElement',
    /** Input Telegram Passport element */
    readonly element?: InputPassportElement$Input,
    /** The 2-step verification password of the current user */
    readonly password?: string,
  }

  export type deletePassportElement = {
    /** Deletes a Telegram Passport element */
    readonly _: 'deletePassportElement',
    /** Element type */
    readonly type?: PassportElementType$Input,
  }

  export type setPassportElementErrors = {
    /**
     * Informs the user that some of the elements in their Telegram Passport contain
     * errors; for bots only. The user will not be able to resend the elements, until
     * the errors are fixed
     */
    readonly _: 'setPassportElementErrors',
    /** User identifier */
    readonly user_id?: number,
    /** The errors */
    readonly errors?: ReadonlyArray<inputPassportElementError$Input>,
  }

  export type getPreferredCountryLanguage = {
    /**
     * Returns an IETF language tag of the language preferred in the country, which
     * must be used to fill native fields in Telegram Passport personal details. Returns
     * a 404 error if unknown
     */
    readonly _: 'getPreferredCountryLanguage',
    /** A two-letter ISO 3166-1 alpha-2 country code */
    readonly country_code?: string,
  }

  export type sendPhoneNumberVerificationCode = {
    /** Sends a code to verify a phone number to be added to a user's Telegram Passport */
    readonly _: 'sendPhoneNumberVerificationCode',
    /** The phone number of the user, in international format */
    readonly phone_number?: string,
    /**
     * Settings for the authentication of the user's phone number; pass null to use
     * default settings
     */
    readonly settings?: phoneNumberAuthenticationSettings$Input,
  }

  export type resendPhoneNumberVerificationCode = {
    /** Resends the code to verify a phone number to be added to a user's Telegram Passport */
    readonly _: 'resendPhoneNumberVerificationCode',
  }

  export type checkPhoneNumberVerificationCode = {
    /** Checks the phone number verification code for Telegram Passport */
    readonly _: 'checkPhoneNumberVerificationCode',
    /** Verification code to check */
    readonly code?: string,
  }

  export type sendEmailAddressVerificationCode = {
    /** Sends a code to verify an email address to be added to a user's Telegram Passport */
    readonly _: 'sendEmailAddressVerificationCode',
    /** Email address */
    readonly email_address?: string,
  }

  export type resendEmailAddressVerificationCode = {
    /**
     * Resends the code to verify an email address to be added to a user's Telegram
     * Passport
     */
    readonly _: 'resendEmailAddressVerificationCode',
  }

  export type checkEmailAddressVerificationCode = {
    /** Checks the email address verification code for Telegram Passport */
    readonly _: 'checkEmailAddressVerificationCode',
    /** Verification code to check */
    readonly code?: string,
  }

  export type getPassportAuthorizationForm = {
    /** Returns a Telegram Passport authorization form for sharing data with a service */
    readonly _: 'getPassportAuthorizationForm',
    /** User identifier of the service's bot */
    readonly bot_user_id?: number,
    /** Telegram Passport element types requested by the service */
    readonly scope?: string,
    /** Service's public key */
    readonly public_key?: string,
    /** Unique request identifier provided by the service */
    readonly nonce?: string,
  }

  export type getPassportAuthorizationFormAvailableElements = {
    /**
     * Returns already available Telegram Passport elements suitable for completing
     * a Telegram Passport authorization form. Result can be received only once for
     * each authorization form
     */
    readonly _: 'getPassportAuthorizationFormAvailableElements',
    /** Authorization form identifier */
    readonly authorization_form_id?: number,
    /** The 2-step verification password of the current user */
    readonly password?: string,
  }

  export type sendPassportAuthorizationForm = {
    /**
     * Sends a Telegram Passport authorization form, effectively sharing data with
     * the service. This method must be called after getPassportAuthorizationFormAvailableElements
     * if some previously available elements are going to be reused
     */
    readonly _: 'sendPassportAuthorizationForm',
    /** Authorization form identifier */
    readonly authorization_form_id?: number,
    /**
     * Types of Telegram Passport elements chosen by user to complete the authorization
     * form
     */
    readonly types?: ReadonlyArray<PassportElementType$Input>,
  }

  export type sendPhoneNumberConfirmationCode = {
    /** Sends phone number confirmation code to handle links of the type internalLinkTypePhoneNumberConfirmation */
    readonly _: 'sendPhoneNumberConfirmationCode',
    /** Hash value from the link */
    readonly hash?: string,
    /** Phone number value from the link */
    readonly phone_number?: string,
    /**
     * Settings for the authentication of the user's phone number; pass null to use
     * default settings
     */
    readonly settings?: phoneNumberAuthenticationSettings$Input,
  }

  export type resendPhoneNumberConfirmationCode = {
    /** Resends phone number confirmation code */
    readonly _: 'resendPhoneNumberConfirmationCode',
  }

  export type checkPhoneNumberConfirmationCode = {
    /** Checks phone number confirmation code */
    readonly _: 'checkPhoneNumberConfirmationCode',
    /** Confirmation code to check */
    readonly code?: string,
  }

  export type setBotUpdatesStatus = {
    /**
     * Informs the server about the number of pending bot updates if they haven't been
     * processed for a long time; for bots only
     */
    readonly _: 'setBotUpdatesStatus',
    /** The number of pending updates */
    readonly pending_update_count?: number,
    /** The last error message */
    readonly error_message?: string,
  }

  export type uploadStickerFile = {
    /** Uploads a file with a sticker; returns the uploaded file */
    readonly _: 'uploadStickerFile',
    /** Sticker file owner; ignored for regular users */
    readonly user_id?: number,
    /** Sticker format */
    readonly sticker_format?: StickerFormat$Input,
    /**
     * File file to upload; must fit in a 512x512 square. For WEBP stickers the file
     * must be in WEBP or PNG format, which will be converted to WEBP server-side.
     * See https://core.telegram.org/animated_stickers#technical-requirements for technical
     * requirements
     */
    readonly sticker?: InputFile$Input,
  }

  export type getSuggestedStickerSetName = {
    /** Returns a suggested name for a new sticker set with a given title */
    readonly _: 'getSuggestedStickerSetName',
    /** Sticker set title; 1-64 characters */
    readonly title?: string,
  }

  export type checkStickerSetName = {
    /** Checks whether a name can be used for a new sticker set */
    readonly _: 'checkStickerSetName',
    /** Name to be checked */
    readonly name?: string,
  }

  export type createNewStickerSet = {
    /** Creates a new sticker set. Returns the newly created sticker set */
    readonly _: 'createNewStickerSet',
    /** Sticker set owner; ignored for regular users */
    readonly user_id?: number,
    /** Sticker set title; 1-64 characters */
    readonly title?: string,
    /**
     * Sticker set name. Can contain only English letters, digits and underscores.
     * Must end with *"_by_<bot username>"* (*<bot_username>* is case insensitive)
     * for bots; 1-64 characters
     */
    readonly name?: string,
    /** Format of the stickers in the set */
    readonly sticker_format?: StickerFormat$Input,
    /** Type of the stickers in the set */
    readonly sticker_type?: StickerType$Input,
    /**
     * Pass true if stickers in the sticker set must be repainted; for custom emoji
     * sticker sets only
     */
    readonly needs_repainting?: boolean,
    /**
     * List of stickers to be added to the set; must be non-empty. All stickers must
     * have the same format. For TGS stickers, uploadStickerFile must be used before
     * the sticker is shown
     */
    readonly stickers?: ReadonlyArray<inputSticker$Input>,
    /** Source of the sticker set; may be empty if unknown */
    readonly source?: string,
  }

  export type addStickerToSet = {
    /** Adds a new sticker to a set; for bots only */
    readonly _: 'addStickerToSet',
    /** Sticker set owner */
    readonly user_id?: number,
    /** Sticker set name */
    readonly name?: string,
    /** Sticker to add to the set */
    readonly sticker?: inputSticker$Input,
  }

  export type setStickerSetThumbnail = {
    /** Sets a sticker set thumbnail; for bots only */
    readonly _: 'setStickerSetThumbnail',
    /** Sticker set owner */
    readonly user_id?: number,
    /** Sticker set name */
    readonly name?: string,
    /**
     * Thumbnail to set in PNG, TGS, or WEBM format; pass null to remove the sticker
     * set thumbnail. Thumbnail format must match the format of stickers in the set
     */
    readonly thumbnail?: InputFile$Input,
  }

  export type setCustomEmojiStickerSetThumbnail = {
    /** Sets a custom emoji sticker set thumbnail; for bots only */
    readonly _: 'setCustomEmojiStickerSetThumbnail',
    /** Sticker set name */
    readonly name?: string,
    /**
     * Identifier of the custom emoji from the sticker set, which will be set as sticker
     * set thumbnail; pass 0 to remove the sticker set thumbnail
     */
    readonly custom_emoji_id?: number | string,
  }

  export type setStickerSetTitle = {
    /** Sets a sticker set title; for bots only */
    readonly _: 'setStickerSetTitle',
    /** Sticker set name */
    readonly name?: string,
    /** New sticker set title */
    readonly title?: string,
  }

  export type deleteStickerSet = {
    /** Deleted a sticker set; for bots only */
    readonly _: 'deleteStickerSet',
    /** Sticker set name */
    readonly name?: string,
  }

  export type setStickerPositionInSet = {
    /**
     * Changes the position of a sticker in the set to which it belongs; for bots only.
     * The sticker set must have been created by the bot
     */
    readonly _: 'setStickerPositionInSet',
    /** Sticker */
    readonly sticker?: InputFile$Input,
    /** New position of the sticker in the set, 0-based */
    readonly position?: number,
  }

  export type removeStickerFromSet = {
    /**
     * Removes a sticker from the set to which it belongs; for bots only. The sticker
     * set must have been created by the bot
     */
    readonly _: 'removeStickerFromSet',
    /** Sticker */
    readonly sticker?: InputFile$Input,
  }

  export type setStickerEmojis = {
    /**
     * Changes the list of emoji corresponding to a sticker; for bots only. The sticker
     * must belong to a regular or custom emoji sticker set created by the bot
     */
    readonly _: 'setStickerEmojis',
    /** Sticker */
    readonly sticker?: InputFile$Input,
    /** New string with 1-20 emoji corresponding to the sticker */
    readonly emojis?: string,
  }

  export type setStickerKeywords = {
    /**
     * Changes the list of keywords of a sticker; for bots only. The sticker must belong
     * to a regular or custom emoji sticker set created by the bot
     */
    readonly _: 'setStickerKeywords',
    /** Sticker */
    readonly sticker?: InputFile$Input,
    /**
     * List of up to 20 keywords with total length up to 64 characters, which can be
     * used to find the sticker
     */
    readonly keywords?: ReadonlyArray<string>,
  }

  export type setStickerMaskPosition = {
    /**
     * Changes the mask position of a mask sticker; for bots only. The sticker must
     * belong to a mask sticker set created by the bot
     */
    readonly _: 'setStickerMaskPosition',
    /** Sticker */
    readonly sticker?: InputFile$Input,
    /** Position where the mask is placed; pass null to remove mask position */
    readonly mask_position?: maskPosition$Input,
  }

  export type getMapThumbnailFile = {
    /**
     * Returns information about a file with a map thumbnail in PNG format. Only map
     * thumbnail files with size less than 1MB can be downloaded
     */
    readonly _: 'getMapThumbnailFile',
    /** Location of the map center */
    readonly location?: location$Input,
    /** Map zoom level; 13-20 */
    readonly zoom?: number,
    /** Map width in pixels before applying scale; 16-1024 */
    readonly width?: number,
    /** Map height in pixels before applying scale; 16-1024 */
    readonly height?: number,
    /** Map scale; 1-3 */
    readonly scale?: number,
    /** Identifier of a chat in which the thumbnail will be shown. Use 0 if unknown */
    readonly chat_id?: number,
  }

  export type getPremiumLimit = {
    /**
     * Returns information about a limit, increased for Premium users. Returns a 404
     * error if the limit is unknown
     */
    readonly _: 'getPremiumLimit',
    /** Type of the limit */
    readonly limit_type?: PremiumLimitType$Input,
  }

  export type getPremiumFeatures = {
    /** Returns information about features, available to Premium users */
    readonly _: 'getPremiumFeatures',
    /**
     * Source of the request; pass null if the method is called from some non-standard
     * source
     */
    readonly source?: PremiumSource$Input,
  }

  export type getPremiumStickerExamples = {
    /** Returns examples of premium stickers for demonstration purposes */
    readonly _: 'getPremiumStickerExamples',
  }

  export type viewPremiumFeature = {
    /**
     * Informs TDLib that the user viewed detailed information about a Premium feature
     * on the Premium features screen
     */
    readonly _: 'viewPremiumFeature',
    /** The viewed premium feature */
    readonly feature?: PremiumFeature$Input,
  }

  export type clickPremiumSubscriptionButton = {
    /**
     * Informs TDLib that the user clicked Premium subscription button on the Premium
     * features screen
     */
    readonly _: 'clickPremiumSubscriptionButton',
  }

  export type getPremiumState = {
    /**
     * Returns state of Telegram Premium subscription and promotion videos for Premium
     * features
     */
    readonly _: 'getPremiumState',
  }

  export type canPurchasePremium = {
    /**
     * Checks whether Telegram Premium purchase is possible. Must be called before
     * in-store Premium purchase
     */
    readonly _: 'canPurchasePremium',
    /** Transaction purpose */
    readonly purpose?: StorePaymentPurpose$Input,
  }

  export type assignAppStoreTransaction = {
    /**
     * Informs server about a purchase through App Store. For official applications
     * only
     */
    readonly _: 'assignAppStoreTransaction',
    /** App Store receipt */
    readonly receipt?: string,
    /** Transaction purpose */
    readonly purpose?: StorePaymentPurpose$Input,
  }

  export type assignGooglePlayTransaction = {
    /**
     * Informs server about a purchase through Google Play. For official applications
     * only
     */
    readonly _: 'assignGooglePlayTransaction',
    /** Application package name */
    readonly package_name?: string,
    /** Identifier of the purchased store product */
    readonly store_product_id?: string,
    /** Google Play purchase token */
    readonly purchase_token?: string,
    /** Transaction purpose */
    readonly purpose?: StorePaymentPurpose$Input,
  }

  export type acceptTermsOfService = {
    /** Accepts Telegram terms of services */
    readonly _: 'acceptTermsOfService',
    /** Terms of service identifier */
    readonly terms_of_service_id?: string,
  }

  export type searchStringsByPrefix = {
    /**
     * Searches specified query by word prefixes in the provided strings. Returns 0-based
     * positions of strings that matched. Can be called synchronously
     */
    readonly _: 'searchStringsByPrefix',
    /** The strings to search in for the query */
    readonly strings?: ReadonlyArray<string>,
    /** Query to search for */
    readonly query?: string,
    /** The maximum number of objects to return */
    readonly limit?: number,
    /** Pass true to receive no results for an empty query */
    readonly return_none_for_empty_query?: boolean,
  }

  export type sendCustomRequest = {
    /** Sends a custom request; for bots only */
    readonly _: 'sendCustomRequest',
    /** The method name */
    readonly method?: string,
    /** JSON-serialized method parameters */
    readonly parameters?: string,
  }

  export type answerCustomQuery = {
    /** Answers a custom query; for bots only */
    readonly _: 'answerCustomQuery',
    /** Identifier of a custom query */
    readonly custom_query_id?: number | string,
    /** JSON-serialized answer to the query */
    readonly data?: string,
  }

  export type setAlarm = {
    /** Succeeds after a specified amount of time has passed. Can be called before initialization */
    readonly _: 'setAlarm',
    /** Number of seconds before the function returns */
    readonly seconds?: number,
  }

  export type getCountries = {
    /** Returns information about existing countries. Can be called before authorization */
    readonly _: 'getCountries',
  }

  export type getCountryCode = {
    /**
     * Uses the current IP address to find the current country. Returns two-letter
     * ISO 3166-1 alpha-2 country code. Can be called before authorization
     */
    readonly _: 'getCountryCode',
  }

  export type getPhoneNumberInfo = {
    /**
     * Returns information about a phone number by its prefix. Can be called before
     * authorization
     */
    readonly _: 'getPhoneNumberInfo',
    /** The phone number prefix */
    readonly phone_number_prefix?: string,
  }

  export type getPhoneNumberInfoSync = {
    /**
     * Returns information about a phone number by its prefix synchronously. getCountries
     * must be called at least once after changing localization to the specified language
     * if properly localized country information is expected. Can be called synchronously
     */
    readonly _: 'getPhoneNumberInfoSync',
    /** A two-letter ISO 639-1 language code for country information localization */
    readonly language_code?: string,
    /** The phone number prefix */
    readonly phone_number_prefix?: string,
  }

  export type getDeepLinkInfo = {
    /**
     * Returns information about a tg:// deep link. Use "tg://need_update_for_some_feature"
     * or "tg:some_unsupported_feature" for testing. Returns a 404 error for unknown
     * links. Can be called before authorization
     */
    readonly _: 'getDeepLinkInfo',
    /** The link */
    readonly link?: string,
  }

  export type getApplicationConfig = {
    /** Returns application config, provided by the server. Can be called before authorization */
    readonly _: 'getApplicationConfig',
  }

  export type addApplicationChangelog = {
    /**
     * Adds server-provided application changelog as messages to the chat 777000 (Telegram)
     * or as a stories; for official applications only. Returns a 404 error if nothing
     * changed
     */
    readonly _: 'addApplicationChangelog',
    /** The previous application version */
    readonly previous_application_version?: string,
  }

  export type saveApplicationLogEvent = {
    /** Saves application log event on the server. Can be called before authorization */
    readonly _: 'saveApplicationLogEvent',
    /** Event type */
    readonly type?: string,
    /** Optional chat identifier, associated with the event */
    readonly chat_id?: number,
    /** The log event data */
    readonly data?: JsonValue$Input,
  }

  export type getApplicationDownloadLink = {
    /**
     * Returns the link for downloading official Telegram application to be used when
     * the current user invites friends to Telegram
     */
    readonly _: 'getApplicationDownloadLink',
  }

  export type addProxy = {
    /** Adds a proxy server for network requests. Can be called before authorization */
    readonly _: 'addProxy',
    /** Proxy server domain or IP address */
    readonly server?: string,
    /** Proxy server port */
    readonly port?: number,
    /** Pass true to immediately enable the proxy */
    readonly enable?: boolean,
    /** Proxy type */
    readonly type?: ProxyType$Input,
  }

  export type editProxy = {
    /** Edits an existing proxy server for network requests. Can be called before authorization */
    readonly _: 'editProxy',
    /** Proxy identifier */
    readonly proxy_id?: number,
    /** Proxy server domain or IP address */
    readonly server?: string,
    /** Proxy server port */
    readonly port?: number,
    /** Pass true to immediately enable the proxy */
    readonly enable?: boolean,
    /** Proxy type */
    readonly type?: ProxyType$Input,
  }

  export type enableProxy = {
    /**
     * Enables a proxy. Only one proxy can be enabled at a time. Can be called before
     * authorization
     */
    readonly _: 'enableProxy',
    /** Proxy identifier */
    readonly proxy_id?: number,
  }

  export type disableProxy = {
    /** Disables the currently enabled proxy. Can be called before authorization */
    readonly _: 'disableProxy',
  }

  export type removeProxy = {
    /** Removes a proxy server. Can be called before authorization */
    readonly _: 'removeProxy',
    /** Proxy identifier */
    readonly proxy_id?: number,
  }

  export type getProxies = {
    /** Returns list of proxies that are currently set up. Can be called before authorization */
    readonly _: 'getProxies',
  }

  export type getProxyLink = {
    /**
     * Returns an HTTPS link, which can be used to add a proxy. Available only for
     * SOCKS5 and MTProto proxies. Can be called before authorization
     */
    readonly _: 'getProxyLink',
    /** Proxy identifier */
    readonly proxy_id?: number,
  }

  export type pingProxy = {
    /**
     * Computes time needed to receive a response from a Telegram server through a
     * proxy. Can be called before authorization
     */
    readonly _: 'pingProxy',
    /** Proxy identifier. Use 0 to ping a Telegram server without a proxy */
    readonly proxy_id?: number,
  }

  export type setLogStream = {
    /** Sets new log stream for internal logging of TDLib. Can be called synchronously */
    readonly _: 'setLogStream',
    /** New log stream */
    readonly log_stream?: LogStream$Input,
  }

  export type getLogStream = {
    /**
     * Returns information about currently used log stream for internal logging of
     * TDLib. Can be called synchronously
     */
    readonly _: 'getLogStream',
  }

  export type setLogVerbosityLevel = {
    /** Sets the verbosity level of the internal logging of TDLib. Can be called synchronously */
    readonly _: 'setLogVerbosityLevel',
    /**
     * New value of the verbosity level for logging. Value 0 corresponds to fatal errors,
     * value 1 corresponds to errors, value 2 corresponds to warnings and debug warnings,
     * value 3 corresponds to informational, value 4 corresponds to debug, value 5
     * corresponds to verbose debug, value greater than 5 and up to 1023 can be used
     * to enable even more logging
     */
    readonly new_verbosity_level?: number,
  }

  export type getLogVerbosityLevel = {
    /**
     * Returns current verbosity level of the internal logging of TDLib. Can be called
     * synchronously
     */
    readonly _: 'getLogVerbosityLevel',
  }

  export type getLogTags = {
    /**
     * Returns list of available TDLib internal log tags, for example, ["actor", "binlog",
     * "connections", "notifications", "proxy"]. Can be called synchronously
     */
    readonly _: 'getLogTags',
  }

  export type setLogTagVerbosityLevel = {
    /**
     * Sets the verbosity level for a specified TDLib internal log tag. Can be called
     * synchronously
     */
    readonly _: 'setLogTagVerbosityLevel',
    /** Logging tag to change verbosity level */
    readonly tag?: string,
    /** New verbosity level; 1-1024 */
    readonly new_verbosity_level?: number,
  }

  export type getLogTagVerbosityLevel = {
    /**
     * Returns current verbosity level for a specified TDLib internal log tag. Can
     * be called synchronously
     */
    readonly _: 'getLogTagVerbosityLevel',
    /** Logging tag to change verbosity level */
    readonly tag?: string,
  }

  export type addLogMessage = {
    /** Adds a message to TDLib internal log. Can be called synchronously */
    readonly _: 'addLogMessage',
    /** The minimum verbosity level needed for the message to be logged; 0-1023 */
    readonly verbosity_level?: number,
    /** Text of a message to log */
    readonly text?: string,
  }

  export type getUserSupportInfo = {
    /** Returns support information for the given user; for Telegram support only */
    readonly _: 'getUserSupportInfo',
    /** User identifier */
    readonly user_id?: number,
  }

  export type setUserSupportInfo = {
    /** Sets support information for the given user; for Telegram support only */
    readonly _: 'setUserSupportInfo',
    /** User identifier */
    readonly user_id?: number,
    /** New information message */
    readonly message?: formattedText$Input,
  }

  export type getSupportName = {
    /** Returns localized name of the Telegram support user; for Telegram support only */
    readonly _: 'getSupportName',
  }

  export type testCallEmpty = {
    /**
     * Does nothing; for testing only. This is an offline method. Can be called before
     * authorization
     */
    readonly _: 'testCallEmpty',
  }

  export type testCallString = {
    /**
     * Returns the received string; for testing only. This is an offline method. Can
     * be called before authorization
     */
    readonly _: 'testCallString',
    /** String to return */
    readonly x?: string,
  }

  export type testCallBytes = {
    /**
     * Returns the received bytes; for testing only. This is an offline method. Can
     * be called before authorization
     */
    readonly _: 'testCallBytes',
    /** Bytes to return */
    readonly x?: string,
  }

  export type testCallVectorInt = {
    /**
     * Returns the received vector of numbers; for testing only. This is an offline
     * method. Can be called before authorization
     */
    readonly _: 'testCallVectorInt',
    /** Vector of numbers to return */
    readonly x?: ReadonlyArray<number>,
  }

  export type testCallVectorIntObject = {
    /**
     * Returns the received vector of objects containing a number; for testing only.
     * This is an offline method. Can be called before authorization
     */
    readonly _: 'testCallVectorIntObject',
    /** Vector of objects to return */
    readonly x?: ReadonlyArray<testInt$Input>,
  }

  export type testCallVectorString = {
    /**
     * Returns the received vector of strings; for testing only. This is an offline
     * method. Can be called before authorization
     */
    readonly _: 'testCallVectorString',
    /** Vector of strings to return */
    readonly x?: ReadonlyArray<string>,
  }

  export type testCallVectorStringObject = {
    /**
     * Returns the received vector of objects containing a string; for testing only.
     * This is an offline method. Can be called before authorization
     */
    readonly _: 'testCallVectorStringObject',
    /** Vector of objects to return */
    readonly x?: ReadonlyArray<testString$Input>,
  }

  export type testSquareInt = {
    /**
     * Returns the squared received number; for testing only. This is an offline method.
     * Can be called before authorization
     */
    readonly _: 'testSquareInt',
    /** Number to square */
    readonly x?: number,
  }

  export type testNetwork = {
    /**
     * Sends a simple network request to the Telegram servers; for testing only. Can
     * be called before authorization
     */
    readonly _: 'testNetwork',
  }

  export type testProxy = {
    /**
     * Sends a simple network request to the Telegram servers via proxy; for testing
     * only. Can be called before authorization
     */
    readonly _: 'testProxy',
    /** Proxy server domain or IP address */
    readonly server?: string,
    /** Proxy server port */
    readonly port?: number,
    /** Proxy type */
    readonly type?: ProxyType$Input,
    /** Identifier of a datacenter with which to test connection */
    readonly dc_id?: number,
    /** The maximum overall timeout for the request */
    readonly timeout?: number,
  }

  export type testGetDifference = {
    /** Forces an updates.getDifference call to the Telegram servers; for testing only */
    readonly _: 'testGetDifference',
  }

  export type testUseUpdate = {
    /**
     * Does nothing and ensures that the Update object is used; for testing only. This
     * is an offline method. Can be called before authorization
     */
    readonly _: 'testUseUpdate',
  }

  export type testReturnError = {
    /**
     * Returns the specified error and ensures that the Error object is used; for testing
     * only. Can be called synchronously
     */
    readonly _: 'testReturnError',
    /** The error to be returned */
    readonly error?: error$Input,
  }

  // ----

  export type Error = error

  export type Ok = ok

  /**
   * Provides information about the method by which an authentication code is delivered
   * to the user
   */
  export type AuthenticationCodeType =
    | authenticationCodeTypeTelegramMessage
    | authenticationCodeTypeSms
    | authenticationCodeTypeCall
    | authenticationCodeTypeFlashCall
    | authenticationCodeTypeMissedCall
    | authenticationCodeTypeFragment
    | authenticationCodeTypeFirebaseAndroid
    | authenticationCodeTypeFirebaseIos

  export type AuthenticationCodeInfo = authenticationCodeInfo

  export type EmailAddressAuthenticationCodeInfo = emailAddressAuthenticationCodeInfo

  /** Contains authentication data for a email address */
  export type EmailAddressAuthentication$Input =
    | emailAddressAuthenticationCode$Input
    | emailAddressAuthenticationAppleId$Input
    | emailAddressAuthenticationGoogleId$Input

  /** Describes reset state of a email address */
  export type EmailAddressResetState =
    | emailAddressResetStateAvailable
    | emailAddressResetStatePending

  export type TextEntities = textEntities

  export type FormattedText = formattedText

  /** Represents the current authorization state of the TDLib client */
  export type AuthorizationState =
    | authorizationStateWaitTdlibParameters
    | authorizationStateWaitPhoneNumber
    | authorizationStateWaitEmailAddress
    | authorizationStateWaitEmailCode
    | authorizationStateWaitCode
    | authorizationStateWaitOtherDeviceConfirmation
    | authorizationStateWaitRegistration
    | authorizationStateWaitPassword
    | authorizationStateReady
    | authorizationStateLoggingOut
    | authorizationStateClosing
    | authorizationStateClosed

  export type PasswordState = passwordState

  export type RecoveryEmailAddress = recoveryEmailAddress

  export type TemporaryPasswordState = temporaryPasswordState

  export type File = file

  /** Points to a file */
  export type InputFile =
    | inputFileId
    | inputFileRemote
    | inputFileLocal
    | inputFileGenerated

  /** Points to a file */
  export type InputFile$Input =
    | inputFileId$Input
    | inputFileRemote$Input
    | inputFileLocal$Input
    | inputFileGenerated$Input

  /** Describes format of a thumbnail */
  export type ThumbnailFormat =
    | thumbnailFormatJpeg
    | thumbnailFormatGif
    | thumbnailFormatMpeg4
    | thumbnailFormatPng
    | thumbnailFormatTgs
    | thumbnailFormatWebm
    | thumbnailFormatWebp

  /** Part of the face, relative to which a mask is placed */
  export type MaskPoint =
    | maskPointForehead
    | maskPointEyes
    | maskPointMouth
    | maskPointChin

  /** Part of the face, relative to which a mask is placed */
  export type MaskPoint$Input =
    | maskPointForehead$Input
    | maskPointEyes$Input
    | maskPointMouth$Input
    | maskPointChin$Input

  /** Describes format of a sticker */
  export type StickerFormat =
    | stickerFormatWebp
    | stickerFormatTgs
    | stickerFormatWebm

  /** Describes format of a sticker */
  export type StickerFormat$Input =
    | stickerFormatWebp$Input
    | stickerFormatTgs$Input
    | stickerFormatWebm$Input

  /** Describes type of a sticker */
  export type StickerType =
    | stickerTypeRegular
    | stickerTypeMask
    | stickerTypeCustomEmoji

  /** Describes type of a sticker */
  export type StickerType$Input =
    | stickerTypeRegular$Input
    | stickerTypeMask$Input
    | stickerTypeCustomEmoji$Input

  /** Contains full information about sticker type */
  export type StickerFullType =
    | stickerFullTypeRegular
    | stickerFullTypeMask
    | stickerFullTypeCustomEmoji

  /** Describes the type of a poll */
  export type PollType =
    | pollTypeRegular
    | pollTypeQuiz

  /** Describes the type of a poll */
  export type PollType$Input =
    | pollTypeRegular$Input
    | pollTypeQuiz$Input

  export type Sticker = sticker

  export type AnimatedEmoji = animatedEmoji

  export type Background = background

  export type Backgrounds = backgrounds

  /**
   * Represents the type of a user. The following types are possible: regular users,
   * deleted users and bots
   */
  export type UserType =
    | userTypeRegular
    | userTypeDeleted
    | userTypeBot
    | userTypeUnknown

  export type BotCommands = botCommands

  export type BotMenuButton = botMenuButton

  /** Describes type of a sticker, which was used to create a chat photo */
  export type ChatPhotoStickerType =
    | chatPhotoStickerTypeRegularOrMask
    | chatPhotoStickerTypeCustomEmoji

  /** Describes type of a sticker, which was used to create a chat photo */
  export type ChatPhotoStickerType$Input =
    | chatPhotoStickerTypeRegularOrMask$Input
    | chatPhotoStickerTypeCustomEmoji$Input

  export type ChatPhotos = chatPhotos

  /** Describes a photo to be set as a user profile or chat photo */
  export type InputChatPhoto$Input =
    | inputChatPhotoPrevious$Input
    | inputChatPhotoStatic$Input
    | inputChatPhotoAnimation$Input
    | inputChatPhotoSticker$Input

  export type EmojiStatuses = emojiStatuses

  export type User = user

  export type UserFullInfo = userFullInfo

  export type Users = users

  export type ChatAdministrators = chatAdministrators

  /** Provides information about the status of a member in a chat */
  export type ChatMemberStatus =
    | chatMemberStatusCreator
    | chatMemberStatusAdministrator
    | chatMemberStatusMember
    | chatMemberStatusRestricted
    | chatMemberStatusLeft
    | chatMemberStatusBanned

  /** Provides information about the status of a member in a chat */
  export type ChatMemberStatus$Input =
    | chatMemberStatusCreator$Input
    | chatMemberStatusAdministrator$Input
    | chatMemberStatusMember$Input
    | chatMemberStatusRestricted$Input
    | chatMemberStatusLeft$Input
    | chatMemberStatusBanned$Input

  export type ChatMember = chatMember

  export type ChatMembers = chatMembers

  /** Specifies the kind of chat members to return in searchChatMembers */
  export type ChatMembersFilter$Input =
    | chatMembersFilterContacts$Input
    | chatMembersFilterAdministrators$Input
    | chatMembersFilterMembers$Input
    | chatMembersFilterMention$Input
    | chatMembersFilterRestricted$Input
    | chatMembersFilterBanned$Input
    | chatMembersFilterBots$Input

  /** Specifies the kind of chat members to return in getSupergroupMembers */
  export type SupergroupMembersFilter$Input =
    | supergroupMembersFilterRecent$Input
    | supergroupMembersFilterContacts$Input
    | supergroupMembersFilterAdministrators$Input
    | supergroupMembersFilterSearch$Input
    | supergroupMembersFilterRestricted$Input
    | supergroupMembersFilterBanned$Input
    | supergroupMembersFilterMention$Input
    | supergroupMembersFilterBots$Input

  export type ChatInviteLink = chatInviteLink

  export type ChatInviteLinks = chatInviteLinks

  export type ChatInviteLinkCounts = chatInviteLinkCounts

  export type ChatInviteLinkMembers = chatInviteLinkMembers

  /** Describes the type of a chat to which points an invite link */
  export type InviteLinkChatType =
    | inviteLinkChatTypeBasicGroup
    | inviteLinkChatTypeSupergroup
    | inviteLinkChatTypeChannel

  export type ChatInviteLinkInfo = chatInviteLinkInfo

  export type ChatJoinRequests = chatJoinRequests

  export type BasicGroup = basicGroup

  export type BasicGroupFullInfo = basicGroupFullInfo

  export type Supergroup = supergroup

  export type SupergroupFullInfo = supergroupFullInfo

  /** Describes the current secret chat state */
  export type SecretChatState =
    | secretChatStatePending
    | secretChatStateReady
    | secretChatStateClosed

  export type SecretChat = secretChat

  /** Contains information about the sender of a message */
  export type MessageSender =
    | messageSenderUser
    | messageSenderChat

  /** Contains information about the sender of a message */
  export type MessageSender$Input =
    | messageSenderUser$Input
    | messageSenderChat$Input

  export type MessageSenders = messageSenders

  export type ChatMessageSenders = chatMessageSenders

  export type MessageViewers = messageViewers

  /** Contains information about the origin of a forwarded message */
  export type MessageForwardOrigin =
    | messageForwardOriginUser
    | messageForwardOriginChat
    | messageForwardOriginHiddenUser
    | messageForwardOriginChannel
    | messageForwardOriginMessageImport

  /** Describes type of message reaction */
  export type ReactionType =
    | reactionTypeEmoji
    | reactionTypeCustomEmoji

  /** Describes type of message reaction */
  export type ReactionType$Input =
    | reactionTypeEmoji$Input
    | reactionTypeCustomEmoji$Input

  /** Contains information about the sending state of the message */
  export type MessageSendingState =
    | messageSendingStatePending
    | messageSendingStateFailed

  /** Contains information about the message or the story a message is replying to */
  export type MessageReplyTo =
    | messageReplyToMessage
    | messageReplyToStory

  /** Contains information about the message or the story a message is replying to */
  export type MessageReplyTo$Input =
    | messageReplyToMessage$Input
    | messageReplyToStory$Input

  export type Message = message

  export type Messages = messages

  export type FoundMessages = foundMessages

  export type FoundChatMessages = foundChatMessages

  export type MessagePositions = messagePositions

  export type MessageCalendar = messageCalendar

  /** Describes source of a message */
  export type MessageSource$Input =
    | messageSourceChatHistory$Input
    | messageSourceMessageThreadHistory$Input
    | messageSourceForumTopicHistory$Input
    | messageSourceHistoryPreview$Input
    | messageSourceChatList$Input
    | messageSourceSearch$Input
    | messageSourceChatEventLog$Input
    | messageSourceNotification$Input
    | messageSourceScreenshot$Input
    | messageSourceOther$Input

  /** Describes type of a message sponsor */
  export type MessageSponsorType =
    | messageSponsorTypeBot
    | messageSponsorTypePublicChannel
    | messageSponsorTypePrivateChannel
    | messageSponsorTypeWebsite

  export type SponsoredMessages = sponsoredMessages

  export type FoundFileDownloads = foundFileDownloads

  /** Describes the types of chats to which notification settings are relevant */
  export type NotificationSettingsScope =
    | notificationSettingsScopePrivateChats
    | notificationSettingsScopeGroupChats
    | notificationSettingsScopeChannelChats

  /** Describes the types of chats to which notification settings are relevant */
  export type NotificationSettingsScope$Input =
    | notificationSettingsScopePrivateChats$Input
    | notificationSettingsScopeGroupChats$Input
    | notificationSettingsScopeChannelChats$Input

  export type ScopeNotificationSettings = scopeNotificationSettings

  /** Describes the type of a chat */
  export type ChatType =
    | chatTypePrivate
    | chatTypeBasicGroup
    | chatTypeSupergroup
    | chatTypeSecret

  export type ChatFolderIcon = chatFolderIcon

  export type ChatFolder = chatFolder

  export type ChatFolderInfo = chatFolderInfo

  export type ChatFolderInviteLink = chatFolderInviteLink

  export type ChatFolderInviteLinks = chatFolderInviteLinks

  export type ChatFolderInviteLinkInfo = chatFolderInviteLinkInfo

  export type RecommendedChatFolders = recommendedChatFolders

  export type ArchiveChatListSettings = archiveChatListSettings

  /** Describes a list of chats */
  export type ChatList =
    | chatListMain
    | chatListArchive
    | chatListFolder

  /** Describes a list of chats */
  export type ChatList$Input =
    | chatListMain$Input
    | chatListArchive$Input
    | chatListFolder$Input

  export type ChatLists = chatLists

  /** Describes a reason why an external chat is shown in a chat list */
  export type ChatSource =
    | chatSourceMtprotoProxy
    | chatSourcePublicServiceAnnouncement

  /** Describes reactions available in the chat */
  export type ChatAvailableReactions =
    | chatAvailableReactionsAll
    | chatAvailableReactionsSome

  /** Describes reactions available in the chat */
  export type ChatAvailableReactions$Input =
    | chatAvailableReactionsAll$Input
    | chatAvailableReactionsSome$Input

  export type Chat = chat

  export type Chats = chats

  export type ChatsNearby = chatsNearby

  /** Describes a type of public chats */
  export type PublicChatType$Input =
    | publicChatTypeHasUsername$Input
    | publicChatTypeIsLocationBased$Input

  /** Describes actions which must be possible to do through a chat action bar */
  export type ChatActionBar =
    | chatActionBarReportSpam
    | chatActionBarReportUnrelatedLocation
    | chatActionBarInviteMembers
    | chatActionBarReportAddBlock
    | chatActionBarAddContact
    | chatActionBarSharePhoneNumber
    | chatActionBarJoinRequest

  /** Describes a keyboard button type */
  export type KeyboardButtonType =
    | keyboardButtonTypeText
    | keyboardButtonTypeRequestPhoneNumber
    | keyboardButtonTypeRequestLocation
    | keyboardButtonTypeRequestPoll
    | keyboardButtonTypeRequestUser
    | keyboardButtonTypeRequestChat
    | keyboardButtonTypeWebApp

  /** Describes a keyboard button type */
  export type KeyboardButtonType$Input =
    | keyboardButtonTypeText$Input
    | keyboardButtonTypeRequestPhoneNumber$Input
    | keyboardButtonTypeRequestLocation$Input
    | keyboardButtonTypeRequestPoll$Input
    | keyboardButtonTypeRequestUser$Input
    | keyboardButtonTypeRequestChat$Input
    | keyboardButtonTypeWebApp$Input

  /** Describes the type of an inline keyboard button */
  export type InlineKeyboardButtonType =
    | inlineKeyboardButtonTypeUrl
    | inlineKeyboardButtonTypeLoginUrl
    | inlineKeyboardButtonTypeWebApp
    | inlineKeyboardButtonTypeCallback
    | inlineKeyboardButtonTypeCallbackWithPassword
    | inlineKeyboardButtonTypeCallbackGame
    | inlineKeyboardButtonTypeSwitchInline
    | inlineKeyboardButtonTypeBuy
    | inlineKeyboardButtonTypeUser

  /** Describes the type of an inline keyboard button */
  export type InlineKeyboardButtonType$Input =
    | inlineKeyboardButtonTypeUrl$Input
    | inlineKeyboardButtonTypeLoginUrl$Input
    | inlineKeyboardButtonTypeWebApp$Input
    | inlineKeyboardButtonTypeCallback$Input
    | inlineKeyboardButtonTypeCallbackWithPassword$Input
    | inlineKeyboardButtonTypeCallbackGame$Input
    | inlineKeyboardButtonTypeSwitchInline$Input
    | inlineKeyboardButtonTypeBuy$Input
    | inlineKeyboardButtonTypeUser$Input

  /**
   * Contains a description of a custom keyboard and actions that can be done with
   * it to quickly reply to bots
   */
  export type ReplyMarkup =
    | replyMarkupRemoveKeyboard
    | replyMarkupForceReply
    | replyMarkupShowKeyboard
    | replyMarkupInlineKeyboard

  /**
   * Contains a description of a custom keyboard and actions that can be done with
   * it to quickly reply to bots
   */
  export type ReplyMarkup$Input =
    | replyMarkupRemoveKeyboard$Input
    | replyMarkupForceReply$Input
    | replyMarkupShowKeyboard$Input
    | replyMarkupInlineKeyboard$Input

  /** Contains information about an inline button of type inlineKeyboardButtonTypeLoginUrl */
  export type LoginUrlInfo =
    | loginUrlInfoOpen
    | loginUrlInfoRequestConfirmation

  export type FoundWebApp = foundWebApp

  export type WebAppInfo = webAppInfo

  export type MessageThreadInfo = messageThreadInfo

  export type ForumTopicInfo = forumTopicInfo

  export type ForumTopic = forumTopic

  export type ForumTopics = forumTopics

  /** Describes a text object inside an instant-view web page */
  export type RichText =
    | richTextPlain
    | richTextBold
    | richTextItalic
    | richTextUnderline
    | richTextStrikethrough
    | richTextFixed
    | richTextUrl
    | richTextEmailAddress
    | richTextSubscript
    | richTextSuperscript
    | richTextMarked
    | richTextPhoneNumber
    | richTextIcon
    | richTextReference
    | richTextAnchor
    | richTextAnchorLink
    | richTexts

  /** Describes a horizontal alignment of a table cell content */
  export type PageBlockHorizontalAlignment =
    | pageBlockHorizontalAlignmentLeft
    | pageBlockHorizontalAlignmentCenter
    | pageBlockHorizontalAlignmentRight

  /** Describes a Vertical alignment of a table cell content */
  export type PageBlockVerticalAlignment =
    | pageBlockVerticalAlignmentTop
    | pageBlockVerticalAlignmentMiddle
    | pageBlockVerticalAlignmentBottom

  /** Describes a block of an instant view web page */
  export type PageBlock =
    | pageBlockTitle
    | pageBlockSubtitle
    | pageBlockAuthorDate
    | pageBlockHeader
    | pageBlockSubheader
    | pageBlockKicker
    | pageBlockParagraph
    | pageBlockPreformatted
    | pageBlockFooter
    | pageBlockDivider
    | pageBlockAnchor
    | pageBlockList
    | pageBlockBlockQuote
    | pageBlockPullQuote
    | pageBlockAnimation
    | pageBlockAudio
    | pageBlockPhoto
    | pageBlockVideo
    | pageBlockVoiceNote
    | pageBlockCover
    | pageBlockEmbedded
    | pageBlockEmbeddedPost
    | pageBlockCollage
    | pageBlockSlideshow
    | pageBlockChatLink
    | pageBlockTable
    | pageBlockDetails
    | pageBlockRelatedArticles
    | pageBlockMap

  export type WebPageInstantView = webPageInstantView

  export type WebPage = webPage

  export type Countries = countries

  export type PhoneNumberInfo = phoneNumberInfo

  export type BankCardInfo = bankCardInfo

  export type OrderInfo = orderInfo

  /** Contains information about the payment method chosen by the user */
  export type InputCredentials$Input =
    | inputCredentialsSaved$Input
    | inputCredentialsNew$Input
    | inputCredentialsApplePay$Input
    | inputCredentialsGooglePay$Input

  /** Contains information about a payment provider */
  export type PaymentProvider =
    | paymentProviderSmartGlocal
    | paymentProviderStripe
    | paymentProviderOther

  export type PaymentForm = paymentForm

  export type ValidatedOrderInfo = validatedOrderInfo

  export type PaymentResult = paymentResult

  export type PaymentReceipt = paymentReceipt

  /** Describes an invoice to process */
  export type InputInvoice$Input =
    | inputInvoiceMessage$Input
    | inputInvoiceName$Input

  /** Describes a media, which is attached to an invoice */
  export type MessageExtendedMedia =
    | messageExtendedMediaPreview
    | messageExtendedMediaPhoto
    | messageExtendedMediaVideo
    | messageExtendedMediaUnsupported

  /** Contains the type of a Telegram Passport element */
  export type PassportElementType =
    | passportElementTypePersonalDetails
    | passportElementTypePassport
    | passportElementTypeDriverLicense
    | passportElementTypeIdentityCard
    | passportElementTypeInternalPassport
    | passportElementTypeAddress
    | passportElementTypeUtilityBill
    | passportElementTypeBankStatement
    | passportElementTypeRentalAgreement
    | passportElementTypePassportRegistration
    | passportElementTypeTemporaryRegistration
    | passportElementTypePhoneNumber
    | passportElementTypeEmailAddress

  /** Contains the type of a Telegram Passport element */
  export type PassportElementType$Input =
    | passportElementTypePersonalDetails$Input
    | passportElementTypePassport$Input
    | passportElementTypeDriverLicense$Input
    | passportElementTypeIdentityCard$Input
    | passportElementTypeInternalPassport$Input
    | passportElementTypeAddress$Input
    | passportElementTypeUtilityBill$Input
    | passportElementTypeBankStatement$Input
    | passportElementTypeRentalAgreement$Input
    | passportElementTypePassportRegistration$Input
    | passportElementTypeTemporaryRegistration$Input
    | passportElementTypePhoneNumber$Input
    | passportElementTypeEmailAddress$Input

  /** Contains information about a Telegram Passport element */
  export type PassportElement =
    | passportElementPersonalDetails
    | passportElementPassport
    | passportElementDriverLicense
    | passportElementIdentityCard
    | passportElementInternalPassport
    | passportElementAddress
    | passportElementUtilityBill
    | passportElementBankStatement
    | passportElementRentalAgreement
    | passportElementPassportRegistration
    | passportElementTemporaryRegistration
    | passportElementPhoneNumber
    | passportElementEmailAddress

  /** Contains information about a Telegram Passport element to be saved */
  export type InputPassportElement$Input =
    | inputPassportElementPersonalDetails$Input
    | inputPassportElementPassport$Input
    | inputPassportElementDriverLicense$Input
    | inputPassportElementIdentityCard$Input
    | inputPassportElementInternalPassport$Input
    | inputPassportElementAddress$Input
    | inputPassportElementUtilityBill$Input
    | inputPassportElementBankStatement$Input
    | inputPassportElementRentalAgreement$Input
    | inputPassportElementPassportRegistration$Input
    | inputPassportElementTemporaryRegistration$Input
    | inputPassportElementPhoneNumber$Input
    | inputPassportElementEmailAddress$Input

  export type PassportElements = passportElements

  /** Contains the description of an error in a Telegram Passport element */
  export type PassportElementErrorSource =
    | passportElementErrorSourceUnspecified
    | passportElementErrorSourceDataField
    | passportElementErrorSourceFrontSide
    | passportElementErrorSourceReverseSide
    | passportElementErrorSourceSelfie
    | passportElementErrorSourceTranslationFile
    | passportElementErrorSourceTranslationFiles
    | passportElementErrorSourceFile
    | passportElementErrorSourceFiles

  export type PassportAuthorizationForm = passportAuthorizationForm

  export type PassportElementsWithErrors = passportElementsWithErrors

  /**
   * Contains the description of an error in a Telegram Passport element; for bots
   * only
   */
  export type InputPassportElementErrorSource$Input =
    | inputPassportElementErrorSourceUnspecified$Input
    | inputPassportElementErrorSourceDataField$Input
    | inputPassportElementErrorSourceFrontSide$Input
    | inputPassportElementErrorSourceReverseSide$Input
    | inputPassportElementErrorSourceSelfie$Input
    | inputPassportElementErrorSourceTranslationFile$Input
    | inputPassportElementErrorSourceTranslationFiles$Input
    | inputPassportElementErrorSourceFile$Input
    | inputPassportElementErrorSourceFiles$Input

  /** Contains the content of a message */
  export type MessageContent =
    | messageText
    | messageAnimation
    | messageAudio
    | messageDocument
    | messagePhoto
    | messageExpiredPhoto
    | messageSticker
    | messageVideo
    | messageExpiredVideo
    | messageVideoNote
    | messageVoiceNote
    | messageLocation
    | messageVenue
    | messageContact
    | messageAnimatedEmoji
    | messageDice
    | messageGame
    | messagePoll
    | messageStory
    | messageInvoice
    | messageCall
    | messageVideoChatScheduled
    | messageVideoChatStarted
    | messageVideoChatEnded
    | messageInviteVideoChatParticipants
    | messageBasicGroupChatCreate
    | messageSupergroupChatCreate
    | messageChatChangeTitle
    | messageChatChangePhoto
    | messageChatDeletePhoto
    | messageChatAddMembers
    | messageChatJoinByLink
    | messageChatJoinByRequest
    | messageChatDeleteMember
    | messageChatUpgradeTo
    | messageChatUpgradeFrom
    | messagePinMessage
    | messageScreenshotTaken
    | messageChatSetBackground
    | messageChatSetTheme
    | messageChatSetMessageAutoDeleteTime
    | messageForumTopicCreated
    | messageForumTopicEdited
    | messageForumTopicIsClosedToggled
    | messageForumTopicIsHiddenToggled
    | messageSuggestProfilePhoto
    | messageCustomServiceAction
    | messageGameScore
    | messagePaymentSuccessful
    | messagePaymentSuccessfulBot
    | messageGiftedPremium
    | messageContactRegistered
    | messageUserShared
    | messageChatShared
    | messageWebsiteConnected
    | messageBotWriteAccessAllowed
    | messageWebAppDataSent
    | messageWebAppDataReceived
    | messagePassportDataSent
    | messagePassportDataReceived
    | messageProximityAlertTriggered
    | messageUnsupported

  /** Represents a part of the text which must be formatted differently */
  export type TextEntityType =
    | textEntityTypeMention
    | textEntityTypeHashtag
    | textEntityTypeCashtag
    | textEntityTypeBotCommand
    | textEntityTypeUrl
    | textEntityTypeEmailAddress
    | textEntityTypePhoneNumber
    | textEntityTypeBankCardNumber
    | textEntityTypeBold
    | textEntityTypeItalic
    | textEntityTypeUnderline
    | textEntityTypeStrikethrough
    | textEntityTypeSpoiler
    | textEntityTypeCode
    | textEntityTypePre
    | textEntityTypePreCode
    | textEntityTypeTextUrl
    | textEntityTypeMentionName
    | textEntityTypeCustomEmoji
    | textEntityTypeMediaTimestamp

  /** Represents a part of the text which must be formatted differently */
  export type TextEntityType$Input =
    | textEntityTypeMention$Input
    | textEntityTypeHashtag$Input
    | textEntityTypeCashtag$Input
    | textEntityTypeBotCommand$Input
    | textEntityTypeUrl$Input
    | textEntityTypeEmailAddress$Input
    | textEntityTypePhoneNumber$Input
    | textEntityTypeBankCardNumber$Input
    | textEntityTypeBold$Input
    | textEntityTypeItalic$Input
    | textEntityTypeUnderline$Input
    | textEntityTypeStrikethrough$Input
    | textEntityTypeSpoiler$Input
    | textEntityTypeCode$Input
    | textEntityTypePre$Input
    | textEntityTypePreCode$Input
    | textEntityTypeTextUrl$Input
    | textEntityTypeMentionName$Input
    | textEntityTypeCustomEmoji$Input
    | textEntityTypeMediaTimestamp$Input

  /** Contains information about the time when a scheduled message will be sent */
  export type MessageSchedulingState =
    | messageSchedulingStateSendAtDate
    | messageSchedulingStateSendWhenOnline

  /** Contains information about the time when a scheduled message will be sent */
  export type MessageSchedulingState$Input =
    | messageSchedulingStateSendAtDate$Input
    | messageSchedulingStateSendWhenOnline$Input

  /** Describes when a message will be self-destructed */
  export type MessageSelfDestructType =
    | messageSelfDestructTypeTimer
    | messageSelfDestructTypeImmediately

  /** Describes when a message will be self-destructed */
  export type MessageSelfDestructType$Input =
    | messageSelfDestructTypeTimer$Input
    | messageSelfDestructTypeImmediately$Input

  /** The content of a message to send */
  export type InputMessageContent =
    | inputMessageText
    | inputMessageAnimation
    | inputMessageAudio
    | inputMessageDocument
    | inputMessagePhoto
    | inputMessageSticker
    | inputMessageVideo
    | inputMessageVideoNote
    | inputMessageVoiceNote
    | inputMessageLocation
    | inputMessageVenue
    | inputMessageContact
    | inputMessageDice
    | inputMessageGame
    | inputMessageInvoice
    | inputMessagePoll
    | inputMessageStory
    | inputMessageForwarded

  /** The content of a message to send */
  export type InputMessageContent$Input =
    | inputMessageText$Input
    | inputMessageAnimation$Input
    | inputMessageAudio$Input
    | inputMessageDocument$Input
    | inputMessagePhoto$Input
    | inputMessageSticker$Input
    | inputMessageVideo$Input
    | inputMessageVideoNote$Input
    | inputMessageVoiceNote$Input
    | inputMessageLocation$Input
    | inputMessageVenue$Input
    | inputMessageContact$Input
    | inputMessageDice$Input
    | inputMessageGame$Input
    | inputMessageInvoice$Input
    | inputMessagePoll$Input
    | inputMessageStory$Input
    | inputMessageForwarded$Input

  /** Represents a filter for message search results */
  export type SearchMessagesFilter$Input =
    | searchMessagesFilterEmpty$Input
    | searchMessagesFilterAnimation$Input
    | searchMessagesFilterAudio$Input
    | searchMessagesFilterDocument$Input
    | searchMessagesFilterPhoto$Input
    | searchMessagesFilterVideo$Input
    | searchMessagesFilterVoiceNote$Input
    | searchMessagesFilterPhotoAndVideo$Input
    | searchMessagesFilterUrl$Input
    | searchMessagesFilterChatPhoto$Input
    | searchMessagesFilterVideoNote$Input
    | searchMessagesFilterVoiceAndVideoNote$Input
    | searchMessagesFilterMention$Input
    | searchMessagesFilterUnreadMention$Input
    | searchMessagesFilterUnreadReaction$Input
    | searchMessagesFilterFailedToSend$Input
    | searchMessagesFilterPinned$Input

  /** Describes the different types of activity in a chat */
  export type ChatAction =
    | chatActionTyping
    | chatActionRecordingVideo
    | chatActionUploadingVideo
    | chatActionRecordingVoiceNote
    | chatActionUploadingVoiceNote
    | chatActionUploadingPhoto
    | chatActionUploadingDocument
    | chatActionChoosingSticker
    | chatActionChoosingLocation
    | chatActionChoosingContact
    | chatActionStartPlayingGame
    | chatActionRecordingVideoNote
    | chatActionUploadingVideoNote
    | chatActionWatchingAnimations
    | chatActionCancel

  /** Describes the different types of activity in a chat */
  export type ChatAction$Input =
    | chatActionTyping$Input
    | chatActionRecordingVideo$Input
    | chatActionUploadingVideo$Input
    | chatActionRecordingVoiceNote$Input
    | chatActionUploadingVoiceNote$Input
    | chatActionUploadingPhoto$Input
    | chatActionUploadingDocument$Input
    | chatActionChoosingSticker$Input
    | chatActionChoosingLocation$Input
    | chatActionChoosingContact$Input
    | chatActionStartPlayingGame$Input
    | chatActionRecordingVideoNote$Input
    | chatActionUploadingVideoNote$Input
    | chatActionWatchingAnimations$Input
    | chatActionCancel$Input

  /** Describes the last time the user was online */
  export type UserStatus =
    | userStatusEmpty
    | userStatusOnline
    | userStatusOffline
    | userStatusRecently
    | userStatusLastWeek
    | userStatusLastMonth

  export type Stickers = stickers

  export type Emojis = emojis

  export type StickerSet = stickerSet

  export type StickerSets = stickerSets

  export type TrendingStickerSets = trendingStickerSets

  export type EmojiCategories = emojiCategories

  /** Describes type of an emoji category */
  export type EmojiCategoryType$Input =
    | emojiCategoryTypeDefault$Input
    | emojiCategoryTypeEmojiStatus$Input
    | emojiCategoryTypeChatPhoto$Input

  export type StoryViewers = storyViewers

  /** Describes type of a clickable rectangle area on a story media */
  export type StoryAreaType =
    | storyAreaTypeLocation
    | storyAreaTypeVenue
    | storyAreaTypeSuggestedReaction

  /** Describes type of a clickable rectangle area on a story media to be added */
  export type InputStoryAreaType$Input =
    | inputStoryAreaTypeLocation$Input
    | inputStoryAreaTypeFoundVenue$Input
    | inputStoryAreaTypePreviousVenue$Input
    | inputStoryAreaTypeSuggestedReaction$Input

  /** Contains the content of a story */
  export type StoryContent =
    | storyContentPhoto
    | storyContentVideo
    | storyContentUnsupported

  /** The content of a story to send */
  export type InputStoryContent$Input =
    | inputStoryContentPhoto$Input
    | inputStoryContentVideo$Input

  /** Describes a list of stories */
  export type StoryList =
    | storyListMain
    | storyListArchive

  /** Describes a list of stories */
  export type StoryList$Input =
    | storyListMain$Input
    | storyListArchive$Input

  export type Story = story

  export type Stories = stories

  export type ChatActiveStories = chatActiveStories

  export type ChatBoostStatus = chatBoostStatus

  export type FoundChatBoosts = foundChatBoosts

  /** Describes the reason why a call was discarded */
  export type CallDiscardReason =
    | callDiscardReasonEmpty
    | callDiscardReasonMissed
    | callDiscardReasonDeclined
    | callDiscardReasonDisconnected
    | callDiscardReasonHungUp

  /** Describes the type of a call server */
  export type CallServerType =
    | callServerTypeTelegramReflector
    | callServerTypeWebrtc

  export type CallId = callId

  export type GroupCallId = groupCallId

  /** Describes the current call state */
  export type CallState =
    | callStatePending
    | callStateExchangingKeys
    | callStateReady
    | callStateHangingUp
    | callStateDiscarded
    | callStateError

  /** Describes the quality of a group call video */
  export type GroupCallVideoQuality$Input =
    | groupCallVideoQualityThumbnail$Input
    | groupCallVideoQualityMedium$Input
    | groupCallVideoQualityFull$Input

  export type GroupCallStreams = groupCallStreams

  export type RtmpUrl = rtmpUrl

  export type GroupCall = groupCall

  /** Describes the exact type of a problem with a call */
  export type CallProblem$Input =
    | callProblemEcho$Input
    | callProblemNoise$Input
    | callProblemInterruptions$Input
    | callProblemDistortedSpeech$Input
    | callProblemSilentLocal$Input
    | callProblemSilentRemote$Input
    | callProblemDropped$Input
    | callProblemDistortedVideo$Input
    | callProblemPixelatedVideo$Input

  /** Contains settings for Firebase Authentication in the official applications */
  export type FirebaseAuthenticationSettings$Input =
    | firebaseAuthenticationSettingsAndroid$Input
    | firebaseAuthenticationSettingsIos$Input

  export type AddedReactions = addedReactions

  export type AvailableReactions = availableReactions

  export type EmojiReaction = emojiReaction

  export type Animations = animations

  /** Contains animated stickers which must be used for dice animation rendering */
  export type DiceStickers =
    | diceStickersRegular
    | diceStickersSlotMachine

  export type ImportedContacts = importedContacts

  /** Describes result of speech recognition in a voice note */
  export type SpeechRecognitionResult =
    | speechRecognitionResultPending
    | speechRecognitionResultText
    | speechRecognitionResultError

  export type AttachmentMenuBot = attachmentMenuBot

  export type SentWebAppMessage = sentWebAppMessage

  export type HttpUrl = httpUrl

  export type UserLink = userLink

  /** Represents a single result of an inline query; for bots only */
  export type InputInlineQueryResult$Input =
    | inputInlineQueryResultAnimation$Input
    | inputInlineQueryResultArticle$Input
    | inputInlineQueryResultAudio$Input
    | inputInlineQueryResultContact$Input
    | inputInlineQueryResultDocument$Input
    | inputInlineQueryResultGame$Input
    | inputInlineQueryResultLocation$Input
    | inputInlineQueryResultPhoto$Input
    | inputInlineQueryResultSticker$Input
    | inputInlineQueryResultVenue$Input
    | inputInlineQueryResultVideo$Input
    | inputInlineQueryResultVoiceNote$Input

  /** Represents a single result of an inline query */
  export type InlineQueryResult =
    | inlineQueryResultArticle
    | inlineQueryResultContact
    | inlineQueryResultLocation
    | inlineQueryResultVenue
    | inlineQueryResultGame
    | inlineQueryResultAnimation
    | inlineQueryResultAudio
    | inlineQueryResultDocument
    | inlineQueryResultPhoto
    | inlineQueryResultSticker
    | inlineQueryResultVideo
    | inlineQueryResultVoiceNote

  /** Represents a type of a button in results of inline query */
  export type InlineQueryResultsButtonType =
    | inlineQueryResultsButtonTypeStartBot
    | inlineQueryResultsButtonTypeWebApp

  /** Represents a type of a button in results of inline query */
  export type InlineQueryResultsButtonType$Input =
    | inlineQueryResultsButtonTypeStartBot$Input
    | inlineQueryResultsButtonTypeWebApp$Input

  export type InlineQueryResults = inlineQueryResults

  /** Represents a payload of a callback query */
  export type CallbackQueryPayload =
    | callbackQueryPayloadData
    | callbackQueryPayloadDataWithPassword
    | callbackQueryPayloadGame

  /** Represents a payload of a callback query */
  export type CallbackQueryPayload$Input =
    | callbackQueryPayloadData$Input
    | callbackQueryPayloadDataWithPassword$Input
    | callbackQueryPayloadGame$Input

  export type CallbackQueryAnswer = callbackQueryAnswer

  export type CustomRequestResult = customRequestResult

  export type GameHighScores = gameHighScores

  /** Represents a chat event */
  export type ChatEventAction =
    | chatEventMessageEdited
    | chatEventMessageDeleted
    | chatEventMessagePinned
    | chatEventMessageUnpinned
    | chatEventPollStopped
    | chatEventMemberJoined
    | chatEventMemberJoinedByInviteLink
    | chatEventMemberJoinedByRequest
    | chatEventMemberInvited
    | chatEventMemberLeft
    | chatEventMemberPromoted
    | chatEventMemberRestricted
    | chatEventAvailableReactionsChanged
    | chatEventDescriptionChanged
    | chatEventLinkedChatChanged
    | chatEventLocationChanged
    | chatEventMessageAutoDeleteTimeChanged
    | chatEventPermissionsChanged
    | chatEventPhotoChanged
    | chatEventSlowModeDelayChanged
    | chatEventStickerSetChanged
    | chatEventTitleChanged
    | chatEventUsernameChanged
    | chatEventActiveUsernamesChanged
    | chatEventHasProtectedContentToggled
    | chatEventInvitesToggled
    | chatEventIsAllHistoryAvailableToggled
    | chatEventHasAggressiveAntiSpamEnabledToggled
    | chatEventSignMessagesToggled
    | chatEventInviteLinkEdited
    | chatEventInviteLinkRevoked
    | chatEventInviteLinkDeleted
    | chatEventVideoChatCreated
    | chatEventVideoChatEnded
    | chatEventVideoChatMuteNewParticipantsToggled
    | chatEventVideoChatParticipantIsMutedToggled
    | chatEventVideoChatParticipantVolumeLevelChanged
    | chatEventIsForumToggled
    | chatEventForumTopicCreated
    | chatEventForumTopicEdited
    | chatEventForumTopicToggleIsClosed
    | chatEventForumTopicToggleIsHidden
    | chatEventForumTopicDeleted
    | chatEventForumTopicPinned

  export type ChatEvents = chatEvents

  /** Represents the value of a string in a language pack */
  export type LanguagePackStringValue =
    | languagePackStringValueOrdinary
    | languagePackStringValuePluralized
    | languagePackStringValueDeleted

  /** Represents the value of a string in a language pack */
  export type LanguagePackStringValue$Input =
    | languagePackStringValueOrdinary$Input
    | languagePackStringValuePluralized$Input
    | languagePackStringValueDeleted$Input

  export type LanguagePackStrings = languagePackStrings

  export type LanguagePackInfo = languagePackInfo

  export type LocalizationTargetInfo = localizationTargetInfo

  /** Describes type of a limit, increased for Premium users */
  export type PremiumLimitType =
    | premiumLimitTypeSupergroupCount
    | premiumLimitTypePinnedChatCount
    | premiumLimitTypeCreatedPublicChatCount
    | premiumLimitTypeSavedAnimationCount
    | premiumLimitTypeFavoriteStickerCount
    | premiumLimitTypeChatFolderCount
    | premiumLimitTypeChatFolderChosenChatCount
    | premiumLimitTypePinnedArchivedChatCount
    | premiumLimitTypeCaptionLength
    | premiumLimitTypeBioLength
    | premiumLimitTypeChatFolderInviteLinkCount
    | premiumLimitTypeShareableChatFolderCount
    | premiumLimitTypeActiveStoryCount
    | premiumLimitTypeWeeklySentStoryCount
    | premiumLimitTypeMonthlySentStoryCount
    | premiumLimitTypeStoryCaptionLength
    | premiumLimitTypeStorySuggestedReactionAreaCount

  /** Describes type of a limit, increased for Premium users */
  export type PremiumLimitType$Input =
    | premiumLimitTypeSupergroupCount$Input
    | premiumLimitTypePinnedChatCount$Input
    | premiumLimitTypeCreatedPublicChatCount$Input
    | premiumLimitTypeSavedAnimationCount$Input
    | premiumLimitTypeFavoriteStickerCount$Input
    | premiumLimitTypeChatFolderCount$Input
    | premiumLimitTypeChatFolderChosenChatCount$Input
    | premiumLimitTypePinnedArchivedChatCount$Input
    | premiumLimitTypeCaptionLength$Input
    | premiumLimitTypeBioLength$Input
    | premiumLimitTypeChatFolderInviteLinkCount$Input
    | premiumLimitTypeShareableChatFolderCount$Input
    | premiumLimitTypeActiveStoryCount$Input
    | premiumLimitTypeWeeklySentStoryCount$Input
    | premiumLimitTypeMonthlySentStoryCount$Input
    | premiumLimitTypeStoryCaptionLength$Input
    | premiumLimitTypeStorySuggestedReactionAreaCount$Input

  /** Describes a feature available to Premium users */
  export type PremiumFeature =
    | premiumFeatureIncreasedLimits
    | premiumFeatureIncreasedUploadFileSize
    | premiumFeatureImprovedDownloadSpeed
    | premiumFeatureVoiceRecognition
    | premiumFeatureDisabledAds
    | premiumFeatureUniqueReactions
    | premiumFeatureUniqueStickers
    | premiumFeatureCustomEmoji
    | premiumFeatureAdvancedChatManagement
    | premiumFeatureProfileBadge
    | premiumFeatureEmojiStatus
    | premiumFeatureAnimatedProfilePhoto
    | premiumFeatureForumTopicIcon
    | premiumFeatureAppIcons
    | premiumFeatureRealTimeChatTranslation
    | premiumFeatureUpgradedStories
    | premiumFeatureChatBoost

  /** Describes a feature available to Premium users */
  export type PremiumFeature$Input =
    | premiumFeatureIncreasedLimits$Input
    | premiumFeatureIncreasedUploadFileSize$Input
    | premiumFeatureImprovedDownloadSpeed$Input
    | premiumFeatureVoiceRecognition$Input
    | premiumFeatureDisabledAds$Input
    | premiumFeatureUniqueReactions$Input
    | premiumFeatureUniqueStickers$Input
    | premiumFeatureCustomEmoji$Input
    | premiumFeatureAdvancedChatManagement$Input
    | premiumFeatureProfileBadge$Input
    | premiumFeatureEmojiStatus$Input
    | premiumFeatureAnimatedProfilePhoto$Input
    | premiumFeatureForumTopicIcon$Input
    | premiumFeatureAppIcons$Input
    | premiumFeatureRealTimeChatTranslation$Input
    | premiumFeatureUpgradedStories$Input
    | premiumFeatureChatBoost$Input

  /** Describes a story feature available to Premium users */
  export type PremiumStoryFeature$Input =
    | premiumStoryFeaturePriorityOrder$Input
    | premiumStoryFeatureStealthMode$Input
    | premiumStoryFeaturePermanentViewsHistory$Input
    | premiumStoryFeatureCustomExpirationDuration$Input
    | premiumStoryFeatureSaveStories$Input
    | premiumStoryFeatureLinksAndFormatting$Input

  export type PremiumLimit = premiumLimit

  export type PremiumFeatures = premiumFeatures

  /** Describes a source from which the Premium features screen is opened */
  export type PremiumSource$Input =
    | premiumSourceLimitExceeded$Input
    | premiumSourceFeature$Input
    | premiumSourceStoryFeature$Input
    | premiumSourceLink$Input
    | premiumSourceSettings$Input

  export type PremiumState = premiumState

  /** Describes a purpose of an in-store payment */
  export type StorePaymentPurpose$Input =
    | storePaymentPurposePremiumSubscription$Input
    | storePaymentPurposeGiftedPremium$Input

  /**
   * Represents a data needed to subscribe for push notifications through registerDevice
   * method. To use specific push notification service, the correct application platform
   * must be specified and a valid server authentication data must be uploaded at
   * https://my.telegram.org
   */
  export type DeviceToken$Input =
    | deviceTokenFirebaseCloudMessaging$Input
    | deviceTokenApplePush$Input
    | deviceTokenApplePushVoIP$Input
    | deviceTokenWindowsPush$Input
    | deviceTokenMicrosoftPush$Input
    | deviceTokenMicrosoftPushVoIP$Input
    | deviceTokenWebPush$Input
    | deviceTokenSimplePush$Input
    | deviceTokenUbuntuPush$Input
    | deviceTokenBlackBerryPush$Input
    | deviceTokenTizenPush$Input
    | deviceTokenHuaweiPush$Input

  export type PushReceiverId = pushReceiverId

  /** Describes a fill of a background */
  export type BackgroundFill =
    | backgroundFillSolid
    | backgroundFillGradient
    | backgroundFillFreeformGradient

  /** Describes a fill of a background */
  export type BackgroundFill$Input =
    | backgroundFillSolid$Input
    | backgroundFillGradient$Input
    | backgroundFillFreeformGradient$Input

  /** Describes the type of a background */
  export type BackgroundType =
    | backgroundTypeWallpaper
    | backgroundTypePattern
    | backgroundTypeFill

  /** Describes the type of a background */
  export type BackgroundType$Input =
    | backgroundTypeWallpaper$Input
    | backgroundTypePattern$Input
    | backgroundTypeFill$Input

  /** Contains information about background to set */
  export type InputBackground$Input =
    | inputBackgroundLocal$Input
    | inputBackgroundRemote$Input
    | inputBackgroundPrevious$Input

  export type Hashtags = hashtags

  /**
   * Represents result of checking whether the current user can send a story in the
   * specific chat
   */
  export type CanSendStoryResult =
    | canSendStoryResultOk
    | canSendStoryResultPremiumNeeded
    | canSendStoryResultBoostNeeded
    | canSendStoryResultActiveStoryLimitExceeded
    | canSendStoryResultWeeklyLimitExceeded
    | canSendStoryResultMonthlyLimitExceeded

  /**
   * Represents result of checking whether the current user can boost the specific
   * chat
   */
  export type CanBoostChatResult =
    | canBoostChatResultOk
    | canBoostChatResultInvalidChat
    | canBoostChatResultAlreadyBoosted
    | canBoostChatResultPremiumNeeded
    | canBoostChatResultPremiumSubscriptionNeeded
    | canBoostChatResultWaitNeeded

  /**
   * Represents result of checking whether the current session can be used to transfer
   * a chat ownership to another user
   */
  export type CanTransferOwnershipResult =
    | canTransferOwnershipResultOk
    | canTransferOwnershipResultPasswordNeeded
    | canTransferOwnershipResultPasswordTooFresh
    | canTransferOwnershipResultSessionTooFresh

  /** Represents result of checking whether a username can be set for a chat */
  export type CheckChatUsernameResult =
    | checkChatUsernameResultOk
    | checkChatUsernameResultUsernameInvalid
    | checkChatUsernameResultUsernameOccupied
    | checkChatUsernameResultUsernamePurchasable
    | checkChatUsernameResultPublicChatsTooMany
    | checkChatUsernameResultPublicGroupsUnavailable

  /** Represents result of checking whether a name can be used for a new sticker set */
  export type CheckStickerSetNameResult =
    | checkStickerSetNameResultOk
    | checkStickerSetNameResultNameInvalid
    | checkStickerSetNameResultNameOccupied

  /** Represents result of 2-step verification password reset */
  export type ResetPasswordResult =
    | resetPasswordResultOk
    | resetPasswordResultPending
    | resetPasswordResultDeclined

  /** Contains information about a file with messages exported from another app */
  export type MessageFileType =
    | messageFileTypePrivate
    | messageFileTypeGroup
    | messageFileTypeUnknown

  /** Contains content of a push message notification */
  export type PushMessageContent =
    | pushMessageContentHidden
    | pushMessageContentAnimation
    | pushMessageContentAudio
    | pushMessageContentContact
    | pushMessageContentContactRegistered
    | pushMessageContentDocument
    | pushMessageContentGame
    | pushMessageContentGameScore
    | pushMessageContentInvoice
    | pushMessageContentLocation
    | pushMessageContentPhoto
    | pushMessageContentPoll
    | pushMessageContentScreenshotTaken
    | pushMessageContentSticker
    | pushMessageContentStory
    | pushMessageContentText
    | pushMessageContentVideo
    | pushMessageContentVideoNote
    | pushMessageContentVoiceNote
    | pushMessageContentBasicGroupChatCreate
    | pushMessageContentChatAddMembers
    | pushMessageContentChatChangePhoto
    | pushMessageContentChatChangeTitle
    | pushMessageContentChatSetBackground
    | pushMessageContentChatSetTheme
    | pushMessageContentChatDeleteMember
    | pushMessageContentChatJoinByLink
    | pushMessageContentChatJoinByRequest
    | pushMessageContentRecurringPayment
    | pushMessageContentSuggestProfilePhoto
    | pushMessageContentMessageForwards
    | pushMessageContentMediaAlbum

  /** Contains detailed information about a notification */
  export type NotificationType =
    | notificationTypeNewMessage
    | notificationTypeNewSecretChat
    | notificationTypeNewCall
    | notificationTypeNewPushMessage

  /** Describes the type of notifications in a notification group */
  export type NotificationGroupType =
    | notificationGroupTypeMessages
    | notificationGroupTypeMentions
    | notificationGroupTypeSecretChat
    | notificationGroupTypeCalls

  export type NotificationSound = notificationSound

  export type NotificationSounds = notificationSounds

  /** Represents the value of an option */
  export type OptionValue =
    | optionValueBoolean
    | optionValueEmpty
    | optionValueInteger
    | optionValueString

  /** Represents the value of an option */
  export type OptionValue$Input =
    | optionValueBoolean$Input
    | optionValueEmpty$Input
    | optionValueInteger$Input
    | optionValueString$Input

  /** Represents a JSON value */
  export type JsonValue =
    | jsonValueNull
    | jsonValueBoolean
    | jsonValueNumber
    | jsonValueString
    | jsonValueArray
    | jsonValueObject

  /** Represents a JSON value */
  export type JsonValue$Input =
    | jsonValueNull$Input
    | jsonValueBoolean$Input
    | jsonValueNumber$Input
    | jsonValueString$Input
    | jsonValueArray$Input
    | jsonValueObject$Input

  /** Describes privacy settings of a story */
  export type StoryPrivacySettings =
    | storyPrivacySettingsEveryone
    | storyPrivacySettingsContacts
    | storyPrivacySettingsCloseFriends
    | storyPrivacySettingsSelectedUsers

  /** Describes privacy settings of a story */
  export type StoryPrivacySettings$Input =
    | storyPrivacySettingsEveryone$Input
    | storyPrivacySettingsContacts$Input
    | storyPrivacySettingsCloseFriends$Input
    | storyPrivacySettingsSelectedUsers$Input

  /** Represents a single rule for managing user privacy settings */
  export type UserPrivacySettingRule =
    | userPrivacySettingRuleAllowAll
    | userPrivacySettingRuleAllowContacts
    | userPrivacySettingRuleAllowUsers
    | userPrivacySettingRuleAllowChatMembers
    | userPrivacySettingRuleRestrictAll
    | userPrivacySettingRuleRestrictContacts
    | userPrivacySettingRuleRestrictUsers
    | userPrivacySettingRuleRestrictChatMembers

  /** Represents a single rule for managing user privacy settings */
  export type UserPrivacySettingRule$Input =
    | userPrivacySettingRuleAllowAll$Input
    | userPrivacySettingRuleAllowContacts$Input
    | userPrivacySettingRuleAllowUsers$Input
    | userPrivacySettingRuleAllowChatMembers$Input
    | userPrivacySettingRuleRestrictAll$Input
    | userPrivacySettingRuleRestrictContacts$Input
    | userPrivacySettingRuleRestrictUsers$Input
    | userPrivacySettingRuleRestrictChatMembers$Input

  export type UserPrivacySettingRules = userPrivacySettingRules

  /** Describes available user privacy settings */
  export type UserPrivacySetting =
    | userPrivacySettingShowStatus
    | userPrivacySettingShowProfilePhoto
    | userPrivacySettingShowLinkInForwardedMessages
    | userPrivacySettingShowPhoneNumber
    | userPrivacySettingShowBio
    | userPrivacySettingAllowChatInvites
    | userPrivacySettingAllowCalls
    | userPrivacySettingAllowPeerToPeerCalls
    | userPrivacySettingAllowFindingByPhoneNumber
    | userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages

  /** Describes available user privacy settings */
  export type UserPrivacySetting$Input =
    | userPrivacySettingShowStatus$Input
    | userPrivacySettingShowProfilePhoto$Input
    | userPrivacySettingShowLinkInForwardedMessages$Input
    | userPrivacySettingShowPhoneNumber$Input
    | userPrivacySettingShowBio$Input
    | userPrivacySettingAllowChatInvites$Input
    | userPrivacySettingAllowCalls$Input
    | userPrivacySettingAllowPeerToPeerCalls$Input
    | userPrivacySettingAllowFindingByPhoneNumber$Input
    | userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages$Input

  export type AccountTtl = accountTtl

  export type MessageAutoDeleteTime = messageAutoDeleteTime

  /** Represents the type of a session */
  export type SessionType =
    | sessionTypeAndroid
    | sessionTypeApple
    | sessionTypeBrave
    | sessionTypeChrome
    | sessionTypeEdge
    | sessionTypeFirefox
    | sessionTypeIpad
    | sessionTypeIphone
    | sessionTypeLinux
    | sessionTypeMac
    | sessionTypeOpera
    | sessionTypeSafari
    | sessionTypeUbuntu
    | sessionTypeUnknown
    | sessionTypeVivaldi
    | sessionTypeWindows
    | sessionTypeXbox

  export type Session = session

  export type Sessions = sessions

  export type ConnectedWebsites = connectedWebsites

  /** Describes the reason why a chat is reported */
  export type ReportReason$Input =
    | reportReasonSpam$Input
    | reportReasonViolence$Input
    | reportReasonPornography$Input
    | reportReasonChildAbuse$Input
    | reportReasonCopyright$Input
    | reportReasonUnrelatedLocation$Input
    | reportReasonFake$Input
    | reportReasonIllegalDrugs$Input
    | reportReasonPersonalDetails$Input
    | reportReasonCustom$Input

  /** Describes the target chat to be opened */
  export type TargetChat =
    | targetChatCurrent
    | targetChatChosen
    | targetChatInternalLink

  /** Describes the target chat to be opened */
  export type TargetChat$Input =
    | targetChatCurrent$Input
    | targetChatChosen$Input
    | targetChatInternalLink$Input

  /**
   * Describes an internal https://t.me or tg: link, which must be processed by the
   * application in a special way
   */
  export type InternalLinkType =
    | internalLinkTypeActiveSessions
    | internalLinkTypeAttachmentMenuBot
    | internalLinkTypeAuthenticationCode
    | internalLinkTypeBackground
    | internalLinkTypeBotAddToChannel
    | internalLinkTypeBotStart
    | internalLinkTypeBotStartInGroup
    | internalLinkTypeChangePhoneNumber
    | internalLinkTypeChatBoost
    | internalLinkTypeChatFolderInvite
    | internalLinkTypeChatFolderSettings
    | internalLinkTypeChatInvite
    | internalLinkTypeDefaultMessageAutoDeleteTimerSettings
    | internalLinkTypeEditProfileSettings
    | internalLinkTypeGame
    | internalLinkTypeInstantView
    | internalLinkTypeInvoice
    | internalLinkTypeLanguagePack
    | internalLinkTypeLanguageSettings
    | internalLinkTypeMessage
    | internalLinkTypeMessageDraft
    | internalLinkTypePassportDataRequest
    | internalLinkTypePhoneNumberConfirmation
    | internalLinkTypePremiumFeatures
    | internalLinkTypePrivacyAndSecuritySettings
    | internalLinkTypeProxy
    | internalLinkTypePublicChat
    | internalLinkTypeQrCodeAuthentication
    | internalLinkTypeRestorePurchases
    | internalLinkTypeSettings
    | internalLinkTypeSideMenuBot
    | internalLinkTypeStickerSet
    | internalLinkTypeStory
    | internalLinkTypeTheme
    | internalLinkTypeThemeSettings
    | internalLinkTypeUnknownDeepLink
    | internalLinkTypeUnsupportedProxy
    | internalLinkTypeUserPhoneNumber
    | internalLinkTypeUserToken
    | internalLinkTypeVideoChat
    | internalLinkTypeWebApp

  /**
   * Describes an internal https://t.me or tg: link, which must be processed by the
   * application in a special way
   */
  export type InternalLinkType$Input =
    | internalLinkTypeActiveSessions$Input
    | internalLinkTypeAttachmentMenuBot$Input
    | internalLinkTypeAuthenticationCode$Input
    | internalLinkTypeBackground$Input
    | internalLinkTypeBotAddToChannel$Input
    | internalLinkTypeBotStart$Input
    | internalLinkTypeBotStartInGroup$Input
    | internalLinkTypeChangePhoneNumber$Input
    | internalLinkTypeChatBoost$Input
    | internalLinkTypeChatFolderInvite$Input
    | internalLinkTypeChatFolderSettings$Input
    | internalLinkTypeChatInvite$Input
    | internalLinkTypeDefaultMessageAutoDeleteTimerSettings$Input
    | internalLinkTypeEditProfileSettings$Input
    | internalLinkTypeGame$Input
    | internalLinkTypeInstantView$Input
    | internalLinkTypeInvoice$Input
    | internalLinkTypeLanguagePack$Input
    | internalLinkTypeLanguageSettings$Input
    | internalLinkTypeMessage$Input
    | internalLinkTypeMessageDraft$Input
    | internalLinkTypePassportDataRequest$Input
    | internalLinkTypePhoneNumberConfirmation$Input
    | internalLinkTypePremiumFeatures$Input
    | internalLinkTypePrivacyAndSecuritySettings$Input
    | internalLinkTypeProxy$Input
    | internalLinkTypePublicChat$Input
    | internalLinkTypeQrCodeAuthentication$Input
    | internalLinkTypeRestorePurchases$Input
    | internalLinkTypeSettings$Input
    | internalLinkTypeSideMenuBot$Input
    | internalLinkTypeStickerSet$Input
    | internalLinkTypeStory$Input
    | internalLinkTypeTheme$Input
    | internalLinkTypeThemeSettings$Input
    | internalLinkTypeUnknownDeepLink$Input
    | internalLinkTypeUnsupportedProxy$Input
    | internalLinkTypeUserPhoneNumber$Input
    | internalLinkTypeUserToken$Input
    | internalLinkTypeVideoChat$Input
    | internalLinkTypeWebApp$Input

  export type MessageLink = messageLink

  export type MessageLinkInfo = messageLinkInfo

  export type ChatBoostLink = chatBoostLink

  export type ChatBoostLinkInfo = chatBoostLinkInfo

  /** Describes a type of a block list */
  export type BlockList =
    | blockListMain
    | blockListStories

  /** Describes a type of a block list */
  export type BlockList$Input =
    | blockListMain$Input
    | blockListStories$Input

  export type FilePart = filePart

  /** Represents the type of a file */
  export type FileType =
    | fileTypeNone
    | fileTypeAnimation
    | fileTypeAudio
    | fileTypeDocument
    | fileTypeNotificationSound
    | fileTypePhoto
    | fileTypePhotoStory
    | fileTypeProfilePhoto
    | fileTypeSecret
    | fileTypeSecretThumbnail
    | fileTypeSecure
    | fileTypeSticker
    | fileTypeThumbnail
    | fileTypeUnknown
    | fileTypeVideo
    | fileTypeVideoNote
    | fileTypeVideoStory
    | fileTypeVoiceNote
    | fileTypeWallpaper

  /** Represents the type of a file */
  export type FileType$Input =
    | fileTypeNone$Input
    | fileTypeAnimation$Input
    | fileTypeAudio$Input
    | fileTypeDocument$Input
    | fileTypeNotificationSound$Input
    | fileTypePhoto$Input
    | fileTypePhotoStory$Input
    | fileTypeProfilePhoto$Input
    | fileTypeSecret$Input
    | fileTypeSecretThumbnail$Input
    | fileTypeSecure$Input
    | fileTypeSticker$Input
    | fileTypeThumbnail$Input
    | fileTypeUnknown$Input
    | fileTypeVideo$Input
    | fileTypeVideoNote$Input
    | fileTypeVideoStory$Input
    | fileTypeVoiceNote$Input
    | fileTypeWallpaper$Input

  export type StorageStatistics = storageStatistics

  export type StorageStatisticsFast = storageStatisticsFast

  export type DatabaseStatistics = databaseStatistics

  /** Represents the type of a network */
  export type NetworkType =
    | networkTypeNone
    | networkTypeMobile
    | networkTypeMobileRoaming
    | networkTypeWiFi
    | networkTypeOther

  /** Represents the type of a network */
  export type NetworkType$Input =
    | networkTypeNone$Input
    | networkTypeMobile$Input
    | networkTypeMobileRoaming$Input
    | networkTypeWiFi$Input
    | networkTypeOther$Input

  /** Contains statistics about network usage */
  export type NetworkStatisticsEntry =
    | networkStatisticsEntryFile
    | networkStatisticsEntryCall

  /** Contains statistics about network usage */
  export type NetworkStatisticsEntry$Input =
    | networkStatisticsEntryFile$Input
    | networkStatisticsEntryCall$Input

  export type NetworkStatistics = networkStatistics

  export type AutoDownloadSettingsPresets = autoDownloadSettingsPresets

  /** Describes scope of autosave settings */
  export type AutosaveSettingsScope =
    | autosaveSettingsScopePrivateChats
    | autosaveSettingsScopeGroupChats
    | autosaveSettingsScopeChannelChats
    | autosaveSettingsScopeChat

  /** Describes scope of autosave settings */
  export type AutosaveSettingsScope$Input =
    | autosaveSettingsScopePrivateChats$Input
    | autosaveSettingsScopeGroupChats$Input
    | autosaveSettingsScopeChannelChats$Input
    | autosaveSettingsScopeChat$Input

  export type AutosaveSettings = autosaveSettings

  /** Describes the current state of the connection to Telegram servers */
  export type ConnectionState =
    | connectionStateWaitingForNetwork
    | connectionStateConnectingToProxy
    | connectionStateConnecting
    | connectionStateUpdating
    | connectionStateReady

  /**
   * Represents the categories of chats for which a list of frequently used chats
   * can be retrieved
   */
  export type TopChatCategory$Input =
    | topChatCategoryUsers$Input
    | topChatCategoryBots$Input
    | topChatCategoryGroups$Input
    | topChatCategoryChannels$Input
    | topChatCategoryInlineBots$Input
    | topChatCategoryCalls$Input
    | topChatCategoryForwardChats$Input

  export type FoundPositions = foundPositions

  /** Describes the type of a URL linking to an internal Telegram entity */
  export type TMeUrlType =
    | tMeUrlTypeUser
    | tMeUrlTypeSupergroup
    | tMeUrlTypeChatInvite
    | tMeUrlTypeStickerSet

  export type TMeUrls = tMeUrls

  /** Describes an action suggested to the current user */
  export type SuggestedAction =
    | suggestedActionEnableArchiveAndMuteNewChats
    | suggestedActionCheckPassword
    | suggestedActionCheckPhoneNumber
    | suggestedActionViewChecksHint
    | suggestedActionConvertToBroadcastGroup
    | suggestedActionSetPassword
    | suggestedActionUpgradePremium
    | suggestedActionRestorePremium
    | suggestedActionSubscribeToAnnualPremium

  /** Describes an action suggested to the current user */
  export type SuggestedAction$Input =
    | suggestedActionEnableArchiveAndMuteNewChats$Input
    | suggestedActionCheckPassword$Input
    | suggestedActionCheckPhoneNumber$Input
    | suggestedActionViewChecksHint$Input
    | suggestedActionConvertToBroadcastGroup$Input
    | suggestedActionSetPassword$Input
    | suggestedActionUpgradePremium$Input
    | suggestedActionRestorePremium$Input
    | suggestedActionSubscribeToAnnualPremium$Input

  export type Count = count

  export type Text = text

  export type Seconds = seconds

  export type FileDownloadedPrefixSize = fileDownloadedPrefixSize

  export type DeepLinkInfo = deepLinkInfo

  /** Describes the way the text needs to be parsed for text entities */
  export type TextParseMode$Input =
    | textParseModeMarkdown$Input
    | textParseModeHTML$Input

  /** Describes the type of a proxy server */
  export type ProxyType =
    | proxyTypeSocks5
    | proxyTypeHttp
    | proxyTypeMtproto

  /** Describes the type of a proxy server */
  export type ProxyType$Input =
    | proxyTypeSocks5$Input
    | proxyTypeHttp$Input
    | proxyTypeMtproto$Input

  export type Proxy = proxy

  export type Proxies = proxies

  /** Describes a statistical graph */
  export type StatisticalGraph =
    | statisticalGraphData
    | statisticalGraphAsync
    | statisticalGraphError

  /** Contains a detailed statistics about a chat */
  export type ChatStatistics =
    | chatStatisticsSupergroup
    | chatStatisticsChannel

  export type MessageStatistics = messageStatistics

  /** Represents a vector path command */
  export type VectorPathCommand =
    | vectorPathCommandLine
    | vectorPathCommandCubicBezierCurve

  /** Represents the scope to which bot commands are relevant */
  export type BotCommandScope$Input =
    | botCommandScopeDefault$Input
    | botCommandScopeAllPrivateChats$Input
    | botCommandScopeAllGroupChats$Input
    | botCommandScopeAllChatAdministrators$Input
    | botCommandScopeChat$Input
    | botCommandScopeChatAdministrators$Input
    | botCommandScopeChatMember$Input

  /** Contains notifications about data changes */
  export type Update =
    | updateAuthorizationState
    | updateNewMessage
    | updateMessageSendAcknowledged
    | updateMessageSendSucceeded
    | updateMessageSendFailed
    | updateMessageContent
    | updateMessageEdited
    | updateMessageIsPinned
    | updateMessageInteractionInfo
    | updateMessageContentOpened
    | updateMessageMentionRead
    | updateMessageUnreadReactions
    | updateMessageLiveLocationViewed
    | updateNewChat
    | updateChatTitle
    | updateChatPhoto
    | updateChatPermissions
    | updateChatLastMessage
    | updateChatPosition
    | updateChatReadInbox
    | updateChatReadOutbox
    | updateChatActionBar
    | updateChatAvailableReactions
    | updateChatDraftMessage
    | updateChatMessageSender
    | updateChatMessageAutoDeleteTime
    | updateChatNotificationSettings
    | updateChatPendingJoinRequests
    | updateChatReplyMarkup
    | updateChatBackground
    | updateChatTheme
    | updateChatUnreadMentionCount
    | updateChatUnreadReactionCount
    | updateChatVideoChat
    | updateChatDefaultDisableNotification
    | updateChatHasProtectedContent
    | updateChatIsTranslatable
    | updateChatIsMarkedAsUnread
    | updateChatBlockList
    | updateChatHasScheduledMessages
    | updateChatFolders
    | updateChatOnlineMemberCount
    | updateForumTopicInfo
    | updateScopeNotificationSettings
    | updateNotification
    | updateNotificationGroup
    | updateActiveNotifications
    | updateHavePendingNotifications
    | updateDeleteMessages
    | updateChatAction
    | updateUserStatus
    | updateUser
    | updateBasicGroup
    | updateSupergroup
    | updateSecretChat
    | updateUserFullInfo
    | updateBasicGroupFullInfo
    | updateSupergroupFullInfo
    | updateServiceNotification
    | updateFile
    | updateFileGenerationStart
    | updateFileGenerationStop
    | updateFileDownloads
    | updateFileAddedToDownloads
    | updateFileDownload
    | updateFileRemovedFromDownloads
    | updateCall
    | updateGroupCall
    | updateGroupCallParticipant
    | updateNewCallSignalingData
    | updateUserPrivacySettingRules
    | updateUnreadMessageCount
    | updateUnreadChatCount
    | updateStory
    | updateStoryDeleted
    | updateStorySendSucceeded
    | updateStorySendFailed
    | updateChatActiveStories
    | updateStoryListChatCount
    | updateStoryStealthMode
    | updateOption
    | updateStickerSet
    | updateInstalledStickerSets
    | updateTrendingStickerSets
    | updateRecentStickers
    | updateFavoriteStickers
    | updateSavedAnimations
    | updateSavedNotificationSounds
    | updateSelectedBackground
    | updateChatThemes
    | updateLanguagePackStrings
    | updateConnectionState
    | updateTermsOfService
    | updateUsersNearby
    | updateUnconfirmedSession
    | updateAttachmentMenuBots
    | updateWebAppMessageSent
    | updateActiveEmojiReactions
    | updateDefaultReactionType
    | updateDiceEmojis
    | updateAnimatedEmojiMessageClicked
    | updateAnimationSearchParameters
    | updateSuggestedActions
    | updateAddChatMembersPrivacyForbidden
    | updateAutosaveSettings
    | updateNewInlineQuery
    | updateNewChosenInlineResult
    | updateNewCallbackQuery
    | updateNewInlineCallbackQuery
    | updateNewShippingQuery
    | updateNewPreCheckoutQuery
    | updateNewCustomEvent
    | updateNewCustomQuery
    | updatePoll
    | updatePollAnswer
    | updateChatMember
    | updateNewChatJoinRequest

  export type Updates = updates

  /** Describes a stream to which TDLib internal log is written */
  export type LogStream =
    | logStreamDefault
    | logStreamFile
    | logStreamEmpty

  /** Describes a stream to which TDLib internal log is written */
  export type LogStream$Input =
    | logStreamDefault$Input
    | logStreamFile$Input
    | logStreamEmpty$Input

  export type LogVerbosityLevel = logVerbosityLevel

  export type LogTags = logTags

  export type UserSupportInfo = userSupportInfo

  export type TestInt = testInt

  export type TestString = testString

  export type TestBytes = testBytes

  export type TestVectorInt = testVectorInt

  export type TestVectorIntObject = testVectorIntObject

  export type TestVectorString = testVectorString

  export type TestVectorStringObject = testVectorStringObject

  // ----

  export type Invoke = <T>(query: { readonly _: T } & (
    getAuthorizationState
    | setTdlibParameters
    | setAuthenticationPhoneNumber
    | setAuthenticationEmailAddress
    | resendAuthenticationCode
    | checkAuthenticationEmailCode
    | checkAuthenticationCode
    | requestQrCodeAuthentication
    | registerUser
    | resetAuthenticationEmailAddress
    | checkAuthenticationPassword
    | requestAuthenticationPasswordRecovery
    | checkAuthenticationPasswordRecoveryCode
    | recoverAuthenticationPassword
    | sendAuthenticationFirebaseSms
    | checkAuthenticationBotToken
    | logOut
    | close
    | destroy
    | confirmQrCodeAuthentication
    | getCurrentState
    | setDatabaseEncryptionKey
    | getPasswordState
    | setPassword
    | setLoginEmailAddress
    | resendLoginEmailAddressCode
    | checkLoginEmailAddressCode
    | getRecoveryEmailAddress
    | setRecoveryEmailAddress
    | checkRecoveryEmailAddressCode
    | resendRecoveryEmailAddressCode
    | requestPasswordRecovery
    | checkPasswordRecoveryCode
    | recoverPassword
    | resetPassword
    | cancelPasswordReset
    | createTemporaryPassword
    | getTemporaryPasswordState
    | getMe
    | getUser
    | getUserFullInfo
    | getBasicGroup
    | getBasicGroupFullInfo
    | getSupergroup
    | getSupergroupFullInfo
    | getSecretChat
    | getChat
    | getMessage
    | getMessageLocally
    | getRepliedMessage
    | getChatPinnedMessage
    | getCallbackQueryMessage
    | getMessages
    | getMessageThread
    | getMessageViewers
    | getFile
    | getRemoteFile
    | loadChats
    | getChats
    | searchPublicChat
    | searchPublicChats
    | searchChats
    | searchChatsOnServer
    | searchChatsNearby
    | getTopChats
    | removeTopChat
    | searchRecentlyFoundChats
    | addRecentlyFoundChat
    | removeRecentlyFoundChat
    | clearRecentlyFoundChats
    | getRecentlyOpenedChats
    | checkChatUsername
    | getCreatedPublicChats
    | checkCreatedPublicChatsLimit
    | getSuitableDiscussionChats
    | getInactiveSupergroupChats
    | getGroupsInCommon
    | getChatHistory
    | getMessageThreadHistory
    | deleteChatHistory
    | deleteChat
    | searchChatMessages
    | searchMessages
    | searchSecretMessages
    | searchCallMessages
    | searchOutgoingDocumentMessages
    | deleteAllCallMessages
    | searchChatRecentLocationMessages
    | getActiveLiveLocationMessages
    | getChatMessageByDate
    | getChatSparseMessagePositions
    | getChatMessageCalendar
    | getChatMessageCount
    | getChatMessagePosition
    | getChatScheduledMessages
    | getMessagePublicForwards
    | getChatSponsoredMessages
    | clickChatSponsoredMessage
    | removeNotification
    | removeNotificationGroup
    | getMessageLink
    | getMessageEmbeddingCode
    | getMessageLinkInfo
    | translateText
    | translateMessageText
    | recognizeSpeech
    | rateSpeechRecognition
    | getChatAvailableMessageSenders
    | setChatMessageSender
    | sendMessage
    | sendMessageAlbum
    | sendBotStartMessage
    | sendInlineQueryResultMessage
    | forwardMessages
    | resendMessages
    | addLocalMessage
    | deleteMessages
    | deleteChatMessagesBySender
    | deleteChatMessagesByDate
    | editMessageText
    | editMessageLiveLocation
    | editMessageMedia
    | editMessageCaption
    | editMessageReplyMarkup
    | editInlineMessageText
    | editInlineMessageLiveLocation
    | editInlineMessageMedia
    | editInlineMessageCaption
    | editInlineMessageReplyMarkup
    | editMessageSchedulingState
    | getForumTopicDefaultIcons
    | createForumTopic
    | editForumTopic
    | getForumTopic
    | getForumTopicLink
    | getForumTopics
    | setForumTopicNotificationSettings
    | toggleForumTopicIsClosed
    | toggleGeneralForumTopicIsHidden
    | toggleForumTopicIsPinned
    | setPinnedForumTopics
    | deleteForumTopic
    | getEmojiReaction
    | getCustomEmojiReactionAnimations
    | getMessageAvailableReactions
    | clearRecentReactions
    | addMessageReaction
    | removeMessageReaction
    | getMessageAddedReactions
    | setDefaultReactionType
    | getTextEntities
    | parseTextEntities
    | parseMarkdown
    | getMarkdownText
    | getFileMimeType
    | getFileExtension
    | cleanFileName
    | getLanguagePackString
    | getJsonValue
    | getJsonString
    | getThemeParametersJsonString
    | setPollAnswer
    | getPollVoters
    | stopPoll
    | hideSuggestedAction
    | getLoginUrlInfo
    | getLoginUrl
    | shareUserWithBot
    | shareChatWithBot
    | getInlineQueryResults
    | answerInlineQuery
    | searchWebApp
    | getWebAppLinkUrl
    | getWebAppUrl
    | sendWebAppData
    | openWebApp
    | closeWebApp
    | answerWebAppQuery
    | getCallbackQueryAnswer
    | answerCallbackQuery
    | answerShippingQuery
    | answerPreCheckoutQuery
    | setGameScore
    | setInlineGameScore
    | getGameHighScores
    | getInlineGameHighScores
    | deleteChatReplyMarkup
    | sendChatAction
    | openChat
    | closeChat
    | viewMessages
    | openMessageContent
    | clickAnimatedEmojiMessage
    | getInternalLink
    | getInternalLinkType
    | getExternalLinkInfo
    | getExternalLink
    | readAllChatMentions
    | readAllMessageThreadMentions
    | readAllChatReactions
    | readAllMessageThreadReactions
    | createPrivateChat
    | createBasicGroupChat
    | createSupergroupChat
    | createSecretChat
    | createNewBasicGroupChat
    | createNewSupergroupChat
    | createNewSecretChat
    | upgradeBasicGroupChatToSupergroupChat
    | getChatListsToAddChat
    | addChatToList
    | getChatFolder
    | createChatFolder
    | editChatFolder
    | deleteChatFolder
    | getChatFolderChatsToLeave
    | getChatFolderChatCount
    | reorderChatFolders
    | getRecommendedChatFolders
    | getChatFolderDefaultIconName
    | getChatsForChatFolderInviteLink
    | createChatFolderInviteLink
    | getChatFolderInviteLinks
    | editChatFolderInviteLink
    | deleteChatFolderInviteLink
    | checkChatFolderInviteLink
    | addChatFolderByInviteLink
    | getChatFolderNewChats
    | processChatFolderNewChats
    | getArchiveChatListSettings
    | setArchiveChatListSettings
    | setChatTitle
    | setChatPhoto
    | setChatMessageAutoDeleteTime
    | setChatPermissions
    | setChatBackground
    | setChatTheme
    | setChatDraftMessage
    | setChatNotificationSettings
    | toggleChatHasProtectedContent
    | toggleChatIsTranslatable
    | toggleChatIsMarkedAsUnread
    | toggleChatDefaultDisableNotification
    | setChatAvailableReactions
    | setChatClientData
    | setChatDescription
    | setChatDiscussionGroup
    | setChatLocation
    | setChatSlowModeDelay
    | pinChatMessage
    | unpinChatMessage
    | unpinAllChatMessages
    | unpinAllMessageThreadMessages
    | joinChat
    | leaveChat
    | addChatMember
    | addChatMembers
    | setChatMemberStatus
    | banChatMember
    | canTransferOwnership
    | transferChatOwnership
    | getChatMember
    | searchChatMembers
    | getChatAdministrators
    | clearAllDraftMessages
    | getSavedNotificationSound
    | getSavedNotificationSounds
    | addSavedNotificationSound
    | removeSavedNotificationSound
    | getChatNotificationSettingsExceptions
    | getScopeNotificationSettings
    | setScopeNotificationSettings
    | resetAllNotificationSettings
    | toggleChatIsPinned
    | setPinnedChats
    | readChatList
    | getStory
    | getChatsToSendStories
    | canSendStory
    | sendStory
    | editStory
    | setStoryPrivacySettings
    | toggleStoryIsPinned
    | deleteStory
    | getStoryNotificationSettingsExceptions
    | loadActiveStories
    | setChatActiveStoriesList
    | getChatActiveStories
    | getChatPinnedStories
    | getChatArchivedStories
    | openStory
    | closeStory
    | getStoryAvailableReactions
    | setStoryReaction
    | getStoryViewers
    | reportStory
    | activateStoryStealthMode
    | getChatBoostStatus
    | canBoostChat
    | boostChat
    | getChatBoostLink
    | getChatBoostLinkInfo
    | getChatBoosts
    | getAttachmentMenuBot
    | toggleBotIsAddedToAttachmentMenu
    | getThemedEmojiStatuses
    | getRecentEmojiStatuses
    | getDefaultEmojiStatuses
    | clearRecentEmojiStatuses
    | downloadFile
    | getFileDownloadedPrefixSize
    | cancelDownloadFile
    | getSuggestedFileName
    | preliminaryUploadFile
    | cancelPreliminaryUploadFile
    | writeGeneratedFilePart
    | setFileGenerationProgress
    | finishFileGeneration
    | readFilePart
    | deleteFile
    | addFileToDownloads
    | toggleDownloadIsPaused
    | toggleAllDownloadsArePaused
    | removeFileFromDownloads
    | removeAllFilesFromDownloads
    | searchFileDownloads
    | getMessageFileType
    | getMessageImportConfirmationText
    | importMessages
    | replacePrimaryChatInviteLink
    | createChatInviteLink
    | editChatInviteLink
    | getChatInviteLink
    | getChatInviteLinkCounts
    | getChatInviteLinks
    | getChatInviteLinkMembers
    | revokeChatInviteLink
    | deleteRevokedChatInviteLink
    | deleteAllRevokedChatInviteLinks
    | checkChatInviteLink
    | joinChatByInviteLink
    | getChatJoinRequests
    | processChatJoinRequest
    | processChatJoinRequests
    | createCall
    | acceptCall
    | sendCallSignalingData
    | discardCall
    | sendCallRating
    | sendCallDebugInformation
    | sendCallLog
    | getVideoChatAvailableParticipants
    | setVideoChatDefaultParticipant
    | createVideoChat
    | getVideoChatRtmpUrl
    | replaceVideoChatRtmpUrl
    | getGroupCall
    | startScheduledGroupCall
    | toggleGroupCallEnabledStartNotification
    | joinGroupCall
    | startGroupCallScreenSharing
    | toggleGroupCallScreenSharingIsPaused
    | endGroupCallScreenSharing
    | setGroupCallTitle
    | toggleGroupCallMuteNewParticipants
    | inviteGroupCallParticipants
    | getGroupCallInviteLink
    | revokeGroupCallInviteLink
    | startGroupCallRecording
    | endGroupCallRecording
    | toggleGroupCallIsMyVideoPaused
    | toggleGroupCallIsMyVideoEnabled
    | setGroupCallParticipantIsSpeaking
    | toggleGroupCallParticipantIsMuted
    | setGroupCallParticipantVolumeLevel
    | toggleGroupCallParticipantIsHandRaised
    | loadGroupCallParticipants
    | leaveGroupCall
    | endGroupCall
    | getGroupCallStreams
    | getGroupCallStreamSegment
    | setMessageSenderBlockList
    | blockMessageSenderFromReplies
    | getBlockedMessageSenders
    | addContact
    | importContacts
    | getContacts
    | searchContacts
    | removeContacts
    | getImportedContactCount
    | changeImportedContacts
    | clearImportedContacts
    | setCloseFriends
    | getCloseFriends
    | setUserPersonalProfilePhoto
    | suggestUserProfilePhoto
    | searchUserByPhoneNumber
    | sharePhoneNumber
    | getUserProfilePhotos
    | getStickers
    | getAllStickerEmojis
    | searchStickers
    | getPremiumStickers
    | getInstalledStickerSets
    | getArchivedStickerSets
    | getTrendingStickerSets
    | getAttachedStickerSets
    | getStickerSet
    | searchStickerSet
    | searchInstalledStickerSets
    | searchStickerSets
    | changeStickerSet
    | viewTrendingStickerSets
    | reorderInstalledStickerSets
    | getRecentStickers
    | addRecentSticker
    | removeRecentSticker
    | clearRecentStickers
    | getFavoriteStickers
    | addFavoriteSticker
    | removeFavoriteSticker
    | getStickerEmojis
    | searchEmojis
    | getEmojiCategories
    | getAnimatedEmoji
    | getEmojiSuggestionsUrl
    | getCustomEmojiStickers
    | getDefaultChatPhotoCustomEmojiStickers
    | getDefaultProfilePhotoCustomEmojiStickers
    | getSavedAnimations
    | addSavedAnimation
    | removeSavedAnimation
    | getRecentInlineBots
    | searchHashtags
    | removeRecentHashtag
    | getWebPagePreview
    | getWebPageInstantView
    | setProfilePhoto
    | deleteProfilePhoto
    | setName
    | setBio
    | setUsername
    | toggleUsernameIsActive
    | reorderActiveUsernames
    | setEmojiStatus
    | setLocation
    | changePhoneNumber
    | resendChangePhoneNumberCode
    | checkChangePhoneNumberCode
    | getUserLink
    | searchUserByToken
    | setCommands
    | deleteCommands
    | getCommands
    | setMenuButton
    | getMenuButton
    | setDefaultGroupAdministratorRights
    | setDefaultChannelAdministratorRights
    | canBotSendMessages
    | allowBotToSendMessages
    | sendWebAppCustomRequest
    | setBotName
    | getBotName
    | setBotProfilePhoto
    | toggleBotUsernameIsActive
    | reorderBotActiveUsernames
    | setBotInfoDescription
    | getBotInfoDescription
    | setBotInfoShortDescription
    | getBotInfoShortDescription
    | getActiveSessions
    | terminateSession
    | terminateAllOtherSessions
    | confirmSession
    | toggleSessionCanAcceptCalls
    | toggleSessionCanAcceptSecretChats
    | setInactiveSessionTtl
    | getConnectedWebsites
    | disconnectWebsite
    | disconnectAllWebsites
    | setSupergroupUsername
    | toggleSupergroupUsernameIsActive
    | disableAllSupergroupUsernames
    | reorderSupergroupActiveUsernames
    | setSupergroupStickerSet
    | toggleSupergroupSignMessages
    | toggleSupergroupJoinToSendMessages
    | toggleSupergroupJoinByRequest
    | toggleSupergroupIsAllHistoryAvailable
    | toggleSupergroupHasHiddenMembers
    | toggleSupergroupHasAggressiveAntiSpamEnabled
    | toggleSupergroupIsForum
    | toggleSupergroupIsBroadcastGroup
    | reportSupergroupSpam
    | reportSupergroupAntiSpamFalsePositive
    | getSupergroupMembers
    | closeSecretChat
    | getChatEventLog
    | getPaymentForm
    | validateOrderInfo
    | sendPaymentForm
    | getPaymentReceipt
    | getSavedOrderInfo
    | deleteSavedOrderInfo
    | deleteSavedCredentials
    | createInvoiceLink
    | getSupportUser
    | getBackgrounds
    | getBackgroundUrl
    | searchBackground
    | setBackground
    | removeBackground
    | resetBackgrounds
    | getLocalizationTargetInfo
    | getLanguagePackInfo
    | getLanguagePackStrings
    | synchronizeLanguagePack
    | addCustomServerLanguagePack
    | setCustomLanguagePack
    | editCustomLanguagePackInfo
    | setCustomLanguagePackString
    | deleteLanguagePack
    | registerDevice
    | processPushNotification
    | getPushReceiverId
    | getRecentlyVisitedTMeUrls
    | setUserPrivacySettingRules
    | getUserPrivacySettingRules
    | getOption
    | setOption
    | setAccountTtl
    | getAccountTtl
    | deleteAccount
    | setDefaultMessageAutoDeleteTime
    | getDefaultMessageAutoDeleteTime
    | removeChatActionBar
    | reportChat
    | reportChatPhoto
    | reportMessageReactions
    | getChatStatistics
    | getMessageStatistics
    | getStatisticalGraph
    | getStorageStatistics
    | getStorageStatisticsFast
    | getDatabaseStatistics
    | optimizeStorage
    | setNetworkType
    | getNetworkStatistics
    | addNetworkStatistics
    | resetNetworkStatistics
    | getAutoDownloadSettingsPresets
    | setAutoDownloadSettings
    | getAutosaveSettings
    | setAutosaveSettings
    | clearAutosaveSettingsExceptions
    | getBankCardInfo
    | getPassportElement
    | getAllPassportElements
    | setPassportElement
    | deletePassportElement
    | setPassportElementErrors
    | getPreferredCountryLanguage
    | sendPhoneNumberVerificationCode
    | resendPhoneNumberVerificationCode
    | checkPhoneNumberVerificationCode
    | sendEmailAddressVerificationCode
    | resendEmailAddressVerificationCode
    | checkEmailAddressVerificationCode
    | getPassportAuthorizationForm
    | getPassportAuthorizationFormAvailableElements
    | sendPassportAuthorizationForm
    | sendPhoneNumberConfirmationCode
    | resendPhoneNumberConfirmationCode
    | checkPhoneNumberConfirmationCode
    | setBotUpdatesStatus
    | uploadStickerFile
    | getSuggestedStickerSetName
    | checkStickerSetName
    | createNewStickerSet
    | addStickerToSet
    | setStickerSetThumbnail
    | setCustomEmojiStickerSetThumbnail
    | setStickerSetTitle
    | deleteStickerSet
    | setStickerPositionInSet
    | removeStickerFromSet
    | setStickerEmojis
    | setStickerKeywords
    | setStickerMaskPosition
    | getMapThumbnailFile
    | getPremiumLimit
    | getPremiumFeatures
    | getPremiumStickerExamples
    | viewPremiumFeature
    | clickPremiumSubscriptionButton
    | getPremiumState
    | canPurchasePremium
    | assignAppStoreTransaction
    | assignGooglePlayTransaction
    | acceptTermsOfService
    | searchStringsByPrefix
    | sendCustomRequest
    | answerCustomQuery
    | setAlarm
    | getCountries
    | getCountryCode
    | getPhoneNumberInfo
    | getPhoneNumberInfoSync
    | getDeepLinkInfo
    | getApplicationConfig
    | addApplicationChangelog
    | saveApplicationLogEvent
    | getApplicationDownloadLink
    | addProxy
    | editProxy
    | enableProxy
    | disableProxy
    | removeProxy
    | getProxies
    | getProxyLink
    | pingProxy
    | setLogStream
    | getLogStream
    | setLogVerbosityLevel
    | getLogVerbosityLevel
    | getLogTags
    | setLogTagVerbosityLevel
    | getLogTagVerbosityLevel
    | addLogMessage
    | getUserSupportInfo
    | setUserSupportInfo
    | getSupportName
    | testCallEmpty
    | testCallString
    | testCallBytes
    | testCallVectorInt
    | testCallVectorIntObject
    | testCallVectorString
    | testCallVectorStringObject
    | testSquareInt
    | testNetwork
    | testProxy
    | testGetDifference
    | testUseUpdate
    | testReturnError
  )) => Promise<
    T extends 'getAuthorizationState' ? AuthorizationState :
    T extends 'setTdlibParameters' ? Ok :
    T extends 'setAuthenticationPhoneNumber' ? Ok :
    T extends 'setAuthenticationEmailAddress' ? Ok :
    T extends 'resendAuthenticationCode' ? Ok :
    T extends 'checkAuthenticationEmailCode' ? Ok :
    T extends 'checkAuthenticationCode' ? Ok :
    T extends 'requestQrCodeAuthentication' ? Ok :
    T extends 'registerUser' ? Ok :
    T extends 'resetAuthenticationEmailAddress' ? Ok :
    T extends 'checkAuthenticationPassword' ? Ok :
    T extends 'requestAuthenticationPasswordRecovery' ? Ok :
    T extends 'checkAuthenticationPasswordRecoveryCode' ? Ok :
    T extends 'recoverAuthenticationPassword' ? Ok :
    T extends 'sendAuthenticationFirebaseSms' ? Ok :
    T extends 'checkAuthenticationBotToken' ? Ok :
    T extends 'logOut' ? Ok :
    T extends 'close' ? Ok :
    T extends 'destroy' ? Ok :
    T extends 'confirmQrCodeAuthentication' ? Session :
    T extends 'getCurrentState' ? Updates :
    T extends 'setDatabaseEncryptionKey' ? Ok :
    T extends 'getPasswordState' ? PasswordState :
    T extends 'setPassword' ? PasswordState :
    T extends 'setLoginEmailAddress' ? EmailAddressAuthenticationCodeInfo :
    T extends 'resendLoginEmailAddressCode' ? EmailAddressAuthenticationCodeInfo :
    T extends 'checkLoginEmailAddressCode' ? Ok :
    T extends 'getRecoveryEmailAddress' ? RecoveryEmailAddress :
    T extends 'setRecoveryEmailAddress' ? PasswordState :
    T extends 'checkRecoveryEmailAddressCode' ? PasswordState :
    T extends 'resendRecoveryEmailAddressCode' ? PasswordState :
    T extends 'requestPasswordRecovery' ? EmailAddressAuthenticationCodeInfo :
    T extends 'checkPasswordRecoveryCode' ? Ok :
    T extends 'recoverPassword' ? PasswordState :
    T extends 'resetPassword' ? ResetPasswordResult :
    T extends 'cancelPasswordReset' ? Ok :
    T extends 'createTemporaryPassword' ? TemporaryPasswordState :
    T extends 'getTemporaryPasswordState' ? TemporaryPasswordState :
    T extends 'getMe' ? User :
    T extends 'getUser' ? User :
    T extends 'getUserFullInfo' ? UserFullInfo :
    T extends 'getBasicGroup' ? BasicGroup :
    T extends 'getBasicGroupFullInfo' ? BasicGroupFullInfo :
    T extends 'getSupergroup' ? Supergroup :
    T extends 'getSupergroupFullInfo' ? SupergroupFullInfo :
    T extends 'getSecretChat' ? SecretChat :
    T extends 'getChat' ? Chat :
    T extends 'getMessage' ? Message :
    T extends 'getMessageLocally' ? Message :
    T extends 'getRepliedMessage' ? Message :
    T extends 'getChatPinnedMessage' ? Message :
    T extends 'getCallbackQueryMessage' ? Message :
    T extends 'getMessages' ? Messages :
    T extends 'getMessageThread' ? MessageThreadInfo :
    T extends 'getMessageViewers' ? MessageViewers :
    T extends 'getFile' ? File :
    T extends 'getRemoteFile' ? File :
    T extends 'loadChats' ? Ok :
    T extends 'getChats' ? Chats :
    T extends 'searchPublicChat' ? Chat :
    T extends 'searchPublicChats' ? Chats :
    T extends 'searchChats' ? Chats :
    T extends 'searchChatsOnServer' ? Chats :
    T extends 'searchChatsNearby' ? ChatsNearby :
    T extends 'getTopChats' ? Chats :
    T extends 'removeTopChat' ? Ok :
    T extends 'searchRecentlyFoundChats' ? Chats :
    T extends 'addRecentlyFoundChat' ? Ok :
    T extends 'removeRecentlyFoundChat' ? Ok :
    T extends 'clearRecentlyFoundChats' ? Ok :
    T extends 'getRecentlyOpenedChats' ? Chats :
    T extends 'checkChatUsername' ? CheckChatUsernameResult :
    T extends 'getCreatedPublicChats' ? Chats :
    T extends 'checkCreatedPublicChatsLimit' ? Ok :
    T extends 'getSuitableDiscussionChats' ? Chats :
    T extends 'getInactiveSupergroupChats' ? Chats :
    T extends 'getGroupsInCommon' ? Chats :
    T extends 'getChatHistory' ? Messages :
    T extends 'getMessageThreadHistory' ? Messages :
    T extends 'deleteChatHistory' ? Ok :
    T extends 'deleteChat' ? Ok :
    T extends 'searchChatMessages' ? FoundChatMessages :
    T extends 'searchMessages' ? FoundMessages :
    T extends 'searchSecretMessages' ? FoundMessages :
    T extends 'searchCallMessages' ? FoundMessages :
    T extends 'searchOutgoingDocumentMessages' ? FoundMessages :
    T extends 'deleteAllCallMessages' ? Ok :
    T extends 'searchChatRecentLocationMessages' ? Messages :
    T extends 'getActiveLiveLocationMessages' ? Messages :
    T extends 'getChatMessageByDate' ? Message :
    T extends 'getChatSparseMessagePositions' ? MessagePositions :
    T extends 'getChatMessageCalendar' ? MessageCalendar :
    T extends 'getChatMessageCount' ? Count :
    T extends 'getChatMessagePosition' ? Count :
    T extends 'getChatScheduledMessages' ? Messages :
    T extends 'getMessagePublicForwards' ? FoundMessages :
    T extends 'getChatSponsoredMessages' ? SponsoredMessages :
    T extends 'clickChatSponsoredMessage' ? Ok :
    T extends 'removeNotification' ? Ok :
    T extends 'removeNotificationGroup' ? Ok :
    T extends 'getMessageLink' ? MessageLink :
    T extends 'getMessageEmbeddingCode' ? Text :
    T extends 'getMessageLinkInfo' ? MessageLinkInfo :
    T extends 'translateText' ? FormattedText :
    T extends 'translateMessageText' ? FormattedText :
    T extends 'recognizeSpeech' ? Ok :
    T extends 'rateSpeechRecognition' ? Ok :
    T extends 'getChatAvailableMessageSenders' ? ChatMessageSenders :
    T extends 'setChatMessageSender' ? Ok :
    T extends 'sendMessage' ? Message :
    T extends 'sendMessageAlbum' ? Messages :
    T extends 'sendBotStartMessage' ? Message :
    T extends 'sendInlineQueryResultMessage' ? Message :
    T extends 'forwardMessages' ? Messages :
    T extends 'resendMessages' ? Messages :
    T extends 'addLocalMessage' ? Message :
    T extends 'deleteMessages' ? Ok :
    T extends 'deleteChatMessagesBySender' ? Ok :
    T extends 'deleteChatMessagesByDate' ? Ok :
    T extends 'editMessageText' ? Message :
    T extends 'editMessageLiveLocation' ? Message :
    T extends 'editMessageMedia' ? Message :
    T extends 'editMessageCaption' ? Message :
    T extends 'editMessageReplyMarkup' ? Message :
    T extends 'editInlineMessageText' ? Ok :
    T extends 'editInlineMessageLiveLocation' ? Ok :
    T extends 'editInlineMessageMedia' ? Ok :
    T extends 'editInlineMessageCaption' ? Ok :
    T extends 'editInlineMessageReplyMarkup' ? Ok :
    T extends 'editMessageSchedulingState' ? Ok :
    T extends 'getForumTopicDefaultIcons' ? Stickers :
    T extends 'createForumTopic' ? ForumTopicInfo :
    T extends 'editForumTopic' ? Ok :
    T extends 'getForumTopic' ? ForumTopic :
    T extends 'getForumTopicLink' ? MessageLink :
    T extends 'getForumTopics' ? ForumTopics :
    T extends 'setForumTopicNotificationSettings' ? Ok :
    T extends 'toggleForumTopicIsClosed' ? Ok :
    T extends 'toggleGeneralForumTopicIsHidden' ? Ok :
    T extends 'toggleForumTopicIsPinned' ? Ok :
    T extends 'setPinnedForumTopics' ? Ok :
    T extends 'deleteForumTopic' ? Ok :
    T extends 'getEmojiReaction' ? EmojiReaction :
    T extends 'getCustomEmojiReactionAnimations' ? Stickers :
    T extends 'getMessageAvailableReactions' ? AvailableReactions :
    T extends 'clearRecentReactions' ? Ok :
    T extends 'addMessageReaction' ? Ok :
    T extends 'removeMessageReaction' ? Ok :
    T extends 'getMessageAddedReactions' ? AddedReactions :
    T extends 'setDefaultReactionType' ? Ok :
    T extends 'getTextEntities' ? TextEntities :
    T extends 'parseTextEntities' ? FormattedText :
    T extends 'parseMarkdown' ? FormattedText :
    T extends 'getMarkdownText' ? FormattedText :
    T extends 'getFileMimeType' ? Text :
    T extends 'getFileExtension' ? Text :
    T extends 'cleanFileName' ? Text :
    T extends 'getLanguagePackString' ? LanguagePackStringValue :
    T extends 'getJsonValue' ? JsonValue :
    T extends 'getJsonString' ? Text :
    T extends 'getThemeParametersJsonString' ? Text :
    T extends 'setPollAnswer' ? Ok :
    T extends 'getPollVoters' ? MessageSenders :
    T extends 'stopPoll' ? Ok :
    T extends 'hideSuggestedAction' ? Ok :
    T extends 'getLoginUrlInfo' ? LoginUrlInfo :
    T extends 'getLoginUrl' ? HttpUrl :
    T extends 'shareUserWithBot' ? Ok :
    T extends 'shareChatWithBot' ? Ok :
    T extends 'getInlineQueryResults' ? InlineQueryResults :
    T extends 'answerInlineQuery' ? Ok :
    T extends 'searchWebApp' ? FoundWebApp :
    T extends 'getWebAppLinkUrl' ? HttpUrl :
    T extends 'getWebAppUrl' ? HttpUrl :
    T extends 'sendWebAppData' ? Ok :
    T extends 'openWebApp' ? WebAppInfo :
    T extends 'closeWebApp' ? Ok :
    T extends 'answerWebAppQuery' ? SentWebAppMessage :
    T extends 'getCallbackQueryAnswer' ? CallbackQueryAnswer :
    T extends 'answerCallbackQuery' ? Ok :
    T extends 'answerShippingQuery' ? Ok :
    T extends 'answerPreCheckoutQuery' ? Ok :
    T extends 'setGameScore' ? Message :
    T extends 'setInlineGameScore' ? Ok :
    T extends 'getGameHighScores' ? GameHighScores :
    T extends 'getInlineGameHighScores' ? GameHighScores :
    T extends 'deleteChatReplyMarkup' ? Ok :
    T extends 'sendChatAction' ? Ok :
    T extends 'openChat' ? Ok :
    T extends 'closeChat' ? Ok :
    T extends 'viewMessages' ? Ok :
    T extends 'openMessageContent' ? Ok :
    T extends 'clickAnimatedEmojiMessage' ? Sticker :
    T extends 'getInternalLink' ? HttpUrl :
    T extends 'getInternalLinkType' ? InternalLinkType :
    T extends 'getExternalLinkInfo' ? LoginUrlInfo :
    T extends 'getExternalLink' ? HttpUrl :
    T extends 'readAllChatMentions' ? Ok :
    T extends 'readAllMessageThreadMentions' ? Ok :
    T extends 'readAllChatReactions' ? Ok :
    T extends 'readAllMessageThreadReactions' ? Ok :
    T extends 'createPrivateChat' ? Chat :
    T extends 'createBasicGroupChat' ? Chat :
    T extends 'createSupergroupChat' ? Chat :
    T extends 'createSecretChat' ? Chat :
    T extends 'createNewBasicGroupChat' ? Chat :
    T extends 'createNewSupergroupChat' ? Chat :
    T extends 'createNewSecretChat' ? Chat :
    T extends 'upgradeBasicGroupChatToSupergroupChat' ? Chat :
    T extends 'getChatListsToAddChat' ? ChatLists :
    T extends 'addChatToList' ? Ok :
    T extends 'getChatFolder' ? ChatFolder :
    T extends 'createChatFolder' ? ChatFolderInfo :
    T extends 'editChatFolder' ? ChatFolderInfo :
    T extends 'deleteChatFolder' ? Ok :
    T extends 'getChatFolderChatsToLeave' ? Chats :
    T extends 'getChatFolderChatCount' ? Count :
    T extends 'reorderChatFolders' ? Ok :
    T extends 'getRecommendedChatFolders' ? RecommendedChatFolders :
    T extends 'getChatFolderDefaultIconName' ? ChatFolderIcon :
    T extends 'getChatsForChatFolderInviteLink' ? Chats :
    T extends 'createChatFolderInviteLink' ? ChatFolderInviteLink :
    T extends 'getChatFolderInviteLinks' ? ChatFolderInviteLinks :
    T extends 'editChatFolderInviteLink' ? ChatFolderInviteLink :
    T extends 'deleteChatFolderInviteLink' ? Ok :
    T extends 'checkChatFolderInviteLink' ? ChatFolderInviteLinkInfo :
    T extends 'addChatFolderByInviteLink' ? Ok :
    T extends 'getChatFolderNewChats' ? Chats :
    T extends 'processChatFolderNewChats' ? Ok :
    T extends 'getArchiveChatListSettings' ? ArchiveChatListSettings :
    T extends 'setArchiveChatListSettings' ? Ok :
    T extends 'setChatTitle' ? Ok :
    T extends 'setChatPhoto' ? Ok :
    T extends 'setChatMessageAutoDeleteTime' ? Ok :
    T extends 'setChatPermissions' ? Ok :
    T extends 'setChatBackground' ? Ok :
    T extends 'setChatTheme' ? Ok :
    T extends 'setChatDraftMessage' ? Ok :
    T extends 'setChatNotificationSettings' ? Ok :
    T extends 'toggleChatHasProtectedContent' ? Ok :
    T extends 'toggleChatIsTranslatable' ? Ok :
    T extends 'toggleChatIsMarkedAsUnread' ? Ok :
    T extends 'toggleChatDefaultDisableNotification' ? Ok :
    T extends 'setChatAvailableReactions' ? Ok :
    T extends 'setChatClientData' ? Ok :
    T extends 'setChatDescription' ? Ok :
    T extends 'setChatDiscussionGroup' ? Ok :
    T extends 'setChatLocation' ? Ok :
    T extends 'setChatSlowModeDelay' ? Ok :
    T extends 'pinChatMessage' ? Ok :
    T extends 'unpinChatMessage' ? Ok :
    T extends 'unpinAllChatMessages' ? Ok :
    T extends 'unpinAllMessageThreadMessages' ? Ok :
    T extends 'joinChat' ? Ok :
    T extends 'leaveChat' ? Ok :
    T extends 'addChatMember' ? Ok :
    T extends 'addChatMembers' ? Ok :
    T extends 'setChatMemberStatus' ? Ok :
    T extends 'banChatMember' ? Ok :
    T extends 'canTransferOwnership' ? CanTransferOwnershipResult :
    T extends 'transferChatOwnership' ? Ok :
    T extends 'getChatMember' ? ChatMember :
    T extends 'searchChatMembers' ? ChatMembers :
    T extends 'getChatAdministrators' ? ChatAdministrators :
    T extends 'clearAllDraftMessages' ? Ok :
    T extends 'getSavedNotificationSound' ? NotificationSounds :
    T extends 'getSavedNotificationSounds' ? NotificationSounds :
    T extends 'addSavedNotificationSound' ? NotificationSound :
    T extends 'removeSavedNotificationSound' ? Ok :
    T extends 'getChatNotificationSettingsExceptions' ? Chats :
    T extends 'getScopeNotificationSettings' ? ScopeNotificationSettings :
    T extends 'setScopeNotificationSettings' ? Ok :
    T extends 'resetAllNotificationSettings' ? Ok :
    T extends 'toggleChatIsPinned' ? Ok :
    T extends 'setPinnedChats' ? Ok :
    T extends 'readChatList' ? Ok :
    T extends 'getStory' ? Story :
    T extends 'getChatsToSendStories' ? Chats :
    T extends 'canSendStory' ? CanSendStoryResult :
    T extends 'sendStory' ? Story :
    T extends 'editStory' ? Ok :
    T extends 'setStoryPrivacySettings' ? Ok :
    T extends 'toggleStoryIsPinned' ? Ok :
    T extends 'deleteStory' ? Ok :
    T extends 'getStoryNotificationSettingsExceptions' ? Chats :
    T extends 'loadActiveStories' ? Ok :
    T extends 'setChatActiveStoriesList' ? Ok :
    T extends 'getChatActiveStories' ? ChatActiveStories :
    T extends 'getChatPinnedStories' ? Stories :
    T extends 'getChatArchivedStories' ? Stories :
    T extends 'openStory' ? Ok :
    T extends 'closeStory' ? Ok :
    T extends 'getStoryAvailableReactions' ? AvailableReactions :
    T extends 'setStoryReaction' ? Ok :
    T extends 'getStoryViewers' ? StoryViewers :
    T extends 'reportStory' ? Ok :
    T extends 'activateStoryStealthMode' ? Ok :
    T extends 'getChatBoostStatus' ? ChatBoostStatus :
    T extends 'canBoostChat' ? CanBoostChatResult :
    T extends 'boostChat' ? Ok :
    T extends 'getChatBoostLink' ? ChatBoostLink :
    T extends 'getChatBoostLinkInfo' ? ChatBoostLinkInfo :
    T extends 'getChatBoosts' ? FoundChatBoosts :
    T extends 'getAttachmentMenuBot' ? AttachmentMenuBot :
    T extends 'toggleBotIsAddedToAttachmentMenu' ? Ok :
    T extends 'getThemedEmojiStatuses' ? EmojiStatuses :
    T extends 'getRecentEmojiStatuses' ? EmojiStatuses :
    T extends 'getDefaultEmojiStatuses' ? EmojiStatuses :
    T extends 'clearRecentEmojiStatuses' ? Ok :
    T extends 'downloadFile' ? File :
    T extends 'getFileDownloadedPrefixSize' ? FileDownloadedPrefixSize :
    T extends 'cancelDownloadFile' ? Ok :
    T extends 'getSuggestedFileName' ? Text :
    T extends 'preliminaryUploadFile' ? File :
    T extends 'cancelPreliminaryUploadFile' ? Ok :
    T extends 'writeGeneratedFilePart' ? Ok :
    T extends 'setFileGenerationProgress' ? Ok :
    T extends 'finishFileGeneration' ? Ok :
    T extends 'readFilePart' ? FilePart :
    T extends 'deleteFile' ? Ok :
    T extends 'addFileToDownloads' ? File :
    T extends 'toggleDownloadIsPaused' ? Ok :
    T extends 'toggleAllDownloadsArePaused' ? Ok :
    T extends 'removeFileFromDownloads' ? Ok :
    T extends 'removeAllFilesFromDownloads' ? Ok :
    T extends 'searchFileDownloads' ? FoundFileDownloads :
    T extends 'getMessageFileType' ? MessageFileType :
    T extends 'getMessageImportConfirmationText' ? Text :
    T extends 'importMessages' ? Ok :
    T extends 'replacePrimaryChatInviteLink' ? ChatInviteLink :
    T extends 'createChatInviteLink' ? ChatInviteLink :
    T extends 'editChatInviteLink' ? ChatInviteLink :
    T extends 'getChatInviteLink' ? ChatInviteLink :
    T extends 'getChatInviteLinkCounts' ? ChatInviteLinkCounts :
    T extends 'getChatInviteLinks' ? ChatInviteLinks :
    T extends 'getChatInviteLinkMembers' ? ChatInviteLinkMembers :
    T extends 'revokeChatInviteLink' ? ChatInviteLinks :
    T extends 'deleteRevokedChatInviteLink' ? Ok :
    T extends 'deleteAllRevokedChatInviteLinks' ? Ok :
    T extends 'checkChatInviteLink' ? ChatInviteLinkInfo :
    T extends 'joinChatByInviteLink' ? Chat :
    T extends 'getChatJoinRequests' ? ChatJoinRequests :
    T extends 'processChatJoinRequest' ? Ok :
    T extends 'processChatJoinRequests' ? Ok :
    T extends 'createCall' ? CallId :
    T extends 'acceptCall' ? Ok :
    T extends 'sendCallSignalingData' ? Ok :
    T extends 'discardCall' ? Ok :
    T extends 'sendCallRating' ? Ok :
    T extends 'sendCallDebugInformation' ? Ok :
    T extends 'sendCallLog' ? Ok :
    T extends 'getVideoChatAvailableParticipants' ? MessageSenders :
    T extends 'setVideoChatDefaultParticipant' ? Ok :
    T extends 'createVideoChat' ? GroupCallId :
    T extends 'getVideoChatRtmpUrl' ? RtmpUrl :
    T extends 'replaceVideoChatRtmpUrl' ? RtmpUrl :
    T extends 'getGroupCall' ? GroupCall :
    T extends 'startScheduledGroupCall' ? Ok :
    T extends 'toggleGroupCallEnabledStartNotification' ? Ok :
    T extends 'joinGroupCall' ? Text :
    T extends 'startGroupCallScreenSharing' ? Text :
    T extends 'toggleGroupCallScreenSharingIsPaused' ? Ok :
    T extends 'endGroupCallScreenSharing' ? Ok :
    T extends 'setGroupCallTitle' ? Ok :
    T extends 'toggleGroupCallMuteNewParticipants' ? Ok :
    T extends 'inviteGroupCallParticipants' ? Ok :
    T extends 'getGroupCallInviteLink' ? HttpUrl :
    T extends 'revokeGroupCallInviteLink' ? Ok :
    T extends 'startGroupCallRecording' ? Ok :
    T extends 'endGroupCallRecording' ? Ok :
    T extends 'toggleGroupCallIsMyVideoPaused' ? Ok :
    T extends 'toggleGroupCallIsMyVideoEnabled' ? Ok :
    T extends 'setGroupCallParticipantIsSpeaking' ? Ok :
    T extends 'toggleGroupCallParticipantIsMuted' ? Ok :
    T extends 'setGroupCallParticipantVolumeLevel' ? Ok :
    T extends 'toggleGroupCallParticipantIsHandRaised' ? Ok :
    T extends 'loadGroupCallParticipants' ? Ok :
    T extends 'leaveGroupCall' ? Ok :
    T extends 'endGroupCall' ? Ok :
    T extends 'getGroupCallStreams' ? GroupCallStreams :
    T extends 'getGroupCallStreamSegment' ? FilePart :
    T extends 'setMessageSenderBlockList' ? Ok :
    T extends 'blockMessageSenderFromReplies' ? Ok :
    T extends 'getBlockedMessageSenders' ? MessageSenders :
    T extends 'addContact' ? Ok :
    T extends 'importContacts' ? ImportedContacts :
    T extends 'getContacts' ? Users :
    T extends 'searchContacts' ? Users :
    T extends 'removeContacts' ? Ok :
    T extends 'getImportedContactCount' ? Count :
    T extends 'changeImportedContacts' ? ImportedContacts :
    T extends 'clearImportedContacts' ? Ok :
    T extends 'setCloseFriends' ? Ok :
    T extends 'getCloseFriends' ? Users :
    T extends 'setUserPersonalProfilePhoto' ? Ok :
    T extends 'suggestUserProfilePhoto' ? Ok :
    T extends 'searchUserByPhoneNumber' ? User :
    T extends 'sharePhoneNumber' ? Ok :
    T extends 'getUserProfilePhotos' ? ChatPhotos :
    T extends 'getStickers' ? Stickers :
    T extends 'getAllStickerEmojis' ? Emojis :
    T extends 'searchStickers' ? Stickers :
    T extends 'getPremiumStickers' ? Stickers :
    T extends 'getInstalledStickerSets' ? StickerSets :
    T extends 'getArchivedStickerSets' ? StickerSets :
    T extends 'getTrendingStickerSets' ? TrendingStickerSets :
    T extends 'getAttachedStickerSets' ? StickerSets :
    T extends 'getStickerSet' ? StickerSet :
    T extends 'searchStickerSet' ? StickerSet :
    T extends 'searchInstalledStickerSets' ? StickerSets :
    T extends 'searchStickerSets' ? StickerSets :
    T extends 'changeStickerSet' ? Ok :
    T extends 'viewTrendingStickerSets' ? Ok :
    T extends 'reorderInstalledStickerSets' ? Ok :
    T extends 'getRecentStickers' ? Stickers :
    T extends 'addRecentSticker' ? Stickers :
    T extends 'removeRecentSticker' ? Ok :
    T extends 'clearRecentStickers' ? Ok :
    T extends 'getFavoriteStickers' ? Stickers :
    T extends 'addFavoriteSticker' ? Ok :
    T extends 'removeFavoriteSticker' ? Ok :
    T extends 'getStickerEmojis' ? Emojis :
    T extends 'searchEmojis' ? Emojis :
    T extends 'getEmojiCategories' ? EmojiCategories :
    T extends 'getAnimatedEmoji' ? AnimatedEmoji :
    T extends 'getEmojiSuggestionsUrl' ? HttpUrl :
    T extends 'getCustomEmojiStickers' ? Stickers :
    T extends 'getDefaultChatPhotoCustomEmojiStickers' ? Stickers :
    T extends 'getDefaultProfilePhotoCustomEmojiStickers' ? Stickers :
    T extends 'getSavedAnimations' ? Animations :
    T extends 'addSavedAnimation' ? Ok :
    T extends 'removeSavedAnimation' ? Ok :
    T extends 'getRecentInlineBots' ? Users :
    T extends 'searchHashtags' ? Hashtags :
    T extends 'removeRecentHashtag' ? Ok :
    T extends 'getWebPagePreview' ? WebPage :
    T extends 'getWebPageInstantView' ? WebPageInstantView :
    T extends 'setProfilePhoto' ? Ok :
    T extends 'deleteProfilePhoto' ? Ok :
    T extends 'setName' ? Ok :
    T extends 'setBio' ? Ok :
    T extends 'setUsername' ? Ok :
    T extends 'toggleUsernameIsActive' ? Ok :
    T extends 'reorderActiveUsernames' ? Ok :
    T extends 'setEmojiStatus' ? Ok :
    T extends 'setLocation' ? Ok :
    T extends 'changePhoneNumber' ? AuthenticationCodeInfo :
    T extends 'resendChangePhoneNumberCode' ? AuthenticationCodeInfo :
    T extends 'checkChangePhoneNumberCode' ? Ok :
    T extends 'getUserLink' ? UserLink :
    T extends 'searchUserByToken' ? User :
    T extends 'setCommands' ? Ok :
    T extends 'deleteCommands' ? Ok :
    T extends 'getCommands' ? BotCommands :
    T extends 'setMenuButton' ? Ok :
    T extends 'getMenuButton' ? BotMenuButton :
    T extends 'setDefaultGroupAdministratorRights' ? Ok :
    T extends 'setDefaultChannelAdministratorRights' ? Ok :
    T extends 'canBotSendMessages' ? Ok :
    T extends 'allowBotToSendMessages' ? Ok :
    T extends 'sendWebAppCustomRequest' ? CustomRequestResult :
    T extends 'setBotName' ? Ok :
    T extends 'getBotName' ? Text :
    T extends 'setBotProfilePhoto' ? Ok :
    T extends 'toggleBotUsernameIsActive' ? Ok :
    T extends 'reorderBotActiveUsernames' ? Ok :
    T extends 'setBotInfoDescription' ? Ok :
    T extends 'getBotInfoDescription' ? Text :
    T extends 'setBotInfoShortDescription' ? Ok :
    T extends 'getBotInfoShortDescription' ? Text :
    T extends 'getActiveSessions' ? Sessions :
    T extends 'terminateSession' ? Ok :
    T extends 'terminateAllOtherSessions' ? Ok :
    T extends 'confirmSession' ? Ok :
    T extends 'toggleSessionCanAcceptCalls' ? Ok :
    T extends 'toggleSessionCanAcceptSecretChats' ? Ok :
    T extends 'setInactiveSessionTtl' ? Ok :
    T extends 'getConnectedWebsites' ? ConnectedWebsites :
    T extends 'disconnectWebsite' ? Ok :
    T extends 'disconnectAllWebsites' ? Ok :
    T extends 'setSupergroupUsername' ? Ok :
    T extends 'toggleSupergroupUsernameIsActive' ? Ok :
    T extends 'disableAllSupergroupUsernames' ? Ok :
    T extends 'reorderSupergroupActiveUsernames' ? Ok :
    T extends 'setSupergroupStickerSet' ? Ok :
    T extends 'toggleSupergroupSignMessages' ? Ok :
    T extends 'toggleSupergroupJoinToSendMessages' ? Ok :
    T extends 'toggleSupergroupJoinByRequest' ? Ok :
    T extends 'toggleSupergroupIsAllHistoryAvailable' ? Ok :
    T extends 'toggleSupergroupHasHiddenMembers' ? Ok :
    T extends 'toggleSupergroupHasAggressiveAntiSpamEnabled' ? Ok :
    T extends 'toggleSupergroupIsForum' ? Ok :
    T extends 'toggleSupergroupIsBroadcastGroup' ? Ok :
    T extends 'reportSupergroupSpam' ? Ok :
    T extends 'reportSupergroupAntiSpamFalsePositive' ? Ok :
    T extends 'getSupergroupMembers' ? ChatMembers :
    T extends 'closeSecretChat' ? Ok :
    T extends 'getChatEventLog' ? ChatEvents :
    T extends 'getPaymentForm' ? PaymentForm :
    T extends 'validateOrderInfo' ? ValidatedOrderInfo :
    T extends 'sendPaymentForm' ? PaymentResult :
    T extends 'getPaymentReceipt' ? PaymentReceipt :
    T extends 'getSavedOrderInfo' ? OrderInfo :
    T extends 'deleteSavedOrderInfo' ? Ok :
    T extends 'deleteSavedCredentials' ? Ok :
    T extends 'createInvoiceLink' ? HttpUrl :
    T extends 'getSupportUser' ? User :
    T extends 'getBackgrounds' ? Backgrounds :
    T extends 'getBackgroundUrl' ? HttpUrl :
    T extends 'searchBackground' ? Background :
    T extends 'setBackground' ? Background :
    T extends 'removeBackground' ? Ok :
    T extends 'resetBackgrounds' ? Ok :
    T extends 'getLocalizationTargetInfo' ? LocalizationTargetInfo :
    T extends 'getLanguagePackInfo' ? LanguagePackInfo :
    T extends 'getLanguagePackStrings' ? LanguagePackStrings :
    T extends 'synchronizeLanguagePack' ? Ok :
    T extends 'addCustomServerLanguagePack' ? Ok :
    T extends 'setCustomLanguagePack' ? Ok :
    T extends 'editCustomLanguagePackInfo' ? Ok :
    T extends 'setCustomLanguagePackString' ? Ok :
    T extends 'deleteLanguagePack' ? Ok :
    T extends 'registerDevice' ? PushReceiverId :
    T extends 'processPushNotification' ? Ok :
    T extends 'getPushReceiverId' ? PushReceiverId :
    T extends 'getRecentlyVisitedTMeUrls' ? TMeUrls :
    T extends 'setUserPrivacySettingRules' ? Ok :
    T extends 'getUserPrivacySettingRules' ? UserPrivacySettingRules :
    T extends 'getOption' ? OptionValue :
    T extends 'setOption' ? Ok :
    T extends 'setAccountTtl' ? Ok :
    T extends 'getAccountTtl' ? AccountTtl :
    T extends 'deleteAccount' ? Ok :
    T extends 'setDefaultMessageAutoDeleteTime' ? Ok :
    T extends 'getDefaultMessageAutoDeleteTime' ? MessageAutoDeleteTime :
    T extends 'removeChatActionBar' ? Ok :
    T extends 'reportChat' ? Ok :
    T extends 'reportChatPhoto' ? Ok :
    T extends 'reportMessageReactions' ? Ok :
    T extends 'getChatStatistics' ? ChatStatistics :
    T extends 'getMessageStatistics' ? MessageStatistics :
    T extends 'getStatisticalGraph' ? StatisticalGraph :
    T extends 'getStorageStatistics' ? StorageStatistics :
    T extends 'getStorageStatisticsFast' ? StorageStatisticsFast :
    T extends 'getDatabaseStatistics' ? DatabaseStatistics :
    T extends 'optimizeStorage' ? StorageStatistics :
    T extends 'setNetworkType' ? Ok :
    T extends 'getNetworkStatistics' ? NetworkStatistics :
    T extends 'addNetworkStatistics' ? Ok :
    T extends 'resetNetworkStatistics' ? Ok :
    T extends 'getAutoDownloadSettingsPresets' ? AutoDownloadSettingsPresets :
    T extends 'setAutoDownloadSettings' ? Ok :
    T extends 'getAutosaveSettings' ? AutosaveSettings :
    T extends 'setAutosaveSettings' ? Ok :
    T extends 'clearAutosaveSettingsExceptions' ? Ok :
    T extends 'getBankCardInfo' ? BankCardInfo :
    T extends 'getPassportElement' ? PassportElement :
    T extends 'getAllPassportElements' ? PassportElements :
    T extends 'setPassportElement' ? PassportElement :
    T extends 'deletePassportElement' ? Ok :
    T extends 'setPassportElementErrors' ? Ok :
    T extends 'getPreferredCountryLanguage' ? Text :
    T extends 'sendPhoneNumberVerificationCode' ? AuthenticationCodeInfo :
    T extends 'resendPhoneNumberVerificationCode' ? AuthenticationCodeInfo :
    T extends 'checkPhoneNumberVerificationCode' ? Ok :
    T extends 'sendEmailAddressVerificationCode' ? EmailAddressAuthenticationCodeInfo :
    T extends 'resendEmailAddressVerificationCode' ? EmailAddressAuthenticationCodeInfo :
    T extends 'checkEmailAddressVerificationCode' ? Ok :
    T extends 'getPassportAuthorizationForm' ? PassportAuthorizationForm :
    T extends 'getPassportAuthorizationFormAvailableElements' ? PassportElementsWithErrors :
    T extends 'sendPassportAuthorizationForm' ? Ok :
    T extends 'sendPhoneNumberConfirmationCode' ? AuthenticationCodeInfo :
    T extends 'resendPhoneNumberConfirmationCode' ? AuthenticationCodeInfo :
    T extends 'checkPhoneNumberConfirmationCode' ? Ok :
    T extends 'setBotUpdatesStatus' ? Ok :
    T extends 'uploadStickerFile' ? File :
    T extends 'getSuggestedStickerSetName' ? Text :
    T extends 'checkStickerSetName' ? CheckStickerSetNameResult :
    T extends 'createNewStickerSet' ? StickerSet :
    T extends 'addStickerToSet' ? Ok :
    T extends 'setStickerSetThumbnail' ? Ok :
    T extends 'setCustomEmojiStickerSetThumbnail' ? Ok :
    T extends 'setStickerSetTitle' ? Ok :
    T extends 'deleteStickerSet' ? Ok :
    T extends 'setStickerPositionInSet' ? Ok :
    T extends 'removeStickerFromSet' ? Ok :
    T extends 'setStickerEmojis' ? Ok :
    T extends 'setStickerKeywords' ? Ok :
    T extends 'setStickerMaskPosition' ? Ok :
    T extends 'getMapThumbnailFile' ? File :
    T extends 'getPremiumLimit' ? PremiumLimit :
    T extends 'getPremiumFeatures' ? PremiumFeatures :
    T extends 'getPremiumStickerExamples' ? Stickers :
    T extends 'viewPremiumFeature' ? Ok :
    T extends 'clickPremiumSubscriptionButton' ? Ok :
    T extends 'getPremiumState' ? PremiumState :
    T extends 'canPurchasePremium' ? Ok :
    T extends 'assignAppStoreTransaction' ? Ok :
    T extends 'assignGooglePlayTransaction' ? Ok :
    T extends 'acceptTermsOfService' ? Ok :
    T extends 'searchStringsByPrefix' ? FoundPositions :
    T extends 'sendCustomRequest' ? CustomRequestResult :
    T extends 'answerCustomQuery' ? Ok :
    T extends 'setAlarm' ? Ok :
    T extends 'getCountries' ? Countries :
    T extends 'getCountryCode' ? Text :
    T extends 'getPhoneNumberInfo' ? PhoneNumberInfo :
    T extends 'getPhoneNumberInfoSync' ? PhoneNumberInfo :
    T extends 'getDeepLinkInfo' ? DeepLinkInfo :
    T extends 'getApplicationConfig' ? JsonValue :
    T extends 'addApplicationChangelog' ? Ok :
    T extends 'saveApplicationLogEvent' ? Ok :
    T extends 'getApplicationDownloadLink' ? HttpUrl :
    T extends 'addProxy' ? Proxy :
    T extends 'editProxy' ? Proxy :
    T extends 'enableProxy' ? Ok :
    T extends 'disableProxy' ? Ok :
    T extends 'removeProxy' ? Ok :
    T extends 'getProxies' ? Proxies :
    T extends 'getProxyLink' ? HttpUrl :
    T extends 'pingProxy' ? Seconds :
    T extends 'setLogStream' ? Ok :
    T extends 'getLogStream' ? LogStream :
    T extends 'setLogVerbosityLevel' ? Ok :
    T extends 'getLogVerbosityLevel' ? LogVerbosityLevel :
    T extends 'getLogTags' ? LogTags :
    T extends 'setLogTagVerbosityLevel' ? Ok :
    T extends 'getLogTagVerbosityLevel' ? LogVerbosityLevel :
    T extends 'addLogMessage' ? Ok :
    T extends 'getUserSupportInfo' ? UserSupportInfo :
    T extends 'setUserSupportInfo' ? UserSupportInfo :
    T extends 'getSupportName' ? Text :
    T extends 'testCallEmpty' ? Ok :
    T extends 'testCallString' ? TestString :
    T extends 'testCallBytes' ? TestBytes :
    T extends 'testCallVectorInt' ? TestVectorInt :
    T extends 'testCallVectorIntObject' ? TestVectorIntObject :
    T extends 'testCallVectorString' ? TestVectorString :
    T extends 'testCallVectorStringObject' ? TestVectorStringObject :
    T extends 'testSquareInt' ? TestInt :
    T extends 'testNetwork' ? Ok :
    T extends 'testProxy' ? Ok :
    T extends 'testGetDifference' ? Ok :
    T extends 'testUseUpdate' ? Update :
    T extends 'testReturnError' ? Error :
  never>

  export type Execute = <T>(query: { readonly _: T } & (
    getAuthorizationState
    | setTdlibParameters
    | setAuthenticationPhoneNumber
    | setAuthenticationEmailAddress
    | resendAuthenticationCode
    | checkAuthenticationEmailCode
    | checkAuthenticationCode
    | requestQrCodeAuthentication
    | registerUser
    | resetAuthenticationEmailAddress
    | checkAuthenticationPassword
    | requestAuthenticationPasswordRecovery
    | checkAuthenticationPasswordRecoveryCode
    | recoverAuthenticationPassword
    | sendAuthenticationFirebaseSms
    | checkAuthenticationBotToken
    | logOut
    | close
    | destroy
    | confirmQrCodeAuthentication
    | getCurrentState
    | setDatabaseEncryptionKey
    | getPasswordState
    | setPassword
    | setLoginEmailAddress
    | resendLoginEmailAddressCode
    | checkLoginEmailAddressCode
    | getRecoveryEmailAddress
    | setRecoveryEmailAddress
    | checkRecoveryEmailAddressCode
    | resendRecoveryEmailAddressCode
    | requestPasswordRecovery
    | checkPasswordRecoveryCode
    | recoverPassword
    | resetPassword
    | cancelPasswordReset
    | createTemporaryPassword
    | getTemporaryPasswordState
    | getMe
    | getUser
    | getUserFullInfo
    | getBasicGroup
    | getBasicGroupFullInfo
    | getSupergroup
    | getSupergroupFullInfo
    | getSecretChat
    | getChat
    | getMessage
    | getMessageLocally
    | getRepliedMessage
    | getChatPinnedMessage
    | getCallbackQueryMessage
    | getMessages
    | getMessageThread
    | getMessageViewers
    | getFile
    | getRemoteFile
    | loadChats
    | getChats
    | searchPublicChat
    | searchPublicChats
    | searchChats
    | searchChatsOnServer
    | searchChatsNearby
    | getTopChats
    | removeTopChat
    | searchRecentlyFoundChats
    | addRecentlyFoundChat
    | removeRecentlyFoundChat
    | clearRecentlyFoundChats
    | getRecentlyOpenedChats
    | checkChatUsername
    | getCreatedPublicChats
    | checkCreatedPublicChatsLimit
    | getSuitableDiscussionChats
    | getInactiveSupergroupChats
    | getGroupsInCommon
    | getChatHistory
    | getMessageThreadHistory
    | deleteChatHistory
    | deleteChat
    | searchChatMessages
    | searchMessages
    | searchSecretMessages
    | searchCallMessages
    | searchOutgoingDocumentMessages
    | deleteAllCallMessages
    | searchChatRecentLocationMessages
    | getActiveLiveLocationMessages
    | getChatMessageByDate
    | getChatSparseMessagePositions
    | getChatMessageCalendar
    | getChatMessageCount
    | getChatMessagePosition
    | getChatScheduledMessages
    | getMessagePublicForwards
    | getChatSponsoredMessages
    | clickChatSponsoredMessage
    | removeNotification
    | removeNotificationGroup
    | getMessageLink
    | getMessageEmbeddingCode
    | getMessageLinkInfo
    | translateText
    | translateMessageText
    | recognizeSpeech
    | rateSpeechRecognition
    | getChatAvailableMessageSenders
    | setChatMessageSender
    | sendMessage
    | sendMessageAlbum
    | sendBotStartMessage
    | sendInlineQueryResultMessage
    | forwardMessages
    | resendMessages
    | addLocalMessage
    | deleteMessages
    | deleteChatMessagesBySender
    | deleteChatMessagesByDate
    | editMessageText
    | editMessageLiveLocation
    | editMessageMedia
    | editMessageCaption
    | editMessageReplyMarkup
    | editInlineMessageText
    | editInlineMessageLiveLocation
    | editInlineMessageMedia
    | editInlineMessageCaption
    | editInlineMessageReplyMarkup
    | editMessageSchedulingState
    | getForumTopicDefaultIcons
    | createForumTopic
    | editForumTopic
    | getForumTopic
    | getForumTopicLink
    | getForumTopics
    | setForumTopicNotificationSettings
    | toggleForumTopicIsClosed
    | toggleGeneralForumTopicIsHidden
    | toggleForumTopicIsPinned
    | setPinnedForumTopics
    | deleteForumTopic
    | getEmojiReaction
    | getCustomEmojiReactionAnimations
    | getMessageAvailableReactions
    | clearRecentReactions
    | addMessageReaction
    | removeMessageReaction
    | getMessageAddedReactions
    | setDefaultReactionType
    | getTextEntities
    | parseTextEntities
    | parseMarkdown
    | getMarkdownText
    | getFileMimeType
    | getFileExtension
    | cleanFileName
    | getLanguagePackString
    | getJsonValue
    | getJsonString
    | getThemeParametersJsonString
    | setPollAnswer
    | getPollVoters
    | stopPoll
    | hideSuggestedAction
    | getLoginUrlInfo
    | getLoginUrl
    | shareUserWithBot
    | shareChatWithBot
    | getInlineQueryResults
    | answerInlineQuery
    | searchWebApp
    | getWebAppLinkUrl
    | getWebAppUrl
    | sendWebAppData
    | openWebApp
    | closeWebApp
    | answerWebAppQuery
    | getCallbackQueryAnswer
    | answerCallbackQuery
    | answerShippingQuery
    | answerPreCheckoutQuery
    | setGameScore
    | setInlineGameScore
    | getGameHighScores
    | getInlineGameHighScores
    | deleteChatReplyMarkup
    | sendChatAction
    | openChat
    | closeChat
    | viewMessages
    | openMessageContent
    | clickAnimatedEmojiMessage
    | getInternalLink
    | getInternalLinkType
    | getExternalLinkInfo
    | getExternalLink
    | readAllChatMentions
    | readAllMessageThreadMentions
    | readAllChatReactions
    | readAllMessageThreadReactions
    | createPrivateChat
    | createBasicGroupChat
    | createSupergroupChat
    | createSecretChat
    | createNewBasicGroupChat
    | createNewSupergroupChat
    | createNewSecretChat
    | upgradeBasicGroupChatToSupergroupChat
    | getChatListsToAddChat
    | addChatToList
    | getChatFolder
    | createChatFolder
    | editChatFolder
    | deleteChatFolder
    | getChatFolderChatsToLeave
    | getChatFolderChatCount
    | reorderChatFolders
    | getRecommendedChatFolders
    | getChatFolderDefaultIconName
    | getChatsForChatFolderInviteLink
    | createChatFolderInviteLink
    | getChatFolderInviteLinks
    | editChatFolderInviteLink
    | deleteChatFolderInviteLink
    | checkChatFolderInviteLink
    | addChatFolderByInviteLink
    | getChatFolderNewChats
    | processChatFolderNewChats
    | getArchiveChatListSettings
    | setArchiveChatListSettings
    | setChatTitle
    | setChatPhoto
    | setChatMessageAutoDeleteTime
    | setChatPermissions
    | setChatBackground
    | setChatTheme
    | setChatDraftMessage
    | setChatNotificationSettings
    | toggleChatHasProtectedContent
    | toggleChatIsTranslatable
    | toggleChatIsMarkedAsUnread
    | toggleChatDefaultDisableNotification
    | setChatAvailableReactions
    | setChatClientData
    | setChatDescription
    | setChatDiscussionGroup
    | setChatLocation
    | setChatSlowModeDelay
    | pinChatMessage
    | unpinChatMessage
    | unpinAllChatMessages
    | unpinAllMessageThreadMessages
    | joinChat
    | leaveChat
    | addChatMember
    | addChatMembers
    | setChatMemberStatus
    | banChatMember
    | canTransferOwnership
    | transferChatOwnership
    | getChatMember
    | searchChatMembers
    | getChatAdministrators
    | clearAllDraftMessages
    | getSavedNotificationSound
    | getSavedNotificationSounds
    | addSavedNotificationSound
    | removeSavedNotificationSound
    | getChatNotificationSettingsExceptions
    | getScopeNotificationSettings
    | setScopeNotificationSettings
    | resetAllNotificationSettings
    | toggleChatIsPinned
    | setPinnedChats
    | readChatList
    | getStory
    | getChatsToSendStories
    | canSendStory
    | sendStory
    | editStory
    | setStoryPrivacySettings
    | toggleStoryIsPinned
    | deleteStory
    | getStoryNotificationSettingsExceptions
    | loadActiveStories
    | setChatActiveStoriesList
    | getChatActiveStories
    | getChatPinnedStories
    | getChatArchivedStories
    | openStory
    | closeStory
    | getStoryAvailableReactions
    | setStoryReaction
    | getStoryViewers
    | reportStory
    | activateStoryStealthMode
    | getChatBoostStatus
    | canBoostChat
    | boostChat
    | getChatBoostLink
    | getChatBoostLinkInfo
    | getChatBoosts
    | getAttachmentMenuBot
    | toggleBotIsAddedToAttachmentMenu
    | getThemedEmojiStatuses
    | getRecentEmojiStatuses
    | getDefaultEmojiStatuses
    | clearRecentEmojiStatuses
    | downloadFile
    | getFileDownloadedPrefixSize
    | cancelDownloadFile
    | getSuggestedFileName
    | preliminaryUploadFile
    | cancelPreliminaryUploadFile
    | writeGeneratedFilePart
    | setFileGenerationProgress
    | finishFileGeneration
    | readFilePart
    | deleteFile
    | addFileToDownloads
    | toggleDownloadIsPaused
    | toggleAllDownloadsArePaused
    | removeFileFromDownloads
    | removeAllFilesFromDownloads
    | searchFileDownloads
    | getMessageFileType
    | getMessageImportConfirmationText
    | importMessages
    | replacePrimaryChatInviteLink
    | createChatInviteLink
    | editChatInviteLink
    | getChatInviteLink
    | getChatInviteLinkCounts
    | getChatInviteLinks
    | getChatInviteLinkMembers
    | revokeChatInviteLink
    | deleteRevokedChatInviteLink
    | deleteAllRevokedChatInviteLinks
    | checkChatInviteLink
    | joinChatByInviteLink
    | getChatJoinRequests
    | processChatJoinRequest
    | processChatJoinRequests
    | createCall
    | acceptCall
    | sendCallSignalingData
    | discardCall
    | sendCallRating
    | sendCallDebugInformation
    | sendCallLog
    | getVideoChatAvailableParticipants
    | setVideoChatDefaultParticipant
    | createVideoChat
    | getVideoChatRtmpUrl
    | replaceVideoChatRtmpUrl
    | getGroupCall
    | startScheduledGroupCall
    | toggleGroupCallEnabledStartNotification
    | joinGroupCall
    | startGroupCallScreenSharing
    | toggleGroupCallScreenSharingIsPaused
    | endGroupCallScreenSharing
    | setGroupCallTitle
    | toggleGroupCallMuteNewParticipants
    | inviteGroupCallParticipants
    | getGroupCallInviteLink
    | revokeGroupCallInviteLink
    | startGroupCallRecording
    | endGroupCallRecording
    | toggleGroupCallIsMyVideoPaused
    | toggleGroupCallIsMyVideoEnabled
    | setGroupCallParticipantIsSpeaking
    | toggleGroupCallParticipantIsMuted
    | setGroupCallParticipantVolumeLevel
    | toggleGroupCallParticipantIsHandRaised
    | loadGroupCallParticipants
    | leaveGroupCall
    | endGroupCall
    | getGroupCallStreams
    | getGroupCallStreamSegment
    | setMessageSenderBlockList
    | blockMessageSenderFromReplies
    | getBlockedMessageSenders
    | addContact
    | importContacts
    | getContacts
    | searchContacts
    | removeContacts
    | getImportedContactCount
    | changeImportedContacts
    | clearImportedContacts
    | setCloseFriends
    | getCloseFriends
    | setUserPersonalProfilePhoto
    | suggestUserProfilePhoto
    | searchUserByPhoneNumber
    | sharePhoneNumber
    | getUserProfilePhotos
    | getStickers
    | getAllStickerEmojis
    | searchStickers
    | getPremiumStickers
    | getInstalledStickerSets
    | getArchivedStickerSets
    | getTrendingStickerSets
    | getAttachedStickerSets
    | getStickerSet
    | searchStickerSet
    | searchInstalledStickerSets
    | searchStickerSets
    | changeStickerSet
    | viewTrendingStickerSets
    | reorderInstalledStickerSets
    | getRecentStickers
    | addRecentSticker
    | removeRecentSticker
    | clearRecentStickers
    | getFavoriteStickers
    | addFavoriteSticker
    | removeFavoriteSticker
    | getStickerEmojis
    | searchEmojis
    | getEmojiCategories
    | getAnimatedEmoji
    | getEmojiSuggestionsUrl
    | getCustomEmojiStickers
    | getDefaultChatPhotoCustomEmojiStickers
    | getDefaultProfilePhotoCustomEmojiStickers
    | getSavedAnimations
    | addSavedAnimation
    | removeSavedAnimation
    | getRecentInlineBots
    | searchHashtags
    | removeRecentHashtag
    | getWebPagePreview
    | getWebPageInstantView
    | setProfilePhoto
    | deleteProfilePhoto
    | setName
    | setBio
    | setUsername
    | toggleUsernameIsActive
    | reorderActiveUsernames
    | setEmojiStatus
    | setLocation
    | changePhoneNumber
    | resendChangePhoneNumberCode
    | checkChangePhoneNumberCode
    | getUserLink
    | searchUserByToken
    | setCommands
    | deleteCommands
    | getCommands
    | setMenuButton
    | getMenuButton
    | setDefaultGroupAdministratorRights
    | setDefaultChannelAdministratorRights
    | canBotSendMessages
    | allowBotToSendMessages
    | sendWebAppCustomRequest
    | setBotName
    | getBotName
    | setBotProfilePhoto
    | toggleBotUsernameIsActive
    | reorderBotActiveUsernames
    | setBotInfoDescription
    | getBotInfoDescription
    | setBotInfoShortDescription
    | getBotInfoShortDescription
    | getActiveSessions
    | terminateSession
    | terminateAllOtherSessions
    | confirmSession
    | toggleSessionCanAcceptCalls
    | toggleSessionCanAcceptSecretChats
    | setInactiveSessionTtl
    | getConnectedWebsites
    | disconnectWebsite
    | disconnectAllWebsites
    | setSupergroupUsername
    | toggleSupergroupUsernameIsActive
    | disableAllSupergroupUsernames
    | reorderSupergroupActiveUsernames
    | setSupergroupStickerSet
    | toggleSupergroupSignMessages
    | toggleSupergroupJoinToSendMessages
    | toggleSupergroupJoinByRequest
    | toggleSupergroupIsAllHistoryAvailable
    | toggleSupergroupHasHiddenMembers
    | toggleSupergroupHasAggressiveAntiSpamEnabled
    | toggleSupergroupIsForum
    | toggleSupergroupIsBroadcastGroup
    | reportSupergroupSpam
    | reportSupergroupAntiSpamFalsePositive
    | getSupergroupMembers
    | closeSecretChat
    | getChatEventLog
    | getPaymentForm
    | validateOrderInfo
    | sendPaymentForm
    | getPaymentReceipt
    | getSavedOrderInfo
    | deleteSavedOrderInfo
    | deleteSavedCredentials
    | createInvoiceLink
    | getSupportUser
    | getBackgrounds
    | getBackgroundUrl
    | searchBackground
    | setBackground
    | removeBackground
    | resetBackgrounds
    | getLocalizationTargetInfo
    | getLanguagePackInfo
    | getLanguagePackStrings
    | synchronizeLanguagePack
    | addCustomServerLanguagePack
    | setCustomLanguagePack
    | editCustomLanguagePackInfo
    | setCustomLanguagePackString
    | deleteLanguagePack
    | registerDevice
    | processPushNotification
    | getPushReceiverId
    | getRecentlyVisitedTMeUrls
    | setUserPrivacySettingRules
    | getUserPrivacySettingRules
    | getOption
    | setOption
    | setAccountTtl
    | getAccountTtl
    | deleteAccount
    | setDefaultMessageAutoDeleteTime
    | getDefaultMessageAutoDeleteTime
    | removeChatActionBar
    | reportChat
    | reportChatPhoto
    | reportMessageReactions
    | getChatStatistics
    | getMessageStatistics
    | getStatisticalGraph
    | getStorageStatistics
    | getStorageStatisticsFast
    | getDatabaseStatistics
    | optimizeStorage
    | setNetworkType
    | getNetworkStatistics
    | addNetworkStatistics
    | resetNetworkStatistics
    | getAutoDownloadSettingsPresets
    | setAutoDownloadSettings
    | getAutosaveSettings
    | setAutosaveSettings
    | clearAutosaveSettingsExceptions
    | getBankCardInfo
    | getPassportElement
    | getAllPassportElements
    | setPassportElement
    | deletePassportElement
    | setPassportElementErrors
    | getPreferredCountryLanguage
    | sendPhoneNumberVerificationCode
    | resendPhoneNumberVerificationCode
    | checkPhoneNumberVerificationCode
    | sendEmailAddressVerificationCode
    | resendEmailAddressVerificationCode
    | checkEmailAddressVerificationCode
    | getPassportAuthorizationForm
    | getPassportAuthorizationFormAvailableElements
    | sendPassportAuthorizationForm
    | sendPhoneNumberConfirmationCode
    | resendPhoneNumberConfirmationCode
    | checkPhoneNumberConfirmationCode
    | setBotUpdatesStatus
    | uploadStickerFile
    | getSuggestedStickerSetName
    | checkStickerSetName
    | createNewStickerSet
    | addStickerToSet
    | setStickerSetThumbnail
    | setCustomEmojiStickerSetThumbnail
    | setStickerSetTitle
    | deleteStickerSet
    | setStickerPositionInSet
    | removeStickerFromSet
    | setStickerEmojis
    | setStickerKeywords
    | setStickerMaskPosition
    | getMapThumbnailFile
    | getPremiumLimit
    | getPremiumFeatures
    | getPremiumStickerExamples
    | viewPremiumFeature
    | clickPremiumSubscriptionButton
    | getPremiumState
    | canPurchasePremium
    | assignAppStoreTransaction
    | assignGooglePlayTransaction
    | acceptTermsOfService
    | searchStringsByPrefix
    | sendCustomRequest
    | answerCustomQuery
    | setAlarm
    | getCountries
    | getCountryCode
    | getPhoneNumberInfo
    | getPhoneNumberInfoSync
    | getDeepLinkInfo
    | getApplicationConfig
    | addApplicationChangelog
    | saveApplicationLogEvent
    | getApplicationDownloadLink
    | addProxy
    | editProxy
    | enableProxy
    | disableProxy
    | removeProxy
    | getProxies
    | getProxyLink
    | pingProxy
    | setLogStream
    | getLogStream
    | setLogVerbosityLevel
    | getLogVerbosityLevel
    | getLogTags
    | setLogTagVerbosityLevel
    | getLogTagVerbosityLevel
    | addLogMessage
    | getUserSupportInfo
    | setUserSupportInfo
    | getSupportName
    | testCallEmpty
    | testCallString
    | testCallBytes
    | testCallVectorInt
    | testCallVectorIntObject
    | testCallVectorString
    | testCallVectorStringObject
    | testSquareInt
    | testNetwork
    | testProxy
    | testGetDifference
    | testUseUpdate
    | testReturnError
  )) => null | error | (
    T extends 'getAuthorizationState' ? AuthorizationState :
    T extends 'setTdlibParameters' ? Ok :
    T extends 'setAuthenticationPhoneNumber' ? Ok :
    T extends 'setAuthenticationEmailAddress' ? Ok :
    T extends 'resendAuthenticationCode' ? Ok :
    T extends 'checkAuthenticationEmailCode' ? Ok :
    T extends 'checkAuthenticationCode' ? Ok :
    T extends 'requestQrCodeAuthentication' ? Ok :
    T extends 'registerUser' ? Ok :
    T extends 'resetAuthenticationEmailAddress' ? Ok :
    T extends 'checkAuthenticationPassword' ? Ok :
    T extends 'requestAuthenticationPasswordRecovery' ? Ok :
    T extends 'checkAuthenticationPasswordRecoveryCode' ? Ok :
    T extends 'recoverAuthenticationPassword' ? Ok :
    T extends 'sendAuthenticationFirebaseSms' ? Ok :
    T extends 'checkAuthenticationBotToken' ? Ok :
    T extends 'logOut' ? Ok :
    T extends 'close' ? Ok :
    T extends 'destroy' ? Ok :
    T extends 'confirmQrCodeAuthentication' ? Session :
    T extends 'getCurrentState' ? Updates :
    T extends 'setDatabaseEncryptionKey' ? Ok :
    T extends 'getPasswordState' ? PasswordState :
    T extends 'setPassword' ? PasswordState :
    T extends 'setLoginEmailAddress' ? EmailAddressAuthenticationCodeInfo :
    T extends 'resendLoginEmailAddressCode' ? EmailAddressAuthenticationCodeInfo :
    T extends 'checkLoginEmailAddressCode' ? Ok :
    T extends 'getRecoveryEmailAddress' ? RecoveryEmailAddress :
    T extends 'setRecoveryEmailAddress' ? PasswordState :
    T extends 'checkRecoveryEmailAddressCode' ? PasswordState :
    T extends 'resendRecoveryEmailAddressCode' ? PasswordState :
    T extends 'requestPasswordRecovery' ? EmailAddressAuthenticationCodeInfo :
    T extends 'checkPasswordRecoveryCode' ? Ok :
    T extends 'recoverPassword' ? PasswordState :
    T extends 'resetPassword' ? ResetPasswordResult :
    T extends 'cancelPasswordReset' ? Ok :
    T extends 'createTemporaryPassword' ? TemporaryPasswordState :
    T extends 'getTemporaryPasswordState' ? TemporaryPasswordState :
    T extends 'getMe' ? User :
    T extends 'getUser' ? User :
    T extends 'getUserFullInfo' ? UserFullInfo :
    T extends 'getBasicGroup' ? BasicGroup :
    T extends 'getBasicGroupFullInfo' ? BasicGroupFullInfo :
    T extends 'getSupergroup' ? Supergroup :
    T extends 'getSupergroupFullInfo' ? SupergroupFullInfo :
    T extends 'getSecretChat' ? SecretChat :
    T extends 'getChat' ? Chat :
    T extends 'getMessage' ? Message :
    T extends 'getMessageLocally' ? Message :
    T extends 'getRepliedMessage' ? Message :
    T extends 'getChatPinnedMessage' ? Message :
    T extends 'getCallbackQueryMessage' ? Message :
    T extends 'getMessages' ? Messages :
    T extends 'getMessageThread' ? MessageThreadInfo :
    T extends 'getMessageViewers' ? MessageViewers :
    T extends 'getFile' ? File :
    T extends 'getRemoteFile' ? File :
    T extends 'loadChats' ? Ok :
    T extends 'getChats' ? Chats :
    T extends 'searchPublicChat' ? Chat :
    T extends 'searchPublicChats' ? Chats :
    T extends 'searchChats' ? Chats :
    T extends 'searchChatsOnServer' ? Chats :
    T extends 'searchChatsNearby' ? ChatsNearby :
    T extends 'getTopChats' ? Chats :
    T extends 'removeTopChat' ? Ok :
    T extends 'searchRecentlyFoundChats' ? Chats :
    T extends 'addRecentlyFoundChat' ? Ok :
    T extends 'removeRecentlyFoundChat' ? Ok :
    T extends 'clearRecentlyFoundChats' ? Ok :
    T extends 'getRecentlyOpenedChats' ? Chats :
    T extends 'checkChatUsername' ? CheckChatUsernameResult :
    T extends 'getCreatedPublicChats' ? Chats :
    T extends 'checkCreatedPublicChatsLimit' ? Ok :
    T extends 'getSuitableDiscussionChats' ? Chats :
    T extends 'getInactiveSupergroupChats' ? Chats :
    T extends 'getGroupsInCommon' ? Chats :
    T extends 'getChatHistory' ? Messages :
    T extends 'getMessageThreadHistory' ? Messages :
    T extends 'deleteChatHistory' ? Ok :
    T extends 'deleteChat' ? Ok :
    T extends 'searchChatMessages' ? FoundChatMessages :
    T extends 'searchMessages' ? FoundMessages :
    T extends 'searchSecretMessages' ? FoundMessages :
    T extends 'searchCallMessages' ? FoundMessages :
    T extends 'searchOutgoingDocumentMessages' ? FoundMessages :
    T extends 'deleteAllCallMessages' ? Ok :
    T extends 'searchChatRecentLocationMessages' ? Messages :
    T extends 'getActiveLiveLocationMessages' ? Messages :
    T extends 'getChatMessageByDate' ? Message :
    T extends 'getChatSparseMessagePositions' ? MessagePositions :
    T extends 'getChatMessageCalendar' ? MessageCalendar :
    T extends 'getChatMessageCount' ? Count :
    T extends 'getChatMessagePosition' ? Count :
    T extends 'getChatScheduledMessages' ? Messages :
    T extends 'getMessagePublicForwards' ? FoundMessages :
    T extends 'getChatSponsoredMessages' ? SponsoredMessages :
    T extends 'clickChatSponsoredMessage' ? Ok :
    T extends 'removeNotification' ? Ok :
    T extends 'removeNotificationGroup' ? Ok :
    T extends 'getMessageLink' ? MessageLink :
    T extends 'getMessageEmbeddingCode' ? Text :
    T extends 'getMessageLinkInfo' ? MessageLinkInfo :
    T extends 'translateText' ? FormattedText :
    T extends 'translateMessageText' ? FormattedText :
    T extends 'recognizeSpeech' ? Ok :
    T extends 'rateSpeechRecognition' ? Ok :
    T extends 'getChatAvailableMessageSenders' ? ChatMessageSenders :
    T extends 'setChatMessageSender' ? Ok :
    T extends 'sendMessage' ? Message :
    T extends 'sendMessageAlbum' ? Messages :
    T extends 'sendBotStartMessage' ? Message :
    T extends 'sendInlineQueryResultMessage' ? Message :
    T extends 'forwardMessages' ? Messages :
    T extends 'resendMessages' ? Messages :
    T extends 'addLocalMessage' ? Message :
    T extends 'deleteMessages' ? Ok :
    T extends 'deleteChatMessagesBySender' ? Ok :
    T extends 'deleteChatMessagesByDate' ? Ok :
    T extends 'editMessageText' ? Message :
    T extends 'editMessageLiveLocation' ? Message :
    T extends 'editMessageMedia' ? Message :
    T extends 'editMessageCaption' ? Message :
    T extends 'editMessageReplyMarkup' ? Message :
    T extends 'editInlineMessageText' ? Ok :
    T extends 'editInlineMessageLiveLocation' ? Ok :
    T extends 'editInlineMessageMedia' ? Ok :
    T extends 'editInlineMessageCaption' ? Ok :
    T extends 'editInlineMessageReplyMarkup' ? Ok :
    T extends 'editMessageSchedulingState' ? Ok :
    T extends 'getForumTopicDefaultIcons' ? Stickers :
    T extends 'createForumTopic' ? ForumTopicInfo :
    T extends 'editForumTopic' ? Ok :
    T extends 'getForumTopic' ? ForumTopic :
    T extends 'getForumTopicLink' ? MessageLink :
    T extends 'getForumTopics' ? ForumTopics :
    T extends 'setForumTopicNotificationSettings' ? Ok :
    T extends 'toggleForumTopicIsClosed' ? Ok :
    T extends 'toggleGeneralForumTopicIsHidden' ? Ok :
    T extends 'toggleForumTopicIsPinned' ? Ok :
    T extends 'setPinnedForumTopics' ? Ok :
    T extends 'deleteForumTopic' ? Ok :
    T extends 'getEmojiReaction' ? EmojiReaction :
    T extends 'getCustomEmojiReactionAnimations' ? Stickers :
    T extends 'getMessageAvailableReactions' ? AvailableReactions :
    T extends 'clearRecentReactions' ? Ok :
    T extends 'addMessageReaction' ? Ok :
    T extends 'removeMessageReaction' ? Ok :
    T extends 'getMessageAddedReactions' ? AddedReactions :
    T extends 'setDefaultReactionType' ? Ok :
    T extends 'getTextEntities' ? TextEntities :
    T extends 'parseTextEntities' ? FormattedText :
    T extends 'parseMarkdown' ? FormattedText :
    T extends 'getMarkdownText' ? FormattedText :
    T extends 'getFileMimeType' ? Text :
    T extends 'getFileExtension' ? Text :
    T extends 'cleanFileName' ? Text :
    T extends 'getLanguagePackString' ? LanguagePackStringValue :
    T extends 'getJsonValue' ? JsonValue :
    T extends 'getJsonString' ? Text :
    T extends 'getThemeParametersJsonString' ? Text :
    T extends 'setPollAnswer' ? Ok :
    T extends 'getPollVoters' ? MessageSenders :
    T extends 'stopPoll' ? Ok :
    T extends 'hideSuggestedAction' ? Ok :
    T extends 'getLoginUrlInfo' ? LoginUrlInfo :
    T extends 'getLoginUrl' ? HttpUrl :
    T extends 'shareUserWithBot' ? Ok :
    T extends 'shareChatWithBot' ? Ok :
    T extends 'getInlineQueryResults' ? InlineQueryResults :
    T extends 'answerInlineQuery' ? Ok :
    T extends 'searchWebApp' ? FoundWebApp :
    T extends 'getWebAppLinkUrl' ? HttpUrl :
    T extends 'getWebAppUrl' ? HttpUrl :
    T extends 'sendWebAppData' ? Ok :
    T extends 'openWebApp' ? WebAppInfo :
    T extends 'closeWebApp' ? Ok :
    T extends 'answerWebAppQuery' ? SentWebAppMessage :
    T extends 'getCallbackQueryAnswer' ? CallbackQueryAnswer :
    T extends 'answerCallbackQuery' ? Ok :
    T extends 'answerShippingQuery' ? Ok :
    T extends 'answerPreCheckoutQuery' ? Ok :
    T extends 'setGameScore' ? Message :
    T extends 'setInlineGameScore' ? Ok :
    T extends 'getGameHighScores' ? GameHighScores :
    T extends 'getInlineGameHighScores' ? GameHighScores :
    T extends 'deleteChatReplyMarkup' ? Ok :
    T extends 'sendChatAction' ? Ok :
    T extends 'openChat' ? Ok :
    T extends 'closeChat' ? Ok :
    T extends 'viewMessages' ? Ok :
    T extends 'openMessageContent' ? Ok :
    T extends 'clickAnimatedEmojiMessage' ? Sticker :
    T extends 'getInternalLink' ? HttpUrl :
    T extends 'getInternalLinkType' ? InternalLinkType :
    T extends 'getExternalLinkInfo' ? LoginUrlInfo :
    T extends 'getExternalLink' ? HttpUrl :
    T extends 'readAllChatMentions' ? Ok :
    T extends 'readAllMessageThreadMentions' ? Ok :
    T extends 'readAllChatReactions' ? Ok :
    T extends 'readAllMessageThreadReactions' ? Ok :
    T extends 'createPrivateChat' ? Chat :
    T extends 'createBasicGroupChat' ? Chat :
    T extends 'createSupergroupChat' ? Chat :
    T extends 'createSecretChat' ? Chat :
    T extends 'createNewBasicGroupChat' ? Chat :
    T extends 'createNewSupergroupChat' ? Chat :
    T extends 'createNewSecretChat' ? Chat :
    T extends 'upgradeBasicGroupChatToSupergroupChat' ? Chat :
    T extends 'getChatListsToAddChat' ? ChatLists :
    T extends 'addChatToList' ? Ok :
    T extends 'getChatFolder' ? ChatFolder :
    T extends 'createChatFolder' ? ChatFolderInfo :
    T extends 'editChatFolder' ? ChatFolderInfo :
    T extends 'deleteChatFolder' ? Ok :
    T extends 'getChatFolderChatsToLeave' ? Chats :
    T extends 'getChatFolderChatCount' ? Count :
    T extends 'reorderChatFolders' ? Ok :
    T extends 'getRecommendedChatFolders' ? RecommendedChatFolders :
    T extends 'getChatFolderDefaultIconName' ? ChatFolderIcon :
    T extends 'getChatsForChatFolderInviteLink' ? Chats :
    T extends 'createChatFolderInviteLink' ? ChatFolderInviteLink :
    T extends 'getChatFolderInviteLinks' ? ChatFolderInviteLinks :
    T extends 'editChatFolderInviteLink' ? ChatFolderInviteLink :
    T extends 'deleteChatFolderInviteLink' ? Ok :
    T extends 'checkChatFolderInviteLink' ? ChatFolderInviteLinkInfo :
    T extends 'addChatFolderByInviteLink' ? Ok :
    T extends 'getChatFolderNewChats' ? Chats :
    T extends 'processChatFolderNewChats' ? Ok :
    T extends 'getArchiveChatListSettings' ? ArchiveChatListSettings :
    T extends 'setArchiveChatListSettings' ? Ok :
    T extends 'setChatTitle' ? Ok :
    T extends 'setChatPhoto' ? Ok :
    T extends 'setChatMessageAutoDeleteTime' ? Ok :
    T extends 'setChatPermissions' ? Ok :
    T extends 'setChatBackground' ? Ok :
    T extends 'setChatTheme' ? Ok :
    T extends 'setChatDraftMessage' ? Ok :
    T extends 'setChatNotificationSettings' ? Ok :
    T extends 'toggleChatHasProtectedContent' ? Ok :
    T extends 'toggleChatIsTranslatable' ? Ok :
    T extends 'toggleChatIsMarkedAsUnread' ? Ok :
    T extends 'toggleChatDefaultDisableNotification' ? Ok :
    T extends 'setChatAvailableReactions' ? Ok :
    T extends 'setChatClientData' ? Ok :
    T extends 'setChatDescription' ? Ok :
    T extends 'setChatDiscussionGroup' ? Ok :
    T extends 'setChatLocation' ? Ok :
    T extends 'setChatSlowModeDelay' ? Ok :
    T extends 'pinChatMessage' ? Ok :
    T extends 'unpinChatMessage' ? Ok :
    T extends 'unpinAllChatMessages' ? Ok :
    T extends 'unpinAllMessageThreadMessages' ? Ok :
    T extends 'joinChat' ? Ok :
    T extends 'leaveChat' ? Ok :
    T extends 'addChatMember' ? Ok :
    T extends 'addChatMembers' ? Ok :
    T extends 'setChatMemberStatus' ? Ok :
    T extends 'banChatMember' ? Ok :
    T extends 'canTransferOwnership' ? CanTransferOwnershipResult :
    T extends 'transferChatOwnership' ? Ok :
    T extends 'getChatMember' ? ChatMember :
    T extends 'searchChatMembers' ? ChatMembers :
    T extends 'getChatAdministrators' ? ChatAdministrators :
    T extends 'clearAllDraftMessages' ? Ok :
    T extends 'getSavedNotificationSound' ? NotificationSounds :
    T extends 'getSavedNotificationSounds' ? NotificationSounds :
    T extends 'addSavedNotificationSound' ? NotificationSound :
    T extends 'removeSavedNotificationSound' ? Ok :
    T extends 'getChatNotificationSettingsExceptions' ? Chats :
    T extends 'getScopeNotificationSettings' ? ScopeNotificationSettings :
    T extends 'setScopeNotificationSettings' ? Ok :
    T extends 'resetAllNotificationSettings' ? Ok :
    T extends 'toggleChatIsPinned' ? Ok :
    T extends 'setPinnedChats' ? Ok :
    T extends 'readChatList' ? Ok :
    T extends 'getStory' ? Story :
    T extends 'getChatsToSendStories' ? Chats :
    T extends 'canSendStory' ? CanSendStoryResult :
    T extends 'sendStory' ? Story :
    T extends 'editStory' ? Ok :
    T extends 'setStoryPrivacySettings' ? Ok :
    T extends 'toggleStoryIsPinned' ? Ok :
    T extends 'deleteStory' ? Ok :
    T extends 'getStoryNotificationSettingsExceptions' ? Chats :
    T extends 'loadActiveStories' ? Ok :
    T extends 'setChatActiveStoriesList' ? Ok :
    T extends 'getChatActiveStories' ? ChatActiveStories :
    T extends 'getChatPinnedStories' ? Stories :
    T extends 'getChatArchivedStories' ? Stories :
    T extends 'openStory' ? Ok :
    T extends 'closeStory' ? Ok :
    T extends 'getStoryAvailableReactions' ? AvailableReactions :
    T extends 'setStoryReaction' ? Ok :
    T extends 'getStoryViewers' ? StoryViewers :
    T extends 'reportStory' ? Ok :
    T extends 'activateStoryStealthMode' ? Ok :
    T extends 'getChatBoostStatus' ? ChatBoostStatus :
    T extends 'canBoostChat' ? CanBoostChatResult :
    T extends 'boostChat' ? Ok :
    T extends 'getChatBoostLink' ? ChatBoostLink :
    T extends 'getChatBoostLinkInfo' ? ChatBoostLinkInfo :
    T extends 'getChatBoosts' ? FoundChatBoosts :
    T extends 'getAttachmentMenuBot' ? AttachmentMenuBot :
    T extends 'toggleBotIsAddedToAttachmentMenu' ? Ok :
    T extends 'getThemedEmojiStatuses' ? EmojiStatuses :
    T extends 'getRecentEmojiStatuses' ? EmojiStatuses :
    T extends 'getDefaultEmojiStatuses' ? EmojiStatuses :
    T extends 'clearRecentEmojiStatuses' ? Ok :
    T extends 'downloadFile' ? File :
    T extends 'getFileDownloadedPrefixSize' ? FileDownloadedPrefixSize :
    T extends 'cancelDownloadFile' ? Ok :
    T extends 'getSuggestedFileName' ? Text :
    T extends 'preliminaryUploadFile' ? File :
    T extends 'cancelPreliminaryUploadFile' ? Ok :
    T extends 'writeGeneratedFilePart' ? Ok :
    T extends 'setFileGenerationProgress' ? Ok :
    T extends 'finishFileGeneration' ? Ok :
    T extends 'readFilePart' ? FilePart :
    T extends 'deleteFile' ? Ok :
    T extends 'addFileToDownloads' ? File :
    T extends 'toggleDownloadIsPaused' ? Ok :
    T extends 'toggleAllDownloadsArePaused' ? Ok :
    T extends 'removeFileFromDownloads' ? Ok :
    T extends 'removeAllFilesFromDownloads' ? Ok :
    T extends 'searchFileDownloads' ? FoundFileDownloads :
    T extends 'getMessageFileType' ? MessageFileType :
    T extends 'getMessageImportConfirmationText' ? Text :
    T extends 'importMessages' ? Ok :
    T extends 'replacePrimaryChatInviteLink' ? ChatInviteLink :
    T extends 'createChatInviteLink' ? ChatInviteLink :
    T extends 'editChatInviteLink' ? ChatInviteLink :
    T extends 'getChatInviteLink' ? ChatInviteLink :
    T extends 'getChatInviteLinkCounts' ? ChatInviteLinkCounts :
    T extends 'getChatInviteLinks' ? ChatInviteLinks :
    T extends 'getChatInviteLinkMembers' ? ChatInviteLinkMembers :
    T extends 'revokeChatInviteLink' ? ChatInviteLinks :
    T extends 'deleteRevokedChatInviteLink' ? Ok :
    T extends 'deleteAllRevokedChatInviteLinks' ? Ok :
    T extends 'checkChatInviteLink' ? ChatInviteLinkInfo :
    T extends 'joinChatByInviteLink' ? Chat :
    T extends 'getChatJoinRequests' ? ChatJoinRequests :
    T extends 'processChatJoinRequest' ? Ok :
    T extends 'processChatJoinRequests' ? Ok :
    T extends 'createCall' ? CallId :
    T extends 'acceptCall' ? Ok :
    T extends 'sendCallSignalingData' ? Ok :
    T extends 'discardCall' ? Ok :
    T extends 'sendCallRating' ? Ok :
    T extends 'sendCallDebugInformation' ? Ok :
    T extends 'sendCallLog' ? Ok :
    T extends 'getVideoChatAvailableParticipants' ? MessageSenders :
    T extends 'setVideoChatDefaultParticipant' ? Ok :
    T extends 'createVideoChat' ? GroupCallId :
    T extends 'getVideoChatRtmpUrl' ? RtmpUrl :
    T extends 'replaceVideoChatRtmpUrl' ? RtmpUrl :
    T extends 'getGroupCall' ? GroupCall :
    T extends 'startScheduledGroupCall' ? Ok :
    T extends 'toggleGroupCallEnabledStartNotification' ? Ok :
    T extends 'joinGroupCall' ? Text :
    T extends 'startGroupCallScreenSharing' ? Text :
    T extends 'toggleGroupCallScreenSharingIsPaused' ? Ok :
    T extends 'endGroupCallScreenSharing' ? Ok :
    T extends 'setGroupCallTitle' ? Ok :
    T extends 'toggleGroupCallMuteNewParticipants' ? Ok :
    T extends 'inviteGroupCallParticipants' ? Ok :
    T extends 'getGroupCallInviteLink' ? HttpUrl :
    T extends 'revokeGroupCallInviteLink' ? Ok :
    T extends 'startGroupCallRecording' ? Ok :
    T extends 'endGroupCallRecording' ? Ok :
    T extends 'toggleGroupCallIsMyVideoPaused' ? Ok :
    T extends 'toggleGroupCallIsMyVideoEnabled' ? Ok :
    T extends 'setGroupCallParticipantIsSpeaking' ? Ok :
    T extends 'toggleGroupCallParticipantIsMuted' ? Ok :
    T extends 'setGroupCallParticipantVolumeLevel' ? Ok :
    T extends 'toggleGroupCallParticipantIsHandRaised' ? Ok :
    T extends 'loadGroupCallParticipants' ? Ok :
    T extends 'leaveGroupCall' ? Ok :
    T extends 'endGroupCall' ? Ok :
    T extends 'getGroupCallStreams' ? GroupCallStreams :
    T extends 'getGroupCallStreamSegment' ? FilePart :
    T extends 'setMessageSenderBlockList' ? Ok :
    T extends 'blockMessageSenderFromReplies' ? Ok :
    T extends 'getBlockedMessageSenders' ? MessageSenders :
    T extends 'addContact' ? Ok :
    T extends 'importContacts' ? ImportedContacts :
    T extends 'getContacts' ? Users :
    T extends 'searchContacts' ? Users :
    T extends 'removeContacts' ? Ok :
    T extends 'getImportedContactCount' ? Count :
    T extends 'changeImportedContacts' ? ImportedContacts :
    T extends 'clearImportedContacts' ? Ok :
    T extends 'setCloseFriends' ? Ok :
    T extends 'getCloseFriends' ? Users :
    T extends 'setUserPersonalProfilePhoto' ? Ok :
    T extends 'suggestUserProfilePhoto' ? Ok :
    T extends 'searchUserByPhoneNumber' ? User :
    T extends 'sharePhoneNumber' ? Ok :
    T extends 'getUserProfilePhotos' ? ChatPhotos :
    T extends 'getStickers' ? Stickers :
    T extends 'getAllStickerEmojis' ? Emojis :
    T extends 'searchStickers' ? Stickers :
    T extends 'getPremiumStickers' ? Stickers :
    T extends 'getInstalledStickerSets' ? StickerSets :
    T extends 'getArchivedStickerSets' ? StickerSets :
    T extends 'getTrendingStickerSets' ? TrendingStickerSets :
    T extends 'getAttachedStickerSets' ? StickerSets :
    T extends 'getStickerSet' ? StickerSet :
    T extends 'searchStickerSet' ? StickerSet :
    T extends 'searchInstalledStickerSets' ? StickerSets :
    T extends 'searchStickerSets' ? StickerSets :
    T extends 'changeStickerSet' ? Ok :
    T extends 'viewTrendingStickerSets' ? Ok :
    T extends 'reorderInstalledStickerSets' ? Ok :
    T extends 'getRecentStickers' ? Stickers :
    T extends 'addRecentSticker' ? Stickers :
    T extends 'removeRecentSticker' ? Ok :
    T extends 'clearRecentStickers' ? Ok :
    T extends 'getFavoriteStickers' ? Stickers :
    T extends 'addFavoriteSticker' ? Ok :
    T extends 'removeFavoriteSticker' ? Ok :
    T extends 'getStickerEmojis' ? Emojis :
    T extends 'searchEmojis' ? Emojis :
    T extends 'getEmojiCategories' ? EmojiCategories :
    T extends 'getAnimatedEmoji' ? AnimatedEmoji :
    T extends 'getEmojiSuggestionsUrl' ? HttpUrl :
    T extends 'getCustomEmojiStickers' ? Stickers :
    T extends 'getDefaultChatPhotoCustomEmojiStickers' ? Stickers :
    T extends 'getDefaultProfilePhotoCustomEmojiStickers' ? Stickers :
    T extends 'getSavedAnimations' ? Animations :
    T extends 'addSavedAnimation' ? Ok :
    T extends 'removeSavedAnimation' ? Ok :
    T extends 'getRecentInlineBots' ? Users :
    T extends 'searchHashtags' ? Hashtags :
    T extends 'removeRecentHashtag' ? Ok :
    T extends 'getWebPagePreview' ? WebPage :
    T extends 'getWebPageInstantView' ? WebPageInstantView :
    T extends 'setProfilePhoto' ? Ok :
    T extends 'deleteProfilePhoto' ? Ok :
    T extends 'setName' ? Ok :
    T extends 'setBio' ? Ok :
    T extends 'setUsername' ? Ok :
    T extends 'toggleUsernameIsActive' ? Ok :
    T extends 'reorderActiveUsernames' ? Ok :
    T extends 'setEmojiStatus' ? Ok :
    T extends 'setLocation' ? Ok :
    T extends 'changePhoneNumber' ? AuthenticationCodeInfo :
    T extends 'resendChangePhoneNumberCode' ? AuthenticationCodeInfo :
    T extends 'checkChangePhoneNumberCode' ? Ok :
    T extends 'getUserLink' ? UserLink :
    T extends 'searchUserByToken' ? User :
    T extends 'setCommands' ? Ok :
    T extends 'deleteCommands' ? Ok :
    T extends 'getCommands' ? BotCommands :
    T extends 'setMenuButton' ? Ok :
    T extends 'getMenuButton' ? BotMenuButton :
    T extends 'setDefaultGroupAdministratorRights' ? Ok :
    T extends 'setDefaultChannelAdministratorRights' ? Ok :
    T extends 'canBotSendMessages' ? Ok :
    T extends 'allowBotToSendMessages' ? Ok :
    T extends 'sendWebAppCustomRequest' ? CustomRequestResult :
    T extends 'setBotName' ? Ok :
    T extends 'getBotName' ? Text :
    T extends 'setBotProfilePhoto' ? Ok :
    T extends 'toggleBotUsernameIsActive' ? Ok :
    T extends 'reorderBotActiveUsernames' ? Ok :
    T extends 'setBotInfoDescription' ? Ok :
    T extends 'getBotInfoDescription' ? Text :
    T extends 'setBotInfoShortDescription' ? Ok :
    T extends 'getBotInfoShortDescription' ? Text :
    T extends 'getActiveSessions' ? Sessions :
    T extends 'terminateSession' ? Ok :
    T extends 'terminateAllOtherSessions' ? Ok :
    T extends 'confirmSession' ? Ok :
    T extends 'toggleSessionCanAcceptCalls' ? Ok :
    T extends 'toggleSessionCanAcceptSecretChats' ? Ok :
    T extends 'setInactiveSessionTtl' ? Ok :
    T extends 'getConnectedWebsites' ? ConnectedWebsites :
    T extends 'disconnectWebsite' ? Ok :
    T extends 'disconnectAllWebsites' ? Ok :
    T extends 'setSupergroupUsername' ? Ok :
    T extends 'toggleSupergroupUsernameIsActive' ? Ok :
    T extends 'disableAllSupergroupUsernames' ? Ok :
    T extends 'reorderSupergroupActiveUsernames' ? Ok :
    T extends 'setSupergroupStickerSet' ? Ok :
    T extends 'toggleSupergroupSignMessages' ? Ok :
    T extends 'toggleSupergroupJoinToSendMessages' ? Ok :
    T extends 'toggleSupergroupJoinByRequest' ? Ok :
    T extends 'toggleSupergroupIsAllHistoryAvailable' ? Ok :
    T extends 'toggleSupergroupHasHiddenMembers' ? Ok :
    T extends 'toggleSupergroupHasAggressiveAntiSpamEnabled' ? Ok :
    T extends 'toggleSupergroupIsForum' ? Ok :
    T extends 'toggleSupergroupIsBroadcastGroup' ? Ok :
    T extends 'reportSupergroupSpam' ? Ok :
    T extends 'reportSupergroupAntiSpamFalsePositive' ? Ok :
    T extends 'getSupergroupMembers' ? ChatMembers :
    T extends 'closeSecretChat' ? Ok :
    T extends 'getChatEventLog' ? ChatEvents :
    T extends 'getPaymentForm' ? PaymentForm :
    T extends 'validateOrderInfo' ? ValidatedOrderInfo :
    T extends 'sendPaymentForm' ? PaymentResult :
    T extends 'getPaymentReceipt' ? PaymentReceipt :
    T extends 'getSavedOrderInfo' ? OrderInfo :
    T extends 'deleteSavedOrderInfo' ? Ok :
    T extends 'deleteSavedCredentials' ? Ok :
    T extends 'createInvoiceLink' ? HttpUrl :
    T extends 'getSupportUser' ? User :
    T extends 'getBackgrounds' ? Backgrounds :
    T extends 'getBackgroundUrl' ? HttpUrl :
    T extends 'searchBackground' ? Background :
    T extends 'setBackground' ? Background :
    T extends 'removeBackground' ? Ok :
    T extends 'resetBackgrounds' ? Ok :
    T extends 'getLocalizationTargetInfo' ? LocalizationTargetInfo :
    T extends 'getLanguagePackInfo' ? LanguagePackInfo :
    T extends 'getLanguagePackStrings' ? LanguagePackStrings :
    T extends 'synchronizeLanguagePack' ? Ok :
    T extends 'addCustomServerLanguagePack' ? Ok :
    T extends 'setCustomLanguagePack' ? Ok :
    T extends 'editCustomLanguagePackInfo' ? Ok :
    T extends 'setCustomLanguagePackString' ? Ok :
    T extends 'deleteLanguagePack' ? Ok :
    T extends 'registerDevice' ? PushReceiverId :
    T extends 'processPushNotification' ? Ok :
    T extends 'getPushReceiverId' ? PushReceiverId :
    T extends 'getRecentlyVisitedTMeUrls' ? TMeUrls :
    T extends 'setUserPrivacySettingRules' ? Ok :
    T extends 'getUserPrivacySettingRules' ? UserPrivacySettingRules :
    T extends 'getOption' ? OptionValue :
    T extends 'setOption' ? Ok :
    T extends 'setAccountTtl' ? Ok :
    T extends 'getAccountTtl' ? AccountTtl :
    T extends 'deleteAccount' ? Ok :
    T extends 'setDefaultMessageAutoDeleteTime' ? Ok :
    T extends 'getDefaultMessageAutoDeleteTime' ? MessageAutoDeleteTime :
    T extends 'removeChatActionBar' ? Ok :
    T extends 'reportChat' ? Ok :
    T extends 'reportChatPhoto' ? Ok :
    T extends 'reportMessageReactions' ? Ok :
    T extends 'getChatStatistics' ? ChatStatistics :
    T extends 'getMessageStatistics' ? MessageStatistics :
    T extends 'getStatisticalGraph' ? StatisticalGraph :
    T extends 'getStorageStatistics' ? StorageStatistics :
    T extends 'getStorageStatisticsFast' ? StorageStatisticsFast :
    T extends 'getDatabaseStatistics' ? DatabaseStatistics :
    T extends 'optimizeStorage' ? StorageStatistics :
    T extends 'setNetworkType' ? Ok :
    T extends 'getNetworkStatistics' ? NetworkStatistics :
    T extends 'addNetworkStatistics' ? Ok :
    T extends 'resetNetworkStatistics' ? Ok :
    T extends 'getAutoDownloadSettingsPresets' ? AutoDownloadSettingsPresets :
    T extends 'setAutoDownloadSettings' ? Ok :
    T extends 'getAutosaveSettings' ? AutosaveSettings :
    T extends 'setAutosaveSettings' ? Ok :
    T extends 'clearAutosaveSettingsExceptions' ? Ok :
    T extends 'getBankCardInfo' ? BankCardInfo :
    T extends 'getPassportElement' ? PassportElement :
    T extends 'getAllPassportElements' ? PassportElements :
    T extends 'setPassportElement' ? PassportElement :
    T extends 'deletePassportElement' ? Ok :
    T extends 'setPassportElementErrors' ? Ok :
    T extends 'getPreferredCountryLanguage' ? Text :
    T extends 'sendPhoneNumberVerificationCode' ? AuthenticationCodeInfo :
    T extends 'resendPhoneNumberVerificationCode' ? AuthenticationCodeInfo :
    T extends 'checkPhoneNumberVerificationCode' ? Ok :
    T extends 'sendEmailAddressVerificationCode' ? EmailAddressAuthenticationCodeInfo :
    T extends 'resendEmailAddressVerificationCode' ? EmailAddressAuthenticationCodeInfo :
    T extends 'checkEmailAddressVerificationCode' ? Ok :
    T extends 'getPassportAuthorizationForm' ? PassportAuthorizationForm :
    T extends 'getPassportAuthorizationFormAvailableElements' ? PassportElementsWithErrors :
    T extends 'sendPassportAuthorizationForm' ? Ok :
    T extends 'sendPhoneNumberConfirmationCode' ? AuthenticationCodeInfo :
    T extends 'resendPhoneNumberConfirmationCode' ? AuthenticationCodeInfo :
    T extends 'checkPhoneNumberConfirmationCode' ? Ok :
    T extends 'setBotUpdatesStatus' ? Ok :
    T extends 'uploadStickerFile' ? File :
    T extends 'getSuggestedStickerSetName' ? Text :
    T extends 'checkStickerSetName' ? CheckStickerSetNameResult :
    T extends 'createNewStickerSet' ? StickerSet :
    T extends 'addStickerToSet' ? Ok :
    T extends 'setStickerSetThumbnail' ? Ok :
    T extends 'setCustomEmojiStickerSetThumbnail' ? Ok :
    T extends 'setStickerSetTitle' ? Ok :
    T extends 'deleteStickerSet' ? Ok :
    T extends 'setStickerPositionInSet' ? Ok :
    T extends 'removeStickerFromSet' ? Ok :
    T extends 'setStickerEmojis' ? Ok :
    T extends 'setStickerKeywords' ? Ok :
    T extends 'setStickerMaskPosition' ? Ok :
    T extends 'getMapThumbnailFile' ? File :
    T extends 'getPremiumLimit' ? PremiumLimit :
    T extends 'getPremiumFeatures' ? PremiumFeatures :
    T extends 'getPremiumStickerExamples' ? Stickers :
    T extends 'viewPremiumFeature' ? Ok :
    T extends 'clickPremiumSubscriptionButton' ? Ok :
    T extends 'getPremiumState' ? PremiumState :
    T extends 'canPurchasePremium' ? Ok :
    T extends 'assignAppStoreTransaction' ? Ok :
    T extends 'assignGooglePlayTransaction' ? Ok :
    T extends 'acceptTermsOfService' ? Ok :
    T extends 'searchStringsByPrefix' ? FoundPositions :
    T extends 'sendCustomRequest' ? CustomRequestResult :
    T extends 'answerCustomQuery' ? Ok :
    T extends 'setAlarm' ? Ok :
    T extends 'getCountries' ? Countries :
    T extends 'getCountryCode' ? Text :
    T extends 'getPhoneNumberInfo' ? PhoneNumberInfo :
    T extends 'getPhoneNumberInfoSync' ? PhoneNumberInfo :
    T extends 'getDeepLinkInfo' ? DeepLinkInfo :
    T extends 'getApplicationConfig' ? JsonValue :
    T extends 'addApplicationChangelog' ? Ok :
    T extends 'saveApplicationLogEvent' ? Ok :
    T extends 'getApplicationDownloadLink' ? HttpUrl :
    T extends 'addProxy' ? Proxy :
    T extends 'editProxy' ? Proxy :
    T extends 'enableProxy' ? Ok :
    T extends 'disableProxy' ? Ok :
    T extends 'removeProxy' ? Ok :
    T extends 'getProxies' ? Proxies :
    T extends 'getProxyLink' ? HttpUrl :
    T extends 'pingProxy' ? Seconds :
    T extends 'setLogStream' ? Ok :
    T extends 'getLogStream' ? LogStream :
    T extends 'setLogVerbosityLevel' ? Ok :
    T extends 'getLogVerbosityLevel' ? LogVerbosityLevel :
    T extends 'getLogTags' ? LogTags :
    T extends 'setLogTagVerbosityLevel' ? Ok :
    T extends 'getLogTagVerbosityLevel' ? LogVerbosityLevel :
    T extends 'addLogMessage' ? Ok :
    T extends 'getUserSupportInfo' ? UserSupportInfo :
    T extends 'setUserSupportInfo' ? UserSupportInfo :
    T extends 'getSupportName' ? Text :
    T extends 'testCallEmpty' ? Ok :
    T extends 'testCallString' ? TestString :
    T extends 'testCallBytes' ? TestBytes :
    T extends 'testCallVectorInt' ? TestVectorInt :
    T extends 'testCallVectorIntObject' ? TestVectorIntObject :
    T extends 'testCallVectorString' ? TestVectorString :
    T extends 'testCallVectorStringObject' ? TestVectorStringObject :
    T extends 'testSquareInt' ? TestInt :
    T extends 'testNetwork' ? Ok :
    T extends 'testProxy' ? Ok :
    T extends 'testGetDifference' ? Ok :
    T extends 'testUseUpdate' ? Update :
    T extends 'testReturnError' ? Error :
  never)
}
